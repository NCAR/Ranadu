#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={Wind Uncertainty TN file}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A Kalman filter to apply corrections to the wind measurements
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilter"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/Ranadu/KalmanFilter')
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Introduction and scope
\end_layout

\begin_layout Standard
The intent of this study is to evaluate the errors present in the measurements
 of attitude angles from the IRU on the NSF/NCAR
\begin_inset space ~
\end_inset

GV by means of a Kalman filter applied to the difference between measurements
 from a GPS and corresponding measurements from the IRU.
 The redundant measurements are those of position and velocity,
\begin_inset Foot
status open

\begin_layout Plain Layout
Because GPS measurements of velocity have low uncertainty, those measurements
 could be differentiated and, after transformation to the aircraft reference
 frame, used as error measurements for the measured accelerations.
 This has not been explored as yet, and it is not clear that this would
 provide information beyond that arising from the Kalman-filter updates
 using only velocity.
\end_layout

\end_inset

 for which the GPS measurements are clearly superior especially at low rate,
 so a necessary result will be that the corrected measurements should be
 quite close to those from the GPS.
 The advantage of this analysis, though, is that the coupling between errors
 in the attitude angles and those in velocity makes it possible to evaluate
 the errors in the attitude angles also.
\end_layout

\begin_layout Standard
Before describing the implementation of the filter, it is useful to explain
 the basic concept underlying a Kalman filter.
 A Kalman filter provides a means of updating a sequence of state vectors
 (consisting, in the present case, of INS measurements of position, velocity,
 and attitude angles) by comparison to an independent set of measurements
 (e.g., GPS-derived measurements of position and velocity).
 The updated state vector obtained by this process consists of an appropriately
 weighted combination of the state vector projected forward using normal
 INS 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 (i.e., determining the next step by using the measured acceleration and rotation
 from the IRU) and the independent measurements from GPS.
 Because errors in the state vector are coupled, the update procedure can
 estimate errors in the attitude angles as well as the components of the
 state vector that are measured directly by the GPS.
 This is the primary reason for using a Kalman filter to improve the wind
 measurements: Although the measurements of position and velocity that result
 should differ little from those provided by the GPS, the corrections to
 the attitude angles (pitch, roll, and heading) can be estimated even though
 there is no direct measurement of these except from the INS.
\end_layout

\begin_layout Standard
The weighting of the projected-forward state and new measurements from GPS
 depends on obtaining estimates of the covariance matrix describing the
 state vector as well as estimates of the noise sources contaminating the
 measurements from both the GPS and the IRU-provided accelerations and rotations.
 With proper weighting, the result should combine the good high-frequency
 response of the INS with the good long-term stability of the GPS.
 The covariance matrix characterizing the state vector is updated as the
 filter is applied, but appropriate weighting depends on reasonable estimation
 of the other error terms.
\end_layout

\begin_layout Standard
The operation of the filter depends on sequential use of a set of matrices,
 so it is useful to define those as follows, where the variable names following
 the symbols are the R variable names used in the following code:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{x}_{k}$
\end_inset


\begin_inset space ~
\end_inset

[SVE] The error-state vector at time interval 
\begin_inset Formula $k$
\end_inset

.
 In the present case, this consists of the 15 components estimated errors
 in position, aircraft velocity, aircraft attitude, IRU-measured rotation
 rate, and IRU-measured accelerations.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{T}_{k|k-1}$
\end_inset


\begin_inset space ~
\end_inset

[dcm] The 15x15 state transformation matrix describing INS mechanism for
 the change from time 
\begin_inset Formula $k-1$
\end_inset

 to time 
\begin_inset Formula $k$
\end_inset

.
 Then 
\begin_inset Formula $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
\end_inset

 where 
\begin_inset Formula $\mathbf{T}$
\end_inset

 combines the unit diagonal matrix with the time step multiplied by the
 derivative matrix describing the state transformation.
 As applied to the state vector, this state transformation matrix would
 involve the derivatives used for normal INS mechanization to get how the
 state vector advances, and so would duplicate the action of the internal
 INS data processing.
 As interpreted for an error-state Kalman filter, the matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is obtained by calculating the Jacobian of that state-transition function
 as a function of the error-state components.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{V}$
\end_inset


\begin_inset space ~
\end_inset

[CV] The covariance matrix that applies to the state vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

, a 15x15 matrix
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}$
\end_inset


\begin_inset space ~
\end_inset

[K] The Kalman-gain matrix representing how the error-state vector is updated
 using the current error state and the new GPS measurements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{z}$
\end_inset


\begin_inset space ~
\end_inset

[DZ] The 6-component measured differences between the INS and GPS measurements
 of position and velocity.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{H}$
\end_inset


\begin_inset space ~
\end_inset

[H] The 15x6-component matrix representing how the measured differences
 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 correspond to the state vector.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{Q},\,\mathbf{R}$
\end_inset


\begin_inset space ~
\end_inset

[Q,
\begin_inset space ~
\end_inset

R] Matrics representing respectively the anticipated noise contributions
 affecting the error-state vector (15x15) and the measurements from the
 GPS (6x6).
\end_layout

\begin_layout Standard
The approach taken here will be to filter the error-state vector that represents
 the difference between the best-estimate measurements and those originally
 provided by the INS.
 The INS integration does not need to be duplicated here to obtain the reference
 solution because that is already available.
 However, the Kalman filter does need the 
\begin_inset Quotes eld
\end_inset

state transition matrix
\begin_inset Quotes erd
\end_inset

 that represents the forward integration, so the first step in this analysis
 is to obtain such a matrix and validate results using it against the available
 INS solution.
 The Jacobian of that state-transition function then provides the matrix
 
\begin_inset Formula $\mathbf{T}$
\end_inset

 used in this filter.
\end_layout

\begin_layout Section*
Some component functions
\end_layout

\begin_layout Standard
Some of the operations involved in that 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 are contained in the following functions, with code as in the associated
 R 
\begin_inset Quotes eld
\end_inset

chunks.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate

\emph on
\bar under
XfLArV()
\emph default
\bar default
, a function of the current state vector, provides a 3x3 matrix that transforms
 a vector from the a-frame (the aircraft reference frame) to the l-frame,
 the local-level frame (with {x,y,z} coordinates toward the East, North,
 and upward directions).
 
\end_layout

\begin_layout Enumerate

\emph on
\bar under
RotationCorrection()
\emph default
\bar default
 calculates the correction to accelerations needed to account for the rotation
 of the Earth and of the l-frame relative to an inertial frame.
 This function provides corrections to subtract from transformed accelerations
 before using them in the l-frame.
\end_layout

\begin_layout Enumerate

\emph on
\bar under
STMFV()
\emph default
\bar default
 calculates the 15-component derivative of the state vector given the state
 vector and the measurements from the INU.
 This function is then used in the R function numDeriv::jacobian to find
 the Jacobian needed for the state transformation matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XfLArV <- function (data) {   ## XfLA but using input in radians and single
 row
\end_layout

\begin_layout Plain Layout

  # data must contain PITCH, ROLL, HEADING as components [7:9]
\end_layout

\begin_layout Plain Layout

  cosphi <- cos (data[8])
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (data[8])
\end_layout

\begin_layout Plain Layout

  costheta <- cos (data[7])
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (data[7])
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (data[9])
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (data[9])
\end_layout

\begin_layout Plain Layout

  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-
sinpsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinph
i-cospsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           -sintheta, costheta*sinphi, -costheta*cosphi)
\end_layout

\begin_layout Plain Layout

  RblM <- aperm( array (Rbl, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  return (RblM)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# other-functions ---------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

dt <- 1/25               ## working with 25-Hz file
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

Ree <- 6378137
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

## The next correction calculates the correction needed to account for the
 rotation
\end_layout

\begin_layout Plain Layout

## of the Earth and of the l-frame (ENU frame).
 See Noureldin et al., 2013, 
\end_layout

\begin_layout Plain Layout

## Eqs.
 5.55--5.57.
 Subtract this from the transformed accelerations before using them.
\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  Ree <- 6378137
\end_layout

\begin_layout Plain Layout

  Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
\end_layout

\begin_layout Plain Layout

  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Gravity <- function (latitude, altitude=0.) {
\end_layout

\begin_layout Plain Layout

  sl2 <- (sin (latitude * Cradeg))^2
\end_layout

\begin_layout Plain Layout

  g <- 9.780327 * ((1.
 + 0.001931851 * sl2) / 
\end_layout

\begin_layout Plain Layout

                     (1.
 - 0.006694380 * sl2)) - 3.086e-6 * altitude
\end_layout

\begin_layout Plain Layout

  ## Somigliana formula 1980 GRS:
\end_layout

\begin_layout Plain Layout

  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
\end_layout

\begin_layout Plain Layout

  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 *
 altitude^2
\end_layout

\begin_layout Plain Layout

  return(g)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
\end_layout

\begin_layout Plain Layout

  (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

STMFV <- function (sv, .aaframe='a') { 
\end_layout

\begin_layout Plain Layout

  stmf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  ## transform back to a-frame if necessary
\end_layout

\begin_layout Plain Layout

  if (.aaframe == 'l') {
\end_layout

\begin_layout Plain Layout

    svv1 <- cos (sv[9]) * sv[7] + sin (sv[9]) * sv[8]
\end_layout

\begin_layout Plain Layout

    sv[8] <- -sin(sv[9]) * sv[7] + cos(sv[9]) * sv[8]
\end_layout

\begin_layout Plain Layout

    sv[7] <- svv1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  rlm <- XfLArV(sv)    
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/(Rn),
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
\end_layout

\begin_layout Plain Layout

  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2],
 omega[1], 0), ncol=3)
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  ## find the derivative of the transformation matrix:
\end_layout

\begin_layout Plain Layout

  ## (must recalculate SRM from measured rotation rates)
\end_layout

\begin_layout Plain Layout

  SRR <- c(0, -sv[12], -sv[10],
\end_layout

\begin_layout Plain Layout

           sv[12], 0, sv[11],
\end_layout

\begin_layout Plain Layout

           sv[10], -sv[11], 0)
\end_layout

\begin_layout Plain Layout

  SRM <- aperm( array (SRR, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  dRLA <- rlm %*% SRM - Oilb
\end_layout

\begin_layout Plain Layout

  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
\end_layout

\begin_layout Plain Layout

  # G <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch
 and roll!
\end_layout

\begin_layout Plain Layout

  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-fra
me
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
\end_layout

\begin_layout Plain Layout

  ## now correct for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  VL <- c(sv[4], sv[5], sv[6])
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3)
\end_layout

\begin_layout Plain Layout

  lat <- sv[1]
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  C[1] <- M12 * VL[2] + M13 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[2] <- M21 * VL[1] + M23 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[3] <- M31 * VL[1] + M32 * VL[2]
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (AL - C, mode='numeric')
\end_layout

\begin_layout Plain Layout

  AL[3] <- AL[3] + Grav
\end_layout

\begin_layout Plain Layout

  AL[3] <- -AL[3]
\end_layout

\begin_layout Plain Layout

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
\end_layout

\begin_layout Plain Layout

              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
\end_layout

\begin_layout Plain Layout

              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
\end_layout

\begin_layout Plain Layout

            0, 0, 0, 0, 0, 0)
\end_layout

\begin_layout Plain Layout

  return (as.vector (stmf, mode='numeric'))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR + 0.0005
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

# SP$BLATA <- SP$BLATA * 1.1
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
The integration steps
\end_layout

\begin_layout Standard
The purpose of this section is to demonstrate that the INS mechanization
 used to find the error-state transformation matrix provides a valid and
 independent means of propagating the measurements of position, velocity,
 and attitude forward in time.
 The procedure used for this test is as follows:
\end_layout

\begin_layout Enumerate
Initialize a state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

 having these components:
\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the l-frame
\end_layout

\begin_layout Enumerate
east velocity, north velocity, upward velocity in the l-frame
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the a-frame
\end_layout

\begin_layout Enumerate
rotation rates about the pitch, roll, and yaw axes of the aircraft
\end_layout

\begin_layout Enumerate
acceleration in the lateral, longitudinal, and normal direction relative
 to the aircraft reference frame.
\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\end_layout

\begin_deeper
\begin_layout Enumerate
store the measured rotations and accelerations in the last 6 components
 of the state vector
\end_layout

\begin_layout Enumerate
via the function STMFV, calculated the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the a-frame to the l-frame and then using
 the definition of components of that matrix to find the derivative of the
 attitude angles.
\end_layout

\begin_layout Enumerate
use that derivative vector to increment the state vector
\end_layout

\begin_layout Enumerate
compensate for possible wrap-around of the heading a 0 and 360 deg so that
 values stay within that range.
\end_layout

\begin_layout Enumerate
save the first 9 components of the state vector in a new data.frame that
 represents an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the INS
 solution.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, echo=TRUE, fig.lp='fig:', fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH,
 ROLL, THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$GGALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

Rn <- SP$Rn[1]
\end_layout

\begin_layout Plain Layout

Rm <- SP$Rm[1]
\end_layout

\begin_layout Plain Layout

Grav <- SP$Grav[1]
\end_layout

\begin_layout Plain Layout

stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

## feedback coefficients for baro loop:
\end_layout

\begin_layout Plain Layout

C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
\end_layout

\begin_layout Plain Layout

wp3F <- 0;
\end_layout

\begin_layout Plain Layout

hxF <- hxxF <- 0
\end_layout

\begin_layout Plain Layout

hi3F <- SP$GGALT[1]
\end_layout

\begin_layout Plain Layout

RK <- TRUE    ## use Runge-Kutta integration if true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (i in 2:DL) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i]
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i]
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i]
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  if (RK) {
\end_layout

\begin_layout Plain Layout

    stmf1 <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

    sv1 <- sv + stmf1 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf2 <- STMFV (sv1)
\end_layout

\begin_layout Plain Layout

    sv2 <- sv + stmf2 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf3 <- STMFV (sv2)
\end_layout

\begin_layout Plain Layout

    sv3 <- sv + stmf3 * dt
\end_layout

\begin_layout Plain Layout

    stmf4 <- STMFV (sv3)
\end_layout

\begin_layout Plain Layout

    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  ## baro-loop
\end_layout

\begin_layout Plain Layout

  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
\end_layout

\begin_layout Plain Layout

  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
\end_layout

\begin_layout Plain Layout

  hxF <- hi3F - SP$GGALT[i]
\end_layout

\begin_layout Plain Layout

  hxxF <- hxxF + hxF * dt
\end_layout

\begin_layout Plain Layout

  sv[6] <- 0.5 * (sv[6] + wp3F)
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparis
on of INS-provided and integration-derived positions.', 'Comparison of INS-provid
ed and integration-derived components of the aircraft velocity.', 'Comparison
 of INS-provided and integration-derived attitude angles.')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 33000, 35500)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LON', 'LONX')])
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
\end_layout

\begin_layout Plain Layout

## find attitude angles from RaLM:
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
\end_layout

\begin_layout Plain Layout

lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

SP <- SPR    ## restore to state before integration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result of that integration is shown in Figs.
\begin_inset space ~
\end_inset

1--3, with comparisons to the INS-produced solutions.
 There are some differences, but they are mostly understandable and could
 be corrected.
 For example, the attitude angles show differences in sine waves during
 the circles flown during this time segment and suggest a timing error that
 causes one signal to be delayed relative to the comparable signal.
 The INS-produced solution for altitude has a baro-loop applied to keep
 the altitude near the pressure altitude, and that is not applied in this
 solution so the vertical wind and position show large drifts.
 Perhaps the one aspect that is troublesome is that in VNS and consequently
 in latitude.
 Also, the data used here are the 25-Hz records, while the INS uses a significan
tly higher data rate for its corresponding integration.
 The remaining differences need further investigation, but the key result
 from this part of the study is that as implemented above the derivatives
 of components of the state vector are approximately correct and integrate
 to reasonable values.
 The function providing those derivatives is therefore a reasonable basis
 for the Kalman filter that follows.
\end_layout

\begin_layout Section*
The Kalman filter
\end_layout

\begin_layout Standard
The preceding steps verify that at least an approximate calculation of the
 derivatives of the state variables is available.
 On that basis, an error-state Kalman filter can be developed, as follows:
\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position and velocity.
 Other errors are unknown at the start of the integration and so will be
 initialized as zero.
\end_layout

\begin_layout Enumerate
The covariance matrix characterizing the errors in the error-state-vector
 is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\Phi$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units escelt those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides at least an approximate
 calculation of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function of the state vector, so the
 state transition matrix is the sum of that Jacobian (multiplied by the
 time step) and the 15-element diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF.
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are known, the covariance matrix can be updated via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X6 diagonal matrix representing how the 6 measured differences (GPS-INS)
 correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise-covariance matrix representing the GPS noise,
 a 6x6 matrix having diagonal elements that are the squares of these components:
 {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1}.
\end_layout

\begin_layout Enumerate
Define 
\series bold

\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 
\series default
as the set of six measurements consisting of the differences between GPS
 and INS positions and velocities.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate, because it is expected that the errors vary slowly.
 Turns and other maneuvers can introduce spurious effects if time delays
 are not adjusted well.
 For these reasons, a 1-Hz data file will be used for the following example,
 and the measurements of components of the velocity and of the attitude
 angles as well as the rotation rates and accelerations will be smoothed
 before applying the Kalman filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-s smoothing of accelerations and 301-s smoothing of measured velocity
 components and attitude angles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DW"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

D1 <- getNetCDF (fname, VarList)
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

dt <- 1
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2
 + D1$GGALT)
\end_layout

\begin_layout Plain Layout

  #interpolate if necessary:
\end_layout

\begin_layout Plain Layout

  MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  ## smooth the measurements
\end_layout

\begin_layout Plain Layout

  .span <- 11    
\end_layout

\begin_layout Plain Layout

  ## The following are accelerations determined from derivatives of the
 GPS velocities.
\end_layout

\begin_layout Plain Layout

  ## These should match the measured accelerations after transformation
 to the l-frame
\end_layout

\begin_layout Plain Layout

  ## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  ## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

  G <- D1$Grav
\end_layout

\begin_layout Plain Layout

  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection
 (D1, VL)
\end_layout

\begin_layout Plain Layout

  AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

  AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

  fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

  fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

  fa3 <- lm(D1$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

  AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

  ## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  AL <- AL - RotationCorrection (D1, VL)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  .span <- 301
\end_layout

\begin_layout Plain Layout

  SMOOTH <- FALSE
\end_layout

\begin_layout Plain Layout

  if (SMOOTH) {
\end_layout

\begin_layout Plain Layout

    vns <- signal::sgolayfilt (vns, 3, .span)
\end_layout

\begin_layout Plain Layout

    vew <- signal::sgolayfilt (vew, 3, .span)
\end_layout

\begin_layout Plain Layout

    vspd <- signal::sgolayfilt (vspd, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvns <- signal::sgolayfilt (ggvns, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvew <- signal::sgolayfilt (ggvew, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
\end_layout

\begin_layout Plain Layout

    pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
\end_layout

\begin_layout Plain Layout

    roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
\end_layout

\begin_layout Plain Layout

    thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    D1$VNSF <- vns
\end_layout

\begin_layout Plain Layout

    D1$VEWF <- vew
\end_layout

\begin_layout Plain Layout

    D1$VSPDF <- vspd
\end_layout

\begin_layout Plain Layout

    D1$GGVNSF <- ggvns
\end_layout

\begin_layout Plain Layout

    D1$GGVEWF <- ggvew
\end_layout

\begin_layout Plain Layout

    D1$GGVSPDF <- ggvspd
\end_layout

\begin_layout Plain Layout

    D1$PITCHF <- pitch
\end_layout

\begin_layout Plain Layout

    D1$ROLLF <- roll
\end_layout

\begin_layout Plain Layout

    D1$THDGF <- thdg
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## get the pitch and roll in the l-frame:
\end_layout

\begin_layout Plain Layout

.thdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

D1$PITCHL <- D1$PITCH * cos (.thdg) - D1$ROLL * sin (.thdg)
\end_layout

\begin_layout Plain Layout

D1$ROLLL <-  D1$PITCH * sin (.thdg) + D1$ROLL * cos (.thdg)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fm1 <- lm (vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the a-frame and compared to the measured accelerat
ions from the IRU (with correction for the Earth's rotation and the motion
 of the l-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

., with a residual standard error of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The differentiated measurements of velocity components from the GPS might
 be considered as additional measurements corresponding to the measured
 accelerations, but this will not be part of this initial study because
 the accelerometers appear to have low uncertainty and because the effect
 of errors in acceleration would also appear as errors in velocity and so
 should be detected by the conventional 6-component measurement vector for
 Kalman filtering.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## also need the noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 100 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 100 / (sp$Rn * cos (sv[1]))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 50
\end_layout

\begin_layout Plain Layout

  gcf[4:6] <- 0.5
\end_layout

\begin_layout Plain Layout

  gcf[7:9] <- 0.05*Cradeg
\end_layout

\begin_layout Plain Layout

  gcf[10:12] <- 0.05*Cradeg*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.002*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

i <- 1
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[i, ]))
\end_layout

\begin_layout Plain Layout

# Gnoise <- gcf * rnorm(15)
\end_layout

\begin_layout Plain Layout

# dsve <- dcm %*% SVE   # + Gnoise
\end_layout

\begin_layout Plain Layout

# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model:
\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS,
 VSPD-GGVSPD))
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 6)
\end_layout

\begin_layout Plain Layout

DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the observation matrix: (the first six components of the state error
 vector are observable)
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=6, ncol=15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

## GPS measurement noise
\end_layout

\begin_layout Plain Layout

RN <- c(50/D1$Rm[1], 50/(D1$Rn[1]*cos(SV[1])), 10, 0.1, 0.1, 0.1)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,36), ncol=6)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (50/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (50/(D1$Rn[1]*cos(SV[1])))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 100^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 0.1^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 0.1^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 0.1^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, echo=TRUE, eval=TRUE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- D1
\end_layout

\begin_layout Plain Layout

DL <- nrow (Data)
\end_layout

\begin_layout Plain Layout

s <- -120
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

SHIFT <- FALSE
\end_layout

\begin_layout Plain Layout

if (SHIFT) {
\end_layout

\begin_layout Plain Layout

  Data$GGVEW <- ShiftInTime (Data$GGVEW, Rate, s)    ## this is needed for
 pitch correction
\end_layout

\begin_layout Plain Layout

  Data$GGVNS <- ShiftInTime (Data$GGVNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  # Data$BLONGA <- ShiftInTime (Data$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BLATA <- ShiftInTime (Data$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BNORMA <- ShiftInTime (Data$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  # find PITCHL, ROLLL in the l-frame
\end_layout

\begin_layout Plain Layout

  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal
 to AC
\end_layout

\begin_layout Plain Layout

  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
\end_layout

\begin_layout Plain Layout

  # UVL <- XformLA (Data, UV)
\end_layout

\begin_layout Plain Layout

  # PitchL <- asin (-UVL[,2])
\end_layout

\begin_layout Plain Layout

  # RollL <- asin (UVL[,1])
\end_layout

\begin_layout Plain Layout

  #   .hdg <- Data$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## note: using l-frame PITCH and ROLL; STMFV must account for this
\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

NSTEP <- 5      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

CVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

CVEF[1, ] <- diag (CV)
\end_layout

\begin_layout Plain Layout

RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
\end_layout

\begin_layout Plain Layout

Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
\end_layout

\begin_layout Plain Layout

for (i in seq(2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL,
 ROLLL, THDG,
\end_layout

\begin_layout Plain Layout

                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- Data$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- Data$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- Data$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv, .aaframe='l') * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new state vector:
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE
\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

  CVEF[i/NSTEP, ] <- diag(CV)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

  IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

    if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

    x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

    T <- A$y
\end_layout

\begin_layout Plain Layout

    T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

    ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

    n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

    NL = length(T)
\end_layout

\begin_layout Plain Layout

    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

    return (T)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

  dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

  VCor <- vector ('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

  dim (VCor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

  X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

  for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

    VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ALTKF <- Data$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

  Data$VEWKF <- Data$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

  Data$VNSKF <- Data$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

  Data$VSPDKF <- Data$VSPD - Cor[, 6]
\end_layout

\begin_layout Plain Layout

  Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BLATAKF <- Data$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$DLAT <- Data$LATKF-Data$GGLAT
\end_layout

\begin_layout Plain Layout

Data$CLAT <- -Cor[,1] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DLON <- Data$LONKF-Data$GGLON
\end_layout

\begin_layout Plain Layout

Data$CLON <- -Cor[,2] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DALT <- Data$ALTKF-Data$GGALT
\end_layout

\begin_layout Plain Layout

Data$CALT <- -Cor[,3]
\end_layout

\begin_layout Plain Layout

Data$DVEW <- Data$VEWKF-Data$GGVEW
\end_layout

\begin_layout Plain Layout

Data$CVEW <- -Cor[,4]
\end_layout

\begin_layout Plain Layout

Data$DVNS <- Data$VNSKF-Data$GGVNS
\end_layout

\begin_layout Plain Layout

Data$CVNS <- -Cor[,5]
\end_layout

\begin_layout Plain Layout

Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$CVSPD <- -Cor[,6]
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- Data$PITCHKF-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$CROLL <- Data$ROLLKF-Data$ROLL
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- Data$THDGKF-Data$THDG
\end_layout

\begin_layout Plain Layout

KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude,
 longitude, and altitude for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                    "Comparison of the KF, GPS, and INS values of aircraft-veloc
ity components for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines show the corrections
 applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                      "Pitch Correction from the Kalman filter (CPITCH,
 blue line) and from Ranadu::CorrectPitch (PC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Roll Correction from the Kalman filter (CROLL) and
 from Ranadu::CorrectPitch (RC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Heading Correction from the Kalman filter (CTHDG)
 and from Ranadu::CorrectHeading (HC, green line)")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Results
\end_layout

\begin_layout Standard
There are several tests that the corrected values should pass:
\end_layout

\begin_layout Enumerate
Because the GPS measurements of position and aircraft velocity have low
 uncertainty, the KF values should match these in long-term average, perhaps
 with some high-frequency components not present in the GPS-provided measurement
s.
\end_layout

\begin_layout Enumerate
The pitch-correction algorithm developed in the Tech Note should give results
 in reasonable agreement with the KF values of pitch and roll.
\end_layout

\begin_layout Enumerate
The heading-correction algorithm should also produce results consistent
 with the KF results.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=KalmanCaptions>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch(Data, .span=601)
\end_layout

\begin_layout Plain Layout

Data$PC <- -PC[, 1]
\end_layout

\begin_layout Plain Layout

Data$RC <- -PC[, 2]
\end_layout

\begin_layout Plain Layout

## translate pitch/roll corrections to the a-frame:
\end_layout

\begin_layout Plain Layout

.hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- CPITCH / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CROLL <- CROLL / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$HC <- CorrectHeading (Data, .plotfile='./HCPlot.pdf')
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 70000, 123000)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH
 CORRECTION',' [',degree,']')), ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

ival <- abs(Data$ROLL) > 4
\end_layout

\begin_layout Plain Layout

Data$CPITCH[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$PC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), ylab=expression(paste('ROLL
 CORRECTION [',degree,']')), ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

Data$CROLL[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$RC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
-- End of Memo --
\end_layout

\begin_layout Standard
Reproducibility:
\begin_inset Note Note
status open

\begin_layout Plain Layout
include enough info to re-run.
 in zip, include program, pdf if not too big, and subset data, not entire
 file.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.zip
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.Rnw
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

/scr/raf
\backslash
_data/
\backslash
Sexpr{Project}/
\backslash
Sexpr{Flight}.nc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.pdf
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/
\backslash
Sexpr{thisFileName}.git
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
