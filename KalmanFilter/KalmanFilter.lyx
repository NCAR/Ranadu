#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={Wind Uncertainty TN file}  % >>change "File" to the "To:" name
 desired
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A Kalman filter to apply corrections to the wind measurements
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilter"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Introduction and scope
\end_layout

\begin_layout Standard
The intent of this study is to evaluate the errors present in the measurements
 of attitude angles from the IRU on the NSF/NCAR
\begin_inset space ~
\end_inset

GV by means of a Kalman filter applied to the difference between measurements
 from a GPS and corresponding measurements from the IRU.
 The redundant measurements are those of position and velocity, for which
 the GPS measurements are clearly superior especially at low rate, so a
 necessary result will be that the corrected measurements should be quite
 close to those from the GPS.
 The advantage of this analysis, though, is that the coupling between errors
 in the attitude angles and those in velocity makes it possible to evaluate
 the errors in the attitude angles also.
\end_layout

\begin_layout Standard
The approach taken here will be to use as the state vector the error state
 that represents the difference between the best measurements and those
 originally provided by the INS.
 The INS solution provides the 9 components consisting of the position vector,
 the velocity vector, and the orientation vector.
 To obtain these, the INS integrates the measured accelerations and rotations
 from the INU.
 That integration does not need to be duplicated here to obtain the reference
 solution.
 However, the Kalman filter does need the 
\begin_inset Quotes eld
\end_inset

state transition matrix
\begin_inset Quotes erd
\end_inset

 that represents the forward integration, so the first step in this analysis
 is to obtain such a matrix and validate results using it against the available
 INS solution.
 
\end_layout

\begin_layout Section*
Some component functions
\end_layout

\begin_layout Standard
Some of the operations involved in that 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 are contained in the following functions, with code as in the associated
 R 
\begin_inset Quotes eld
\end_inset

chunks.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
XfLA() transforms a vector from the 
\begin_inset Quotes eld
\end_inset

aircraft
\begin_inset Quotes erd
\end_inset

 reference frame or the a-frame to the l-frame, the local-level frame with
 (x,y,z) coordinates toward the East, North, and upward directions.
\end_layout

\begin_layout Enumerate
RotationCorrection() calculates the correction to accelerations needed to
 account for the rotation of the Earth and of the l-frame relative to an
 inertial frame.
 This function provides corrections to subtract from transformed accelerations
 before using them in the l-frame.
\end_layout

\begin_layout Enumerate
STMFV() calculates the derivative of the state vector (defined below) given
 the state vector and the measurements from the INU.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XfLArV <- function (data) {   ## XfLA but using input in radians and single
 row
\end_layout

\begin_layout Plain Layout

  # data must contain PITCH, ROLL, HEADING as components [7:9]
\end_layout

\begin_layout Plain Layout

  cosphi <- cos (data[8])
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (data[8])
\end_layout

\begin_layout Plain Layout

  costheta <- cos (data[7])
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (data[7])
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (data[9])
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (data[9])
\end_layout

\begin_layout Plain Layout

  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-
sinpsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinph
i-cospsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           -sintheta, costheta*sinphi, -costheta*cosphi)
\end_layout

\begin_layout Plain Layout

  RblM <- aperm( array (Rbl, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  return (RblM)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# other-functions ---------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

dt <- 1/25               ## working with 25-Hz file
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

Ree <- 6378137
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

## The next correction calculates the correction needed to account for the
 rotation
\end_layout

\begin_layout Plain Layout

## of the Earth and of the l-frame (ENU frame).
 See Noureldin et al., 2013, 
\end_layout

\begin_layout Plain Layout

## Eqs.
 5.55--5.57.
 Subtract this from the transformed accelerations before using them.
\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  Ree <- 6378137
\end_layout

\begin_layout Plain Layout

  Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
\end_layout

\begin_layout Plain Layout

  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Gravity <- function (latitude, altitude=0.) {
\end_layout

\begin_layout Plain Layout

  sl2 <- (sin (latitude * Cradeg))^2
\end_layout

\begin_layout Plain Layout

  g <- 9.780327 * ((1.
 + 0.001931851 * sl2) / 
\end_layout

\begin_layout Plain Layout

                     (1.
 - 0.006694380 * sl2)) - 3.086e-6 * altitude
\end_layout

\begin_layout Plain Layout

  ## Somigliana formula 1980 GRS:
\end_layout

\begin_layout Plain Layout

  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
\end_layout

\begin_layout Plain Layout

  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 *
 altitude^2
\end_layout

\begin_layout Plain Layout

  return(g)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
\end_layout

\begin_layout Plain Layout

  (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

STMFV <- function (sv) { 
\end_layout

\begin_layout Plain Layout

  stmf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  rlm <- XfLArV(sv)    
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/(Rn),
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
\end_layout

\begin_layout Plain Layout

  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2],
 omega[1], 0), ncol=3)
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  ## find the derivative of the transformation matrix:
\end_layout

\begin_layout Plain Layout

  ## (must recalculate SRM from measured rotation rates)
\end_layout

\begin_layout Plain Layout

  SRR <- c(0, -sv[12], -sv[10],
\end_layout

\begin_layout Plain Layout

           sv[12], 0, sv[11],
\end_layout

\begin_layout Plain Layout

           sv[10], -sv[11], 0)
\end_layout

\begin_layout Plain Layout

  SRM <- aperm( array (SRR, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  dRLA <- rlm %*% SRM - Oilb
\end_layout

\begin_layout Plain Layout

  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
\end_layout

\begin_layout Plain Layout

  # G <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch
 and roll!
\end_layout

\begin_layout Plain Layout

  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-fra
me
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
\end_layout

\begin_layout Plain Layout

  ## now correct for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  VL <- c(sv[4], sv[5], sv[6])
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3)
\end_layout

\begin_layout Plain Layout

  lat <- sv[1]
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  C[1] <- M12 * VL[2] + M13 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[2] <- M21 * VL[1] + M23 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[3] <- M31 * VL[1] + M32 * VL[2]
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (AL - C, mode='numeric')
\end_layout

\begin_layout Plain Layout

  AL[3] <- AL[3] + Grav
\end_layout

\begin_layout Plain Layout

  AL[3] <- -AL[3]
\end_layout

\begin_layout Plain Layout

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
\end_layout

\begin_layout Plain Layout

              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
\end_layout

\begin_layout Plain Layout

              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
\end_layout

\begin_layout Plain Layout

            0, 0, 0, 0, 0, 0)
\end_layout

\begin_layout Plain Layout

  return (as.vector (stmf, mode='numeric'))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

Drot <- with (Data, data.frame (BYAWR, BPITCHR, BROLLR))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

Drot$BYAWR <- Drot$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

Drot$BROLLR <- Drot$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
The integration steps
\end_layout

\begin_layout Enumerate
Initialize a state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

 having these components:
\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the l-frame
\end_layout

\begin_layout Enumerate
east velocity, north velocity, upward velocity in the l-frame
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the l-frame
\end_layout

\begin_layout Enumerate
rotation rates about the pitch, roll, and yaw axes of the aircraft
\end_layout

\begin_layout Enumerate
acceleration in the lateral, longitudinal, and normal direction relative
 to the aircraft reference frame.
\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\end_layout

\begin_deeper
\begin_layout Enumerate
store the measured rotations and accelerations in the last 6 components
 of the state vector
\end_layout

\begin_layout Enumerate
via the function STMFV, calculated the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the a-frame to the l-frame and then using
 the definition of components of that matrix to find the derivative of the
 attitude angles.
\end_layout

\begin_layout Enumerate
use that derivative vector to increment the state vector
\end_layout

\begin_layout Enumerate
compensate for possible wrap-around of the heading a 0 and 360 deg so that
 values stay within that range.
\end_layout

\begin_layout Enumerate
save the first 9 components of the state vector in a new data.frame that
 represents an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the INS
 solution.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$ALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

for (i in 2:DL) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i]
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i]
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i]
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'LAT', 'LATX')])
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'LON', 'LONX')])
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'ALT', 'ALTX')])
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VEW', 'VEWX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VNS', 'VNSX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VSPD', 'VSPDX')])
\end_layout

\begin_layout Plain Layout

## find attitude angles from RaLM:
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

plotWAC(Data[, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC(Data[, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
\end_layout

\begin_layout Plain Layout

lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

SP <- SPR    ## restore to state before integration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result of that integration is shown in Figs.
\begin_inset space ~
\end_inset

1--3, with comparisons to the INS-produced solutions.
 There are some differences, but they are mostly understandable and could
 be corrected.
 For example, the attitude angles show differences in sine waves during
 the circles flown during this time segment and suggest a timing error that
 causes one signal to be delayed relative to the comparable signal.
 The INS-produced solution for altitude has a baro-loop applied to keep
 the altitude near the pressure altitude, and that is not applied in this
 solution so the vertical wind and position show large drifts.
 Perhaps the one aspect that is troublesome is that in VNS and consequently
 in latitude.
 Also, the data used here are the 25-Hz records, while the INS uses a significan
tly higher data rate for its corresponding integration.
 The remaining differences need further investigation, but the key result
 from this part of the study is that as implemented above the derivatives
 of components of the state vector are approximately correct and integrate
 to reasonable values.
 The function providing those derivatives is therefore a reasonable basis
 for the Kalman filter that follows.
\end_layout

\begin_layout Section*
The Kalman filter
\end_layout

\begin_layout Standard
The preceding steps verify that at least an approximate calculation of the
 derivatives of the state variables is available.
 On that basis, an error-state Kalman filter can be developed, as follows:
\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position and velocity.
 Other errors are unknown at the start of the integration and so will be
 initialized as zero.
\end_layout

\begin_layout Enumerate
The covariance matrix characterizing the errors in the error-state-vector
 is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\Phi$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units escelt those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides at least an approximate
 calculation of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function of the state vector, so the
 state transition matrix is the sum of that Jacobian (multiplied by the
 time step) and the 15-element diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF.
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are known, the covariance matrix can be updated via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X6 diagonal matrix representing how the 6 measured differences (GPS-INS)
 correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise-covariance matrix representing the GPS noise,
 a 6x6 matrix having diagonal elements that are the squares of these components:
 {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1}.
\end_layout

\begin_layout Enumerate
Consider 
\begin_inset Formula $\delta z$
\end_inset

 the six measurements consisting of the differences between GPS and INS
 positions and velocities.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate, because it is expected that the errors vary slowly.
 Turns and other maneuvers can introduce spurious effects if time delays
 are not adjusted well.
 For these reasons, a 1-Hz data file will be used for the following example,
 and the measurements of components of the velocity and of the attitude
 angles as well as the rotation rates and accelerations will be smoothed
 before applying the Kalman filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-s smoothing of accelerations and 301-s smoothing of measured velocity
 components and attitude angles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DW"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

D1 <- getNetCDF (fname, VarList)
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

dt <- 1
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2
 + D1$GGALT)
\end_layout

\begin_layout Plain Layout

  #interpolate if necessary:
\end_layout

\begin_layout Plain Layout

  MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  ## smooth the measurements
\end_layout

\begin_layout Plain Layout

  .span <- 11    
\end_layout

\begin_layout Plain Layout

  ## The following are accelerations determined from derivatives of the
 GPS velocities.
\end_layout

\begin_layout Plain Layout

  ## These should match the measured accelerations after transformation
 to the l-frame
\end_layout

\begin_layout Plain Layout

  ## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  ## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

  G <- D1$Grav
\end_layout

\begin_layout Plain Layout

  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection
 (D1, VL)
\end_layout

\begin_layout Plain Layout

  AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

  AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

  fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

  fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

  fa3 <- lm(D1$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

  AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

  ## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  AL <- AL - RotationCorrection (D1, VL)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  .span <- 301
\end_layout

\begin_layout Plain Layout

  vns <- signal::sgolayfilt (vns, 3, .span)
\end_layout

\begin_layout Plain Layout

  vew <- signal::sgolayfilt (vew, 3, .span)
\end_layout

\begin_layout Plain Layout

  vspd <- signal::sgolayfilt (vspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
\end_layout

\begin_layout Plain Layout

  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
\end_layout

\begin_layout Plain Layout

  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$VNSF <- vns
\end_layout

\begin_layout Plain Layout

D1$VEWF <- vew
\end_layout

\begin_layout Plain Layout

D1$VSPDF <- vspd
\end_layout

\begin_layout Plain Layout

D1$GGVNSF <- ggvns
\end_layout

\begin_layout Plain Layout

D1$GGVEWF <- ggvew
\end_layout

\begin_layout Plain Layout

D1$GGVSPDF <- ggvspd
\end_layout

\begin_layout Plain Layout

D1$PITCHF <- pitch
\end_layout

\begin_layout Plain Layout

D1$ROLLF <- roll
\end_layout

\begin_layout Plain Layout

D1$THDGF <- thdg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fm1 <- lm (vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the a-frame and compared to the measured accelerat
ions from the IRU (with correction for the Earth's rotation and the motion
 of the l-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

., with a residual standard error of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The differentiated measurements of velocity components from the GPS might
 be considered as additional measurements corresponding to the measured
 accelerations, but this will not be part of this initial study because
 the accelerometers appear to have low uncertainty and because the effect
 of errors in acceleration would also appear as errors in velocity and so
 should be detected by the conventional 6-component measurement vector for
 Kalman filtering.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## also need the noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 100 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 100 / (sp$Rn * cos (sv[1]))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 50
\end_layout

\begin_layout Plain Layout

  gcf[4:6] <- 0.5
\end_layout

\begin_layout Plain Layout

  gcf[7:9] <- 0.05*Cradeg
\end_layout

\begin_layout Plain Layout

  # gcf[1:9] <- 0
\end_layout

\begin_layout Plain Layout

  gcf[10:12] <- 0.05*Cradeg*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.002*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

i <- 1
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[i, ]))
\end_layout

\begin_layout Plain Layout

# Gnoise <- gcf * rnorm(15)
\end_layout

\begin_layout Plain Layout

# dsve <- dcm %*% SVE   # + Gnoise
\end_layout

\begin_layout Plain Layout

# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model:
\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEWF-GGVEWF, VNSF-GGVNSF,
 VSPDF-GGVSPDF))
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 6)
\end_layout

\begin_layout Plain Layout

DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the observation matrix: (the first six components of the state error
 vector are observable)
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=6, ncol=15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

## GPS measurement noise
\end_layout

\begin_layout Plain Layout

RN <- c(50/D1$Rm[1], 50/(D1$Rn[1]*cos(SV[1])), 10, 0.1, 0.1, 0.1)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,36), ncol=6)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (50/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (50/(D1$Rn[1]*cos(SV[1])))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 100^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 0.1^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 0.1^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 0.1^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, echo=TRUE, eval=TRUE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- D1
\end_layout

\begin_layout Plain Layout

DL <- nrow (Data)
\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, ALT, VEWF, VNSF, VSPDF, PITCHF,
 ROLLF, THDGF,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

NSTEP <- 10      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

for (i in seq(2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEWF, VNSF, VSPDF, PITCHF,
 ROLLF, THDGF,
\end_layout

\begin_layout Plain Layout

                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- Data$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- Data$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- Data$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new state vector:
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE
\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

  IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

    if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

    x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

    T <- A$y
\end_layout

\begin_layout Plain Layout

    T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

    ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

    n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

    NL = length(T)
\end_layout

\begin_layout Plain Layout

    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

    return (T)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

  dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

  X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

  for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ALTKF <- Data$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

  Data$VEWKF <- Data$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

  Data$VNSKF <- Data$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

  Data$VSPDKF <- Data$VSPD - Cor[, 6]
\end_layout

\begin_layout Plain Layout

  Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BLATAKF <- Data$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Data$DVEW <- Data$VEWKF-Data$GGVEW
\end_layout

\begin_layout Plain Layout

Data$DVNS <- Data$VNSKF-Data$GGVNS
\end_layout

\begin_layout Plain Layout

Data$DVSPD <- Data$VSPD-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCH-Data$PITCHKF
\end_layout

\begin_layout Plain Layout

Data$DROLL <- Data$ROLL-Data$ROLLKF
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- Data$THDG-Data$THDGKF
\end_layout

\begin_layout Plain Layout

Data$PC <- -CorrectPitch(Data, .span=301)[,1]
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[setRange(Data, 70000, 123000),],,c(Time, DPITCH, PC)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
-- End of Memo --
\end_layout

\begin_layout Standard
Reproducibility:
\begin_inset Note Note
status open

\begin_layout Plain Layout
include enough info to re-run.
 in zip, include program, pdf if not too big, and subset data, not entire
 file.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.zip
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.Rnw
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

/scr/raf
\backslash
_data/
\backslash
Sexpr{Project}/
\backslash
Sexpr{Flight}.nc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.pdf
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/
\backslash
Sexpr{thisFileName}.git
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
cc{first attachment
\backslash

\backslash
second
\backslash

\backslash
3rd att}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
