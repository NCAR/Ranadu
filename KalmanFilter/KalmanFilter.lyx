#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
%\fancyhead{}
%\fancyfoot[CE,CO]{}
%\newtoks{\addressee} \global\addressee={}
%\newdimen\longindent \longindent=3.5truein
%\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
%\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={Wind Uncertainty TN file}  
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Correcting attitude angles via a Kalman filter
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Correcting Measured Attitude Angles with a Kalman Filter
\end_layout

\begin_layout Author
William A.
 Cooper
\end_layout

\begin_layout Date
08/07/2016
\end_layout

\begin_layout Section
Overview and background
\end_layout

\begin_layout Subsection
Sources of error in measurements of wind
\end_layout

\begin_layout Standard
An 
\begin_inset CommandInset href
LatexCommand href
name "NCAR Technical Note"
target "http://dx.doi.org/10.5065/D60G3HJ8"

\end_inset

 documents the uncertainties associated with measurements of wind from the
 NSF/NCAR Gulfstream V (hence, GV) research aircraft.
 That report highlights that the most important contributions to that uncertaint
y arise from three errors:
\end_layout

\begin_layout Enumerate
For vertical wind, 
\emph on
\bar under
error in pitch
\emph default
\bar default
 is the dominant remaining error.
\end_layout

\begin_layout Enumerate
For horizontal wind, 
\emph on
\bar under
error in heading
\emph default
\bar default
 is the dominant remaining error.
\end_layout

\begin_layout Enumerate
For both, pressure-line resonance limits high-frequency response and compromises
 measurements of variance spectra.
\end_layout

\begin_layout Standard
This document describes methods for improving the measurements of wind by
 addressing the first two of these errors.
 The third requires hardware changes, but the first two can be addressed
 solely by changes in the processing algorithms.
 It will be shown here that such processing can reduce the uncertainty in
 pitch and heading so that they make only minor contributions to the overall
 uncertainty in wind, so that further improvement is not beneficial.
 Two parallel approaches are possible: (1) implementation of a Kalman filter
 to correct the measurements from the inertial navigation system (INS) on
 the GV, which does not have such a Kalman filter as an integral part of
 processing; and (2) development of simpler algorithms that can obtain comparabl
e correction terms without the full mechanism of the Kalman filter.
 The latter is the topic of separate documentstion.
 Here the focus is on the Kalman filter.
\end_layout

\begin_layout Standard
The primary wind-sensing system on the GV consists of these components:
\begin_inset Foot
status open

\begin_layout Plain Layout
See the referenced NCAR Technical Note for a full description.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
An inertial reference unit (IRU) that makes the basic measurements of accelerati
on and rotation in the reference frame of the aircraft, or 
\emph on
a-
\emph default
frame.
\end_layout

\begin_layout Enumerate
The associated inertial navigation system (INS) that integrates these measuremen
ts to determine the location, Earth-relative motion, and attitude angles
 of the aircraft.
 The latter include the pitch, roll, and heading.
\end_layout

\begin_layout Enumerate
A Global Positioning System (GPS) receiver that provides independent measurement
s of the location and Earth-relative motion.
\end_layout

\begin_layout Enumerate
A radome-based gust system, consisting of pressure measurements at ports
 on the surface of the radome and associated measurements of dynamic and
 ambient pressure, that measures the 
\begin_inset Quotes eld
\end_inset

relative wind
\begin_inset Quotes erd
\end_inset

 or the air-velocity vector relative to the aircraft and in its reference
 frame.
\end_layout

\begin_layout Standard
These are processed to obtain two 
\begin_inset Quotes eld
\end_inset

state vectors
\begin_inset Quotes erd
\end_inset

, an aircraft-state vector with nine components that specify the position,
 Earth-relative motion, and attitude angles of the aircraft and a relative-wind
 vector with three components that represent the motion of air with respect
 to the aircraft reference frame.
 The Earth-relative motion of the aircraft is then combined with the relative
 wind to obtain the Earth-relative wind.
 That combination involves a coordinate transformation from the reference
 frame of the aircraft (
\begin_inset Quotes eld
\end_inset


\emph on
a-
\emph default
frame
\begin_inset Quotes erd
\end_inset

) to the Earth-relative local frame (
\begin_inset Quotes eld
\end_inset

ENU
\begin_inset Quotes erd
\end_inset

 or 
\emph on

\begin_inset Quotes eld
\end_inset

l-
\emph default
frame
\begin_inset Quotes erd
\end_inset

) and so depends on the attitude angles of the aircraft.
 Those angles are important sources of uncertainty because the solution
 is very sensitive to them and their measurement relies upon proper initializati
on of the INS at the start of the flight and proper integrations of all
 changes during the flight, with no updating available in standard processing.
\end_layout

\begin_layout Standard
In the case of position and ground-speed of the aircraft, the GPS provides
 a low-uncertainty measurement that can be used to correct the measurements
 from the INS, and this is done in standard processing via a complementary
 filter that combines the high-frequency response from the INS with the
 low-frequency response from the GPS, as described in the referenced Technical
 Note.
 This correction of the INS-provided measurements can also be made using
 the Kalman filter described below, but there is little advantage because
 the result is very close to the result obtained using the complementary
 filter.
 However, the GPS does not provide an alternate measurement of the attitude
 angles, so reduction in their uncertainties requires a different approach.
 The significant benefit achieved by the Kalman filter described in this
 report is reduction of the uncertainty in the measurements of attitude
 angles.
\end_layout

\begin_layout Subsection
The purpose of the Kalman filter
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-Kalman-filter"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:", cache=TRUE)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilter"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

library(TTR)
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 			
\end_layout

\begin_layout Plain Layout

Project = "DWIRU" 
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

#ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData1 <- sprintf("%s1.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData1)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The intent of this study is to evaluate the errors present in the measurements
 of attitude angles from the IRU on the NSF/NCAR
\begin_inset space ~
\end_inset

GV by means of a Kalman filter applied to the difference between measurements
 from a Global Positioning System (GPS) receiver and corresponding measurements
 from an inertial reference unit (IRU).
 Here the terminology used will be to refer to the core unit producing measureme
nts of acceleration and rotation as the IRU and the associated system that
 produces useful variables like ground speed or location as the inertial
 navigation system (INS).
 The redundant measurements are those of position and velocity,
\begin_inset Foot
status open

\begin_layout Plain Layout
Because GPS measurements of velocity have low uncertainty, those measurements
 could be differentiated and, after transformation to the aircraft reference
 frame, used as error measurements for the measured accelerations.
 This has not been explored as yet, and it is not clear that this would
 provide information beyond that arising from the Kalman-filter updates
 using only velocity.
\end_layout

\end_inset

 for which the GPS measurements are clearly superior especially at low rate,
 so a necessary result will be that the corrected measurements should be
 quite close to those from the GPS.
 The advantage of this analysis, though, is that the coupling between errors
 in the attitude angles and those in velocity makes it possible to evaluate
 the errors in the attitude angles also.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Kalman filter provides a means of updating a sequence of aircraft-state
 vectors by comparison to an independent set of measurements, e.g., from GPS-deriv
ed measurements of position and velocity).
 The updated state vector obtained by this process consists of an appropriately
 weighted combination of the aircraft-state vector projected forward using
 normal INS 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 (i.e., determining the next step by using the measured acceleration and rotation
 from the IRU) and the independent measurements from GPS.
 Because errors in the state vector are coupled, the update procedure can
 estimate errors in the attitude angles as well as the components of the
 state vector that are measured directly by the GPS.
 As described below, corrections to the attitude angles (pitch, roll, and
 heading) can be estimated even though there is no direct measurement of
 these except from the INS.
 The reason is that the attitude-angle errors have consequences that 
\emph on
are 
\emph default
observable.
 For example, an error in pitch or roll leads to errors when the acceleration
 of gravity is resolved into the aircraft reference frame, and that leads
 to errors in the measured accelerations of the aircraft that cause errors
 in Earth-relative velocity or location.
 Those are observable by comparison to the corresponding measurements from
 the GPS receiver, so the Kalman filter is able to introduce corrections
 that reduce those errors.
 In similar fashion, an error in heading leads to an error in the measured
 acceleration when transformed from the 
\emph on
a-
\emph default
frame to the 
\emph on
l-
\emph default
frame and so to errors in Earth-relative velocity and position that are
 observable by comparison to the GPS-provided measurements.
\end_layout

\begin_layout Standard
The weighting of the projected-forward aircraft-state vector and new measurement
s from GPS depends on obtaining estimates of the covariance matrix describing
 uncertainty in the state vector as well as estimates of the noise sources
 contaminating the measurements from both the GPS- and the IRU-provided
 accelerations and rotations.
 With proper weighting, the result should combine the good high-frequency
 response of the INS with the good long-term stability of the GPS.
 The covariance matrix characterizing the aircraft-state vector is updated
 as the filter is applied, but appropriate weighting depends on reasonable
 estimation of the other error terms that are not updated.
\end_layout

\begin_layout Subsection
An error-state Kalman filter
\begin_inset CommandInset label
LatexCommand label
name "subsec:An-error-state-Kalman"

\end_inset


\end_layout

\begin_layout Standard
As outlined above, the Kalman filter operates during 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INS as a solution is produced.
 However, in the GV case, mechanization is internal to the INS and is beyond
 the reach of an alternate software solution.
 Because the processing in the INS has access to data at higher rate than
 is present in the archive files and uses undisclosed processing algorithms
 likely superior to ones we might construct, a preferable approach is instead
 to use an error-state Kalman filter where the aircraft-state vector provided
 by the INS is taken as a reference state and the Kalman filter instead
 propagates an error-state vector that represents corrections to the reference
 state.
 A central need is still to determine the derivative matrix representing
 the change in the aircraft-state vector, because the transformation matrix
 for the error-state vector is the jacobian of that derivative matrix..
 Therefore, an essential step toward development of the error-state Kalman
 filter is to develop the aircraft-state transformation matrix based on
 that derivative matrix and verify that it provides, at least approximately,
 the reference solution.
 That verification is therefore an important step that is described in detail
 below.
 The resulting transformation matrix will then provide the core for the
 error-state Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Section
Simplified correction algorithms 
\end_layout

\begin_layout Subsection
Advantages of simplified corrections
\end_layout

\begin_layout Plain Layout
Because the Kalman-filter solution can be complex and requires specification
 of uncertainties as well as access to the original measurements of acceleration
 and rotation rates, its implementation can be difficult particularly for
 old data archives where the required information might not be preserved.
 The algorithms outlined here are much simpler, faster to use, require less
 specification of uncertainties, and are easily applied to data from past
 research projects.
 
\end_layout

\begin_layout Subsection
Correction for errors in pitch and roll
\end_layout

\begin_layout Subsubsection
The correction algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:pitch-and-roll"

\end_inset


\end_layout

\begin_layout Plain Layout
In the case of pitch and roll, the solution relies on observation of the
 derivatives in the errors in ground-speed components, which arise primarily
 from errors in those angles.
 An inertial system aligns during initialization to detect the local vertical
 direction and then calculates the new vertical direction as the aircraft
 moves (changing the local vertical direction) and accelerates (which can
 cause gyros to precess).
 Any mis-alignment present at initialization persists but also will oscillate
 and will cause errors in roll and pitch to mix as the aircraft changes
 flight direction.
 The standard error associated with this measurement is 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 for flight duration of a few hours, and the error often increases during
 the flight as heading errors and accelerometer biases affect the results.
\end_layout

\begin_layout Plain Layout
The work of Schuler (
\begin_inset CommandInset citation
LatexCommand cite
key "Schuler1923"

\end_inset

) showed that coupling among some of these error sources leads to limits
 on the growth of errors and simultaneous oscillations in some of the measuremen
t errors.
 In particular, an error in pitch leads to an error in horizontal acceleration
 because gravity is resolved to have an erroneous horizontal component,
 and integration of that error in horizontal acceleration leads to a position
 error that grows so as to compensate for the original error in pitch.
 However, when the error in pitch is reduced to zero, errors in position
 and velocity have been accumulated and those lead to growth of the error
 in pitch in the direction opposite to the original error.
 The result is a Schuler oscillation having a period of 
\begin_inset Formula $T_{Sch}=(R_{e}/g)^{0.5}/(2\pi)\approx5064\thinspace s$
\end_inset

 or 84.4
\begin_inset space \thinspace{}
\end_inset

min, where 
\begin_inset Formula $R_{e}$
\end_inset

 is the radius of the Earth and 
\begin_inset Formula $g$
\end_inset

 the acceleration of gravity.
 
\end_layout

\begin_layout Plain Layout
The existence of this coupling allows estimation of the pitch error if the
 error in horizontal acceleration is known.
 That is the case if, in addition to the INS, there is a GPS receiver that
 can provide high-quality measurements of Earth-relative velocity.
 Modern GPS receivers, especially if they incorporate differential-GPS correctio
ns or ionispheric corrections, produce velocity measurements that have remarkabl
y low uncertainty, often a few cm/s, so these can be considered the standard
 against which to compare the corresponding IRS-measured velocities.The differenc
e between ground-speed components from the two systems thus determines the
 error in INS-measured velocity and, after differentiation, the error in
 horizontal acceleration.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization-pitch,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(ggplot2)
\end_layout

\begin_layout Plain Layout

require(grid)
\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

require(ggthemes)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.loc="center", digits=4)
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "ff02" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"			 # XXX change this
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory,Project,Project,Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("BLATA", "BLONGA", "BNORMA", "VNS", "VEW", "VSPD", "GGVNS",
 "GGVEW", 
\end_layout

\begin_layout Plain Layout

              "GGVSPD", "LAT", "LON", "ALT", "THDG", "PITCH", "ROLL") 
\end_layout

\begin_layout Plain Layout

SaveRData2 <- sprintf("%s2.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))		
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData2)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180
\end_layout

\begin_layout Plain Layout

source ("~/RStudio/Ranadu/R/ShiftInTime.R")
\end_layout

\begin_layout Plain Layout

source("~/RStudio/Ranadu/R/XformLA.R")
\end_layout

\begin_layout Plain Layout

source ("~/RStudio/Ranadu/R/PitchCorrection.R")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The algorithm for correcting pitch is discussed in Cooper et al., 2016, where
 the following is presented along with some additional diagrams that clarify
 the nature of the oscillation.
 The development is repeated here is more abbreviated form for convenient
 reference.
 The equations for the Schuler oscillation are these:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
v_{n}=\frac{dx_{n}}{dt}=R_{e}\frac{d\lambda}{dt}\label{eq:vn}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\frac{d^{2}x_{n}}{dt^{2}}=a_{n}\label{eq:an}
\end{equation}

\end_inset

where 
\begin_inset Formula $x_{n}$
\end_inset

 is the north coordinate of the position and 
\begin_inset Formula $a_{n}$
\end_inset

 is the northward acceleration.
 However, if 
\begin_inset Formula $a_{n}=a_{n}^{*}+\delta a_{n}$
\end_inset

 where 
\begin_inset Formula $a_{n}^{*}$
\end_inset

 is the true northward acceleration of the aircraft and 
\begin_inset Formula $\delta a_{n}$
\end_inset

 is the erroneous acceleration that results from pitch and displacement
 errors, then
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\delta a_{n}=g(\delta\lambda-\delta\theta^{(l)})\label{eq:delta-an}
\end{equation}

\end_inset

with 
\begin_inset Formula $\lambda$
\end_inset

 the latitude, 
\begin_inset Formula $\delta\lambda=\delta x_{n}/R_{e}$
\end_inset

 the error in latitude, and 
\begin_inset Formula $\delta\theta^{(l)}$
\end_inset

 the error in pitch, where 
\begin_inset Formula $(l)$
\end_inset

 denotes that this in defined in an Earth reference frame or 
\begin_inset Formula $l$
\end_inset

-frame (often called the ENU frame) where the axes are respectively east,
 north, and up.
 Then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d(\delta v_{n})}{dt}=-g\delta\theta^{(l)}\label{eq:delta-vn-dot}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d(\delta\theta^{(l)})}{dt}=\frac{\delta v_{n}}{R_{e}}=-\frac{1}{g}\frac{d^{2}(\delta v_{n})}{dt^{2}}\label{eq:delta-theta-dot}
\end{equation}

\end_inset

which has the solution:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta v_{n}=V_{n}\cos(\omega t+\zeta_{n})\label{eq:delta-vn-solution}
\end{equation}

\end_inset

where 
\begin_inset Formula $\omega=\sqrt{g/R_{e}}\simeq0.00124$
\end_inset

 is the Schuler angular velocity.
 The error in the north component of the velocity therefore oscillates with
 the Schuler period and a phase 
\begin_inset Formula $\zeta_{n}$
\end_inset

.
 Integrating in time gives
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta x_{n}=\int\delta v_{n}dt=\frac{V_{n}}{\omega}\sin(\omega t+\zeta_{n})\label{eq:delta-xn-solution}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout

\family sans
\color black
The key to developing a correction to the pitch angle is that both 
\begin_inset Formula $\delta x_{n}$
\end_inset

 and 
\begin_inset Formula $\delta v_{n}$
\end_inset

 are observable because reference measurements are available from GPS.
 For example,
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\delta x_{n} & = & R_{e}(\lambda_{INS}-\lambda_{GPS})\nonumber \\
\delta v_{n} & = & v_{n}^{(INS)}-v_{n}^{(GPS)}\label{eq:observed-errors}
\end{eqnarray}

\end_inset

These observations determine 
\begin_inset Formula $A_{n}$
\end_inset

 and 
\begin_inset Formula $\zeta_{n}$
\end_inset

 in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-vn-solution"

\end_inset

).
 From these, the error in pitch can be found from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-vn-dot"

\end_inset

):
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\theta^{(l)}=-\frac{1}{g}\frac{d(V_{n}\cos(\omega t+\zeta_{n})}{dt}=\frac{V_{n}\omega}{g}\sin(\omega t+\zeta_{n})\label{eq:solution-delta-theta}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Analogous equations lead to a similar coupling between the roll angle and
 the east component of the ground velocity:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\delta\phi^{(l)}=-\frac{V_{e}\omega}{g}\sin(\omega t+\zeta_{e})\label{eq:solution-delta-phi}
\end{equation}

\end_inset

where 
\begin_inset Formula $\phi^{(l)}$
\end_inset

 is the roll angle and 
\begin_inset Formula $V_{e}$
\end_inset

 and 
\begin_inset Formula $\zeta_{e}$
\end_inset

 are determined from fits to the observed error 
\begin_inset Formula $\delta v_{e}$
\end_inset

.
 However, it is common for the amplitude and phase of the correction to
 change during extended flight as other errors like those in measured accelerati
on affect the solution.
 Therefore, instead of using fits to (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:solution-delta-theta"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:solution-delta-phi"

\end_inset

), it is preferable to determine the errors directly from the time-derivatives
 of the error terms in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-vn-dot"

\end_inset

) and the analogous equation for roll, restated as:
\begin_inset Foot
status open

\begin_layout Plain Layout
The different signs arise from the different definitions of the angles,
 where a positive pitch error represents a rotation of the platform axis
 in the negative 
\begin_inset Formula $y$
\end_inset

-axis direction but a positive roll error corresponds to a platform rotation
 in the positive 
\begin_inset Formula $x$
\end_inset

-axis direction.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\delta\theta^{(l)} & = & -\frac{1}{g}\frac{d(\delta v_{n})}{dt}\label{eq:delta-theta}\\
\delta\phi^{(l)} & = & \frac{1}{g}\frac{d(\delta v_{e})}{dt}\,\,\,.\label{eq:delta-phi}
\end{eqnarray}

\end_inset

The differentiated errors in the components of the aircraft ground-speed
 thus can provide estimates for corrections to be applied to the measurements
 of pitch and roll in the 
\emph on
l-
\emph default
frame.
 However, in general an additional transformation of angles is needed to
 obtain the pitch and roll errors in the aircraft reference frame because
 these angles are normally reported and used as measured in that frame.
\end_layout

\begin_layout Subsubsection
An example
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<v-errors-straight-leg, fig.height=6.5, fig.lp="fig:",fig.cap="Top: Errors
 in the IRS measurements of the northward and eastward components of groundspeed
 ($V_n^{(IRS)}$ and $V_e^{(IRS)}$) as determined by comparison to measurements
 from a GPS receiver ($V_n^{(GPS)}$ and $V_e^{(GPS)}$) for DEEPWAVE flight
 ff02, a ferry flight starting on 1 June 2014 and traveling from Hawaii
 to Pago-Pago.
 Bottom: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi$) as obtained from (
\backslash

\backslash
ref{eq:delta-theta}) and (
\backslash

\backslash
ref{eq:delta-phi}).", include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[Data$TASX > 130., ]
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

Z <- plotWAC (D$Time, D$GGVEW-D$VEW, ylab="error [m/s]", ylim=c(-2.5,3.))
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, D$GGVNS-D$VNS, col='darkgreen')
\end_layout

\begin_layout Plain Layout

legend ('top', legend=c(expression(paste('(',V[e]^(IRS),'-',V[e]^(GPS),')')),
 expression(paste('(',V[n]^(IRS),'-',V[n]^(GPS),')'))), lwd=2, col=c('blue',
 'darkgreen'), text.col=c('blue', 'darkgreen'), cex=0.8, horiz=TRUE)
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, D$THDG/360, col='darkorange')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- D[!is.na (D$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

VNS <- zoo::na.approx (as.vector(D$VNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

VEW <- zoo::na.approx (as.vector(D$VEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

NAV <- 1013 * Rate
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (VNS-GGVNS, 3, NAV, m=1) * Rate  # m=1 for first
 deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (VEW-GGVEW, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

deltaPitch <- vndot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

deltaRoll <- vedot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

Z <- plotWAC(D$Time, deltaRoll/Cradeg, ylab=expression(paste('error [',
 degree, ']')), col='darkgreen', ylim=c(-0.02,0.02))
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, deltaPitch/Cradeg, col='blue')
\end_layout

\begin_layout Plain Layout

legend('top', legend=c(expression(paste(delta, theta)), expression(paste(delta,p
hi))), lwd=2, col=c("blue", "darkgreen"), text.col=c("blue", "darkgreen"),
 cex=0.8, horiz=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
An example from the second ferry flight of the DEEPWAVE project is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

.
 The heading for most of this flight was close to southbound and steady,
 so to a reasonable approximation the errors in pitch and heading will be
 given by the respective derivatives in the error terms 
\begin_inset Formula $\delta v_{n}$
\end_inset

 and 
\begin_inset Formula $\delta v_{e}$
\end_inset

, divided by the acceleration of gravity and converted to units of degrees.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The amplitude of the Schuler oscillation is about 0.5 to 0.75 m/s, which would
 indicate that the pitch error is about (0.5–0.75)(0.00124)/9.8
\begin_inset Formula $\simeq0.005^{\circ}$
\end_inset

.
 For this flight, the error in pitch is very small compared to the expected
 uncertainty in angle-of-attack (0.1
\begin_inset Formula $^{\circ}$
\end_inset

).
 A Schuler oscillation in the north component of the aircraft ground-speed
 of 1 m/s indicates that, in the l-frame, the pitch error is <0.01
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\end_inset

The derivatives estimated using Savitzky-Golay polynomials were used to
 find the errors, as shown in the bottom panel of Fig._
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

.
 Savitzky-Golay polynomials were chosen because they are computationally
 efficient, don't introduce a time shift, and can provide derivatives directly.
 A rather long averaging period of 1013 s, or about 1/5 of a Schuler oscillation
, was used to reduce noise in the result.
\end_layout

\begin_layout Plain Layout
The result is that the magnitude of the pitch error is limited to 
\begin_inset Formula $<0.01^{\circ}$
\end_inset

for most of this flight, except for the final descent, and the roll error
 is limited to less than about 0.015
\begin_inset Formula $^{\circ}$
\end_inset

for the same period.
 This is evidence for low uncertainty in both measurements for this flight,
 well below the specified uncertainty of 0.05
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Transformation of attitude angles
\end_layout

\begin_layout Plain Layout
In a reference frame called the 
\begin_inset Formula $l$
\end_inset

-frame or ENU frame, where the coordinate axes are local-east, local-north,
 and upward, the derivation in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pitch-and-roll"

\end_inset

 showed that the pitch and roll errors are related via (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

) to the time-derivatives of the errors in horizontal velocity.
 Pitch and roll as used in these equations are the respective errors in
 platform alignment
\begin_inset Foot
status open

\begin_layout Plain Layout
The inertial system used is a strap-down system, so there is no actual motion
 of the 
\begin_inset Quotes eld
\end_inset

platform
\begin_inset Quotes erd
\end_inset

.
 Instead, from measured rotations and accelerations, the system calculates
 the expected orientation if there were a true stabilized platform.
 The errors referenced here are those relative to that calculated platform
 orientation.
\end_layout

\end_inset

 in the north-south and east-west directions, so these angles must be transforme
d to account for the orientation of the aircraft when it is not flying straight-
and-level to the north.
 Because transformations for roll and pitch do not change the magnitude
 of the errors in those quantities, only a rotation about the 
\begin_inset Formula $z$
\end_inset

 axis for heading is needed to obtain the error components in the body or
 
\begin_inset Formula $b$
\end_inset

-frame of the aircraft.
 This leads to pitch errors in the body frame of the aircraft that are mixtures
 of pitch and roll errors in the 
\begin_inset Formula $l$
\end_inset

-frame, with the mixture dependent on the heading.
 A positive pitch error for northbound level flight will be a negative pitch
 error for southbound level flight, and for eastbound flight an 
\begin_inset Formula $l$
\end_inset

-frame roll error becomes a 
\begin_inset Formula $b$
\end_inset

-frame pitch error while an 
\begin_inset Formula $l$
\end_inset

-frame pitch error become a negative 
\begin_inset Formula $b$
\end_inset

-frame roll error.
 
\end_layout

\begin_layout Plain Layout
Consider a unit vector representing the orientation errors in pitch and
 roll in the 
\begin_inset Formula $l$
\end_inset

-frame, with east, north, and upward components 
\begin_inset Formula $\mathbf{b^{(l)}=}$
\end_inset

{
\begin_inset Formula $\sin\delta\phi^{(l)},\,-\sin\delta\theta^{(l)},\,\sqrt{1-\sin^{2}\delta\phi^{(l)}-\sin^{2}\delta\theta^{(l)}}$
\end_inset

} or, because the errors are always small, approximately {
\begin_inset Formula $\delta\phi^{(l)},\,-\delta\theta^{(l)},\,1$
\end_inset

}.
 The transformation of these errors from the 
\begin_inset Formula $l$
\end_inset

-frame to the 
\begin_inset Formula $b$
\end_inset

-frame only requires a rotation by the heading angle 
\begin_inset Formula $-\psi$
\end_inset

 in the 
\begin_inset Formula $l$
\end_inset

-frame because differences in pitch and roll between the 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 reference frames do not affect the estimate of platform mis-alignment and
 how that misalignment is resolved into pitch and roll components.
 Therefore, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Marginal
status open

\begin_layout Plain Layout
check sign
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\mathbf{b^{(b)}=}R_{l}^{b}\mathbf{b^{(l)}} & \approx & \left[\begin{array}{ccc}
\cos\psi & -\sin\psi & 0\\
\sin\psi & \cos\psi & 0\\
0 & 0 & 1
\end{array}\right]\begin{bmatrix}\delta\phi^{(l)}\\
-\delta\theta^{(l)}\\
1
\end{bmatrix}=\begin{bmatrix}\cos\psi\delta\phi(l)+\sin\psi\delta\theta(l)\\
\sin\psi\delta\phi^{(l)}-\cos\psi\delta\theta^{(l)}\\
1
\end{bmatrix}\label{eq:b-vector-in-b-frame}
\end{eqnarray}

\end_inset

which leads to 
\begin_inset Formula $\delta\theta^{(b)}$
\end_inset

 and 
\begin_inset Formula $\delta\phi^{(b)}$
\end_inset

, the pitch and roll errors in the 
\begin_inset Formula $b$
\end_inset

-frame:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{eqnarray}
\delta\theta^{(b)} & \simeq & -b_{2}^{(b)}/b_{3}^{(b)}=-\sin\psi\delta\phi^{(l)}+\cos\psi\delta\theta^{(l)}\label{eq:final-answer}\\
\delta\phi^{(b)} & \approx & b_{1}^{(b)}/b_{3}^{(b)}=\cos\psi\delta\phi^{(l)}+\sin\psi\delta\theta^{(l)}\,\,\,.\nonumber 
\end{eqnarray}

\end_inset

These errors should then be 
\emph on
subtracted
\emph default
 from the angles measured by the INS to obtain corrected values.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Xform-l-from-b-pitch, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

XformLA-old <- function (bvector, .roll, .pitch, .heading, .reverse=FALSE) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  sr <- sin(.roll*Cradeg); cr <- cos(.roll*Cradeg)
\end_layout

\begin_layout Plain Layout

  sp <- sin(.pitch*Cradeg); cp <- cos(.pitch*Cradeg)
\end_layout

\begin_layout Plain Layout

  sh <- sin(.heading*Cradeg); ch <- cos(.heading*Cradeg)
\end_layout

\begin_layout Plain Layout

  if (.reverse) {   # note that entries are in column order; transpose before
 use
\end_layout

\begin_layout Plain Layout

    M <- c(sh*cr+ch*sp*sr, ch*cr-sh*sp*sr, -cp*sr,
\end_layout

\begin_layout Plain Layout

           ch*cp, -sh*cp, sp,
\end_layout

\begin_layout Plain Layout

           -sh*sr+ch*sp*cr, -ch*sr-sh*sp*cr, -cp*cr)
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    M <- c(sh*cp, ch*cr+sh*sp*sr, ch*sr-sh*sp*cr,
\end_layout

\begin_layout Plain Layout

            ch*cp, -sh*cr+ch*sp*sr, -sh*sr-ch*sp*cr,
\end_layout

\begin_layout Plain Layout

            -sp, cp*sr, cp*cr)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dim (M) <- c(3,3)
\end_layout

\begin_layout Plain Layout

  return (t(M) %*% bvector)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<processing-1, fig.height=3.5, fig.cap="Measured errors in ground-speed components
 for DEEPWAVE research flight 1.
 $V_e^{IRS}$ and $V_n^{IRS}$ are the east and north components of the ground
 speed measured by the inertial system, and $V_e^{GPS}$ and $V_n^{GPS}$
 are the corresponding components measured independently by the GPS receiver.",
 include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "rf01h"
\end_layout

\begin_layout Plain Layout

Flight <- "rf01"
\end_layout

\begin_layout Plain Layout

# Flight <- "rf15"
\end_layout

\begin_layout Plain Layout

fname <- sprintf ("%s%s/%s%s.nc", DataDirectory (), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("VNS", "VEW","GGVNS", "GGVEW", "GGALT", "LATC", "LONC", "THDG",
 "PITCH", "ROLL")
\end_layout

\begin_layout Plain Layout

SaveRData2 <- sprintf("%s2.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData2)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

Ts <- -120
\end_layout

\begin_layout Plain Layout

Data$VEW <- ShiftInTime (Data$VEW, Rate, Ts)
\end_layout

\begin_layout Plain Layout

Data$VNS <- ShiftInTime (Data$VNS, Rate, Ts)
\end_layout

\begin_layout Plain Layout

Ts <- -60
\end_layout

\begin_layout Plain Layout

Data$THDG <- ShiftInTime (Data$THDG, Rate, Ts)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[Data$TASX > 130, ]
\end_layout

\begin_layout Plain Layout

#D <- D[setRange(D$Time, 81500,82500),]
\end_layout

\begin_layout Plain Layout

Z <- plotWAC (D$Time, D$GGVEW-D$VEW, ylab="Ve error [m/s]", ylim=c(-5, 8.))
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, D$GGVNS-D$VNS, col='darkgreen', lwd=1)
\end_layout

\begin_layout Plain Layout

legend ('topleft', legend=c('VEW-GGVEW', 'VNS-GGVNS'), lwd=c(2,1), col=c('blue',
 'darkgreen'), text.col=c('blue', 'darkgreen'), ncol=2)
\end_layout

\begin_layout Plain Layout

figcapP2=c("Top: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta^{(l)}$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi^{(l)}$) determined from the measured errors in ground-speed components
 via (
\backslash

\backslash
ref{eq:final-answer}), as measured in the $l$-frame.
 Measurements are from the DEEPWAVE project, research flight 1.
 Bottom: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi$) determined from the measured errors in ground-speed components, after
 transformation of the errors shown in the previous plot to the reference
 frame that is the body frame of the aircraft.
 Measurements are from the DEEPWAVE project, research flight 1.
 The limits $
\backslash

\backslash
pm$0.02 correspond to roll angle of $
\backslash

\backslash
pm 20^{
\backslash

\backslash
circ}$ after division by 1000.")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Application to a representative research flight
\begin_inset CommandInset label
LatexCommand label
name "subsec:Application-to-research"

\end_inset


\end_layout

\begin_layout Plain Layout
The research flights have frequent changes in heading, with associated mixing
 of the roll and pitch errors but also accelerations that affect those errors
 and introduce new errors from heading errors.
 The corrections to pitch therefore appear much less systematic than was
 the case for the ferry flight, and in some cases the corrections are considerab
ly larger.
 An example, DEEPWAVE research flight 1 (June 6 2014), is presented here.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

 shows the estimated errors in pitch and roll in the 
\begin_inset Formula $l$
\end_inset

-frame and after transformation to the 
\begin_inset Formula $b$
\end_inset

-frame.
 There are instances in the latter where the pitch error abruptly reverses
 sign; those are cases where the flight direction changes by about 180
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are also some times when there are noise and jumps in the differences.
 These arise in turns and appear to be the result of small timing differences,
 which have not been corrected here because 1-Hz data rates were used while
 the indicated difference was found consistent with about 160
\begin_inset space ~
\end_inset

ms lag in the IRS measurements.
\end_layout

\end_inset

In straight-and-level flight, the needed corrections are about 
\begin_inset Formula $\pm$
\end_inset

0.03
\begin_inset Formula $^{\circ}$
\end_inset

 at some times, and this error can lead (for true airspeed of 220 m/s) to
 an error in vertical wind of about 
\begin_inset Formula $\pm0.1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m/s.
 A mismatch in timing between measurements from IRS and GPS units will affect
 measurements in turns, and there is some evidence of this in Fig.\SpecialChar softhyphen

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Discussion
\end_layout

\begin_layout Plain Layout
The magnitude of the correction in the example shown is significant in compariso
n to the total uncertainty in measurements of vertical wind (discussed further
 in the Appendix), so correction for this error should lead to a significant
 reduction in the uncertainty associated with the measured vertical wind.
 There can be various sources for the error in pitch, including initial
 alignment, bias or other errors from the IRS sensors, possible effects
 of horizontal accelerations or turbulence on platform alignment, and others.
 However, the equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) used to detect this error do not depend on the source of the error; any
 error in pitch will introduce an error in horizontal acceleration, and
 that error can be detected by comparison to corresponding measurements
 from the GPS receiver provided only that the measurements from the GPS
 unit are accurate.
 Modern GPS receivers, often incorporating differential-GPS corrections
 and ionospheric corrections, are capable of measuring horizontal motions
 with uncertainties as small as 3
\begin_inset space ~
\end_inset

cm
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Representative variance spectra for the GPS-measured velocity components
 suggest an onset of noise at around 0.2
\begin_inset space \thinspace{}
\end_inset

Hz with approximate amplitude of 0.1
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, suggesting an ability to measure accelerations with an uncertainty of
 about 0.02
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

for measurements spanning 5
\begin_inset space ~
\end_inset

s.
 From (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

), this suggests an uncertainty in the pitch correction of about 0.002 or
 0.1
\begin_inset Formula $^{\circ}$
\end_inset

 for measurements with this separation.
 It appears from plots like those shown above that the pitch correction
 varies only slowly with time, so this estimate can be improved significantly
 by using longer averaging times.
 For times of 5
\begin_inset space ~
\end_inset

min, for example, the uncertainty in acceleration can be less than 0.0001
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and the corresponding uncertainty in the pitch correction is less than
 0.002
\begin_inset Formula $^{\circ}$
\end_inset

.
 At this level, the uncertainty in pitch does not make a significant contributio
n to the uncertainty in measurements of vertical wind because other sources
 dominate.
 For straight flight paths, the correction procedure thus can be considered
 to remove the error in pitch.
 In turns, however, the relative timing of the measurements can introduce
 biases that cause errors extending not only during but also for a short
 period before and after the turns, with duration depending on the averaging
 period used.
\end_layout

\begin_layout Plain Layout
For research applications, the roll correction is seldom of much consequence,
 but the pitch correction can either produce significant improvement in
 the calculated vertical wind or, when small, can reduce the uncertainty
 below that based solely on specifications for the measurement from the
 IRS.
 The Appendix to this note presents a summary of the uncertainty components
 for vertical wind for the NSF/NCAR Gulfstream V research aircraft and shows
 that this pitch correction leads to substantial reduction in the net uncertaint
y of that measurement.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<calculate-pitch-correction, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The correction should be subtracted from PITCH to get PITCHC;
\end_layout

\begin_layout Plain Layout

## it is the error in pitch, so you get the true value by subtraction
\end_layout

\begin_layout Plain Layout

## This calculates corrections for an entire flight in one call.
\end_layout

\begin_layout Plain Layout

## D must be a dataframe containing at least VNS, VEW, GGVNS, GGVEW,
\end_layout

\begin_layout Plain Layout

## LATC, GGALT, THDG, PITCH, ROLL, 
\end_layout

\begin_layout Plain Layout

CorrectPitch <- function (D, .span=1013) {
\end_layout

\begin_layout Plain Layout

  Rate <- 1
\end_layout

\begin_layout Plain Layout

  MaxGap <- 300 * Rate
\end_layout

\begin_layout Plain Layout

  .vns <- zoo::na.approx (as.vector(D$VNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .vew <- zoo::na.approx (as.vector(D$VEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .ggvns <- zoo::na.approx (as.vector(D$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .ggvew <- zoo::na.approx (as.vector(D$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  # 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

  NAV <- .span * Rate
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (.vns-.ggvns, 3, NAV, m=1) * Rate  # m=1 for
 first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (.vew-.ggvew, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

  deltaPitchL <- -vndot/Ranadu::Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

  deltaRollL  <- vedot/Ranadu::Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

  .hdg <- D$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  deltaPitch <- (sin(.hdg)*deltaRollL + cos(.hdg)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  deltaRoll <- (cos(.hdg)*deltaRollL - sin(.hdg)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  C <- c(deltaPitch, deltaRoll)
\end_layout

\begin_layout Plain Layout

  dim(C) <- c(nrow(D), 2)
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<processing-2, fig.height=6.5, fig.cap=figcapP2, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- D[!is.na (D$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

VNS <- zoo::na.approx (as.vector(D$VNS), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

VEW <- zoo::na.approx (as.vector(D$VEW), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

NAV <- 1013*Rate
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (VNS-GGVNS, 3, NAV, m=1) * Rate  # m=1 for first
 deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (VEW-GGVEW, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

deltaPitchL <- -vndot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

deltaRollL <- vedot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

HDG <- D$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

D$deltaPitch <- (sin(HDG)*deltaRollL + cos(HDG)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

D$deltaRoll <- (cos(HDG)*deltaRollL - sin(HDG)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

# DeltaPitch2 <- CorrectPitch(D)
\end_layout

\begin_layout Plain Layout

D$dRL <- deltaRollL/Cradeg
\end_layout

\begin_layout Plain Layout

D$dPL <- deltaPitchL/Cradeg
\end_layout

\begin_layout Plain Layout

plotWAC (D[, c("Time", "dPL", "dRL")], ylab=expression (paste (delta, theta^(l),
 ' or ', delta, phi^(l), ' [', degree, ']')), lwd=c(2.5, 2, 1.5),  lty=c(1,1,3),
 ylim=c(-0.05,0.05), legend.position=NA)
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time, D$THDG/10000, col='red')
\end_layout

\begin_layout Plain Layout

legend('bottom', legend=c(expression (paste (delta, theta^(l))), expression
 (paste (delta, phi^(l)))), lwd=c(2.5,2), lty=c(1,1), col=c("blue", "darkgreen"),
 text.col=c("blue", "darkgreen"), cex=0.8, bg='lightyellow', horiz=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# D$deltaRoll <- SmoothInterp(D$deltaRoll, .Length=121)
\end_layout

\begin_layout Plain Layout

# D$deltaPitch <- SmoothInterp(D$deltaPitch, .Length=121)
\end_layout

\begin_layout Plain Layout

Z <- plotWAC (D[, c("Time", "deltaPitch", "deltaRoll")], ylab=expression
 (paste (delta, theta, ' or ', delta, phi, ' [', degree, ']')), lwd=c(2.5,
 2, 1.5),  lty=c(1,1,3), ylim=c(-0.05,0.05), legend.position=NA)
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaRoll2, col='darkgreen')
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaPitch, col='darkorange', lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaRoll, col='red', lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, D$ROLL/1000, col='red', lwd=1.5, lty=1)
\end_layout

\begin_layout Plain Layout

legend('bottom', legend=c(expression (paste (delta, theta)), expression
 (paste (delta, phi)), "ROLL/1000"), lwd=c(2.5,2,1.5), lty=c(1,1,1), col=c("blue",
 "darkgreen", "red"), text.col=c("blue", "darkgreen", "red"), cex=0.8, bg='lightye
llow', horiz=TRUE)
\end_layout

\begin_layout Plain Layout

Valid <- (D$TASX > 130)
\end_layout

\begin_layout Plain Layout

Valid[abs(D$ROLL) > 5] <- FALSE
\end_layout

\begin_layout Plain Layout

## hist (CorrectPitch(D)[Valid], xlim=c(-0.05, 0.05))
\end_layout

\begin_layout Plain Layout

## mean is very close to zero
\end_layout

\begin_layout Plain Layout

## mean (CorrectPitch(D)[Valid], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

SDofCorrection = sd (CorrectPitch(D)[Valid], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## check how this would change with an accelerometer bias of 1%
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Some details regarding smoothing
\end_layout

\begin_layout Plain Layout
While (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) provides a correction applicable to each measurement, some smoothing is
 desirable not only to decrease the uncertainty in the correction but also
 to avoid introducing high-frequency noise into signals that might distort
 the variance spectrum or affect other uses where noise is undesirable.
 A specific choice was made for the examples shown, but other choices might
 perform better and may benefit from tailoring to the flight patterns.
 The velocity errors usually vary smoothly and approximately sinusoidally,
 as shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

, except for occasional noise associated with turns or turbulence.
 Smoothing the time series of these error terms can be combined with finding
 the derivatives required in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

) if Savitzky-Golay polynomials are fitted to the time series.
 The specific choice made here is to use third-order polynomials covering
 1013 points or, for 1-Hz measurements, about 1/5 of a Schuler oscillation.
 In the 
\begin_inset Formula $l$
\end_inset

-frame where these errors are measured they are usually quite regular over
 several oscillations so this provides a compromise between good smoothing
 and response to changes in the amplitude and phase of the oscillations.
 This usually produces smooth corrections except near turns, where some
 more abrupt changes occur.
 Most research measurements of wind are made during straight flight legs,
 so these fluctuations near turns are not a serious impediment in the normal
 case.
 They appear to arise from timing differences among the different measurements
 being used.
 For example, if the measurement of heading lags behind the derivatives,
 the rotation of 
\begin_inset Formula $l$
\end_inset

-frame errors to the 
\begin_inset Formula $b$
\end_inset

-frame will lead to different errors in right vs.
\begin_inset space ~
\end_inset

left turns, leading to jumps in the correction terms like those evident
 at, e.g., about 12:00 UTC in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
The usual final step in the application of the correction algorithm for
 pitch is to subtract the term given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) from the measured pitch or roll and use the result when the Earth-relative
 wind is calculated.
 
\end_layout

\begin_layout Subsection
Correction for errors in heading
\begin_inset CommandInset label
LatexCommand label
name "sec:heading-correction"

\end_inset


\end_layout

\begin_layout Subsubsection
The basis for the correction
\end_layout

\begin_layout Plain Layout
A procedure related to that used for pitch is developed here for estimating
 the error in heading.
 The basis for the correction is that an error in heading results in an
 error in how the measured body-relative components of the acceleration
 are transformed to the ENU or 
\emph on
l
\emph default
-frame (in the terminology of the previous discussion of the correction
 for pitch).
 These errors can be detected by comparing the actual acceleration of the
 aircraft (determined from derivatives of the GPS-measured ground-speed
 components, as in the preceding section) to the IRU-provided measurements
 of acceleration after transformation to the 
\emph on
l
\emph default
-frame.
 If the IRU-provided accelerations are not available (e.g., in archived files
 where those measurements were not saved), they can be determined from recorded
 velocities by appropriate differentiation and transformation.
\end_layout

\begin_layout Plain Layout
The accelerations measured by a strap-down inertial system like the Honeywell
 systems on the GV and C-130 are the accelerations in the reference frame
 of the aircraft, or the 
\emph on
b
\emph default
-frame.
 To transform these to the 
\emph on
l
\emph default
-frame, the transformation by conventional definition of the attitude angles
 involves a rotation about the roll axis to level the wings, a rotation
 about the pitch axis to level the longitudinal axis of the aircraft, and
 a rotation about the vertical axis as required to point the aircraft to
 the north.
 However, if there is an error in the heading (
\begin_inset Formula $\delta\psi$
\end_inset

) the last rotation will give final components 
\begin_inset Formula $a_{x,y,z}^{(l)}$
\end_inset

 that have respective errors of 
\begin_inset Formula $\delta a_{x}^{(l)}=a_{x}^{(l)}(1-\cos\delta\psi)-a_{y}^{(l)}\sin\delta\psi$
\end_inset

, 
\begin_inset Formula $\delta a_{y}^{(l)}=a_{y}^{(l)}(1-\cos\delta\psi)+a_{x}^{(l)}\sin\delta\psi$
\end_inset

, and 
\begin_inset Formula $\delta a_{z}^{(l)}=0$
\end_inset

 or, for small angles,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\left[\begin{array}{c}
\delta a_{x}^{(l)}\\
\delta a_{y}^{(l)}\\
\delta a_{z}^{(l)}
\end{array}\right] & =\left[\begin{array}{ccc}
0 & -\delta\psi & 0\\
\delta\psi & 0 & 0\\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{c}
a_{x}^{(l)}\\
a_{y}^{(l)}\\
a_{z}^{(l)}
\end{array}\right]\label{eq:heading-error-equation}\\
\delta a_{x}^{(l)} & =-a_{y}^{(l)}\delta\psi\label{eq:ax-error}\\
\delta a_{y}^{(l)} & =a_{x}^{(l)}\delta\psi\label{eq:ay-error}\\
\delta\psi & =\frac{a_{x}^{(l)}\delta a_{y}^{(l)}-a_{y}^{(l)}\delta a_{x}^{(l)}}{(a_{x}^{(l)})^{2}+(a_{y}^{(l)})^{2}}\label{eq:estimator-equation}
\end{align}

\end_inset

The last equation is obtained
\begin_inset Foot
status open

\begin_layout Plain Layout
If the error measure to be minimized is 
\begin_inset Formula $\chi^{2}=(\delta a_{x}+a_{y}\delta\psi)^{2}+(\delta a_{y}-a_{x}\delta\psi)^{2}$
\end_inset

, differentiating 
\begin_inset Formula $\chi^{2}$
\end_inset

 with respect to 
\begin_inset Formula $\delta\psi$
\end_inset

 and setting the result equal to zero gives (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

).
\end_layout

\end_inset

 by minimizing the errors between the values of 
\begin_inset Formula $\delta a_{i}^{(l)}$
\end_inset

 given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax-error"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ay-error"

\end_inset

) and the measured error given by 
\begin_inset Formula $(a_{i}^{*}-a_{i}^{(l)})$
\end_inset

.
 This then gives an estimate of the rotation 
\begin_inset Formula $-\delta\psi$
\end_inset

 that gives the best match between the measured accelerations 
\begin_inset Formula $a_{i}^{(lo)}$
\end_inset

 and 
\begin_inset Formula $a_{i}^{*}$
\end_inset

 deduced from the deriviatives of the GPS-provided ground-speed components.
 The resulting value of 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) is then an estimate of the error in heading.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
An alternate and simpler (but equivalent) approach is to transform the component
s of acceleration measured in the 
\begin_inset Formula $b$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame, use them to determine the Earth-relative direction of the acceleration
 vector 
\begin_inset Formula $\alpha^{(l)}$
\end_inset

 in the 
\begin_inset Formula $l$
\end_inset

-frame, and find the difference between that result and the direction found
 for Earth-based acceleration 
\begin_inset Formula $\alpha^{*}$
\end_inset

 obtained by differentiating the measurements of velocity components by
 a GPS receiver.
 In this case,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\alpha^{*}=\arctan\frac{\dot{v}_{x}^{(l)}}{\dot{v}_{y}^{(l)}}\label{eq:alpha-GPS}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\alpha^{(l)}=\arctan\frac{a_{x}^{(l)}}{a_{y}^{(l)}}\label{eq:alpha-l}
\end{equation}

\end_inset

where 
\begin_inset Formula $\dot{v}_{1}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{2}$
\end_inset

 refer to the accelerations determined by differentiating the measurements
 of ground-speed components 
\begin_inset Formula $v_{1}$
\end_inset

 and 
\begin_inset Formula $v_{2}$
\end_inset

, the eastward and northward components of the ground speed measured by
 a GPS receiver.
 If there are no other sources of error, the difference between these two
 directions will arise from the heading error that causes the components
 {
\begin_inset Formula $a_{1}^{(l)},\,a_{2}^{(l)},\,a_{3}^{(l)}$
\end_inset

} to point in an incorrect direction in the 
\begin_inset Formula $l$
\end_inset

-frame.
 Therefore, an estimate of the heading error can be obtained from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\alpha^{*}-\alpha^{(l)}\,\,\,.\label{eq:error-estimate-2}
\end{equation}

\end_inset

Other sources of error can arise from biases or other errors in the measurements
 of acceleration, from timing errors (e.g., displacing the measurements of
 heading and so introducing errors in turns), or from the measurements by
 GPS of the velocity components relative to the Earth.
 Any of those possibilities can compromise the results that follow, so these
 error sources will need further discussion later in this note.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
To use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

), the acceleration vector 
\begin_inset Formula $\mathbf{a^{*}}$
\end_inset

 must be determined by differentiation of the GPS-measured velocity components.
 As in the pitch-correction algorithm, the choice made here is to estimate
 the derivatives using Savitzky-Golay polynomials, but with a 31
\begin_inset space \thinspace{}
\end_inset

s span to avoid excessive distortion in 3-min turns.
 Interpolation filled some rare and short gaps in the measurements prior
 to filtering.
 However, this choice affects the uncertainty of the estimate, as follows.
 It was previously estimated that the uncertainty in a measurement of accelerati
on from GPS is at least 0.01
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

/
\begin_inset Formula $\tau$
\end_inset

 where 
\begin_inset Formula $\tau$
\end_inset

 is the time over which the average is calculated.
 For 31-s polynomial fits, the effective averaging time is about 20
\begin_inset space \thinspace{}
\end_inset

s, leading to a minimum uncertainty of about 0.0005
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) indicates that, for an uncertainty in the heading correction of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

 or about 0.002
\begin_inset space ~
\end_inset

radians, the total horizontal acceleration should be at least 0.0005/0.002=0.25
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Typical horizontal accelerations in turns exceed 4
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 but accelerations exceeding 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 are seldom encountered outside of turns, so the algorithm developed here
 only provides a valid correction if there are regular turns during the
 flight.
 In the following, heading corrections will be calculated only for periods
 when the horizontal acceleration exceeds 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 to avoid excessive noise and uncertainty.
 It is significant, though, that for a flight that transits in a straight
 line from start to finish, attempts to use these estimates are unlikely
 to be useful.
 Fortunately, in most research flights there are many turns, e.g., as the
 aircraft flies back and forth over a mountain range or flies fixed raster
 patterns for mapping.
 Each turn can provide significant horizontal accelerations that give estimates
 of the heading error, but these estimates are only sporadic and must be
 linked by an extrapolation procedure to obtain valid corrections spanning
 periods without significant acceleration.
 The heading correction therefore has a higher uncertainty than the pitch
 correction and, unlike the pitch correction, depends on significant horizontal
 accelerations for its operation.
 
\end_layout

\begin_layout Plain Layout
The components of the accelerations of the aircraft in an Earth-relative
 coordinate system like the 
\begin_inset Formula $l$
\end_inset

-frame can be determined solely from measurements provided by a GPS and
 so are independent of the IRS.
 They are determined from
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout


\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout

a_{x}^{*}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

a_{y}^{*}
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]=
\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout


\backslash
frac{dv_{x}}{dt}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
frac{dv_{y}}{dt}
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]=
\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout

d(GGVEW)/dt
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

d(GGVNS)/dt
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]
\backslash
 
\backslash
 
\backslash
 .
\backslash
label{eq:acceleration-from-GPS}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The transformation from 
\begin_inset Formula $b$
\end_inset

-frame to 
\begin_inset Formula $l$
\end_inset

-frame
\end_layout

\begin_layout Plain Layout
In NCAR/EOL/RAF data archives, the appropriate body-relative accelerations
 are represented by the netCDF variables BLONGA, BLATA, BNORMA for respectively
 the 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, and 
\begin_inset Formula $z$
\end_inset

 components (in the aircraft coordinate system with 
\begin_inset Formula $x$
\end_inset

 forward, 
\begin_inset Formula $y$
\end_inset

 starboard, and 
\begin_inset Formula $z$
\end_inset

 downward), except that BNORMA represents the 
\begin_inset Formula $z$
\end_inset

-upward component and is adjusted by subtraction of the acceleration of
 gravity.
 Measurements of body accelerations similar to these are provided by most
 inertial systems used on research aircraft, so the procedure developed
 here is not unique to the NCAR aircraft, but the specific application will
 use measurements from the NSF/NCAR Gulfstream V research aircraft.
 These body accelerations will be represented by (
\begin_inset Formula $a_{1}^{(b)},\,a_{2}^{(b)},\,a_{3}^{(b)}$
\end_inset

), respectively, with 
\begin_inset Formula $a_{3}^{(b)}=\mathrm{-BNORMA}+g$
\end_inset

 where 
\begin_inset Formula $g$
\end_inset

 is the acceleration of gravity.
 Then, with {
\begin_inset Formula $\phi,\,\theta,\,\psi$
\end_inset

} representing {roll, pitch, heading}, the transformation from the 
\emph on
b
\emph default
-frame to the 
\emph on
l
\emph default
-frame is that given in standard sources include RAF Bulletin 23.
\begin_inset Foot
status open

\begin_layout Plain Layout
See Bulletin 23, but note that there is an error in Eq.
\begin_inset space ~
\end_inset

2.6, where in matrix element (1,3) the first term should be 
\begin_inset Formula $\sin\psi\sin\phi,$
\end_inset

not 
\begin_inset Formula $\sin\psi\sin\theta$
\end_inset

.
 Standard NCAR/RAF processing uses the correct transformation.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
by the rotation matix
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
R_{b}^{l}=\begin{bmatrix}\sin\psi\cos\theta & \sin\psi\sin\theta\sin\phi+\cos\psi\cos\phi & -\sin\psi\sin\theta\cos\phi+\cos\psi\sin\phi\\
\cos\psi\cos\theta & \cos\psi\sin\theta\sin\phi-\sin\psi\cos\phi & -\cos\psi\sin\theta\cos\phi-\sin\psi\sin\phi\\
-\sin\theta & \cos\theta\sin\phi & \cos\theta\cos\phi
\end{bmatrix}\label{eq:transform-b-to-l}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
so 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathbf{a^{(l)}}=R_{b}^{l}\mathbf{a^{(b)}}\label{eq:matrix-multiplication-eq}
\end{equation}

\end_inset


\end_layout

\end_inset

This transformation then gives the accelerations in the local reference
 frame with 
\begin_inset Formula $x$
\end_inset

-axis east, 
\begin_inset Formula $y$
\end_inset

-axis north, and 
\begin_inset Formula $z$
\end_inset

-axis upward.
 It incorporates the change in axis definitions as well as the required
 signs of the rotations.
\begin_inset Note Note
status open

\begin_layout Plain Layout
signs of roll and pitch are reversed but heading is kept unchanged
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinitialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "rf15" 				
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"			 
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%sZPC.nc", Directory,Project,Project,Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("BLATA", "BLONGA", "BNORMA",
\end_layout

\begin_layout Plain Layout

              "VNS", "VEW", "VSPD", "GGVNS", "GGVEW", 
\end_layout

\begin_layout Plain Layout

              "GGVSPD", "LAT", "LON", "ALT", "THDG", "PITCH", "ROLL") 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData3 <- sprintf("%s3.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))	
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData3)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (SaveRData3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180
\end_layout

\begin_layout Plain Layout

s <- -60
\end_layout

\begin_layout Plain Layout

Data$VEW <- ShiftInTime (Data$VEW, 1, s)
\end_layout

\begin_layout Plain Layout

Data$VNS <- ShiftInTime (Data$VNS, 1, s)
\end_layout

\begin_layout Plain Layout

Data$THDG <- ShiftInTime (Data$THDG, 1, s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sg-poly-smoothing, include=FALSE, fig.lp="fig:", fig.cap=c("Ground-speed
 components measured using GPS.", "Estimated components of horizontal acceleratio
n for DEEPWAVE flight rf15, obtained via differentiation of the GPS-measured
 variables GGVEW and GGVNS")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- Data[!is.na (Data$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

D$GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$vndot <- signal::sgolayfilt (D$GGVNS, 3, 21, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

D$vedot <- signal::sgolayfilt (D$GGVEW, 3, 21, m=1)
\end_layout

\begin_layout Plain Layout

D$vzdot <- signal::sgolayfilt (D$GGVSPD, 3, 7, m=1)
\end_layout

\begin_layout Plain Layout

plotWAC(D[, c("Time", "GGVNS", "GGVEW")])
\end_layout

\begin_layout Plain Layout

plotWAC(D[, c("Time", "vndot", "vedot", "vzdot")])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Xform, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Xform <- function (data) { # data must contain ROLL, PITCH, HEADING, 
\end_layout

\begin_layout Plain Layout

                           # BLATA, BLONGA, BNORMA
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  if ("PITCHC" %in% names(data)) {data$PITCH <- data$PITCHC}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## note minus signs in the next line
\end_layout

\begin_layout Plain Layout

  PITCH <- -data$PITCH * Cradeg; ROLL <- -data$ROLL * Cradeg
\end_layout

\begin_layout Plain Layout

  THDG <- data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  cosphi <- cos (ROLL)
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (ROLL)
\end_layout

\begin_layout Plain Layout

  costheta <- cos (PITCH)
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (PITCH)
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (THDG)
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (THDG)
\end_layout

\begin_layout Plain Layout

  G <- Gravity (data$LATC, data$GGALT)
\end_layout

\begin_layout Plain Layout

  d <- data.frame("X" = data$BLONGA)
\end_layout

\begin_layout Plain Layout

  d$Y <- data$BLATA
\end_layout

\begin_layout Plain Layout

  d$Z <- data$BNORMA + G    ## need to add G for transform; 
\end_layout

\begin_layout Plain Layout

                            ## it was removed from sensed accel.
\end_layout

\begin_layout Plain Layout

  A <- as.matrix(d)
\end_layout

\begin_layout Plain Layout

  DL <- nrow(data)
\end_layout

\begin_layout Plain Layout

  One <- rep (1, DL)
\end_layout

\begin_layout Plain Layout

  ZZ <- rep (0, DL)
\end_layout

\begin_layout Plain Layout

  T1 <- aperm(array (c(One,ZZ,ZZ,ZZ,cosphi,-sinphi,ZZ,sinphi,cosphi), 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  T2 <- aperm(array (c (costheta,ZZ,sintheta,ZZ,One,ZZ,-sintheta,ZZ,costheta),
 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  T3 <- aperm(array (c (cospsi,-sinpsi,ZZ,sinpsi,cospsi,ZZ,ZZ,ZZ,One), 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  AX <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  AY <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  AZ <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  X <- zoo::na.approx (as.vector(d$X), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Y <- zoo::na.approx (as.vector(d$Y), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Z <- zoo::na.approx (as.vector(d$Z), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  X[is.na(X)] <- 0
\end_layout

\begin_layout Plain Layout

  Y[is.na(Y)] <- 0
\end_layout

\begin_layout Plain Layout

  Z[is.na(X)] <- 0
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  for (i in 1:DL) {
\end_layout

\begin_layout Plain Layout

    Y1 <- T1[,,i] %*% matrix (A[i,], 3, 1)
\end_layout

\begin_layout Plain Layout

    Y2 <- T2[,,i] %*% Y1
\end_layout

\begin_layout Plain Layout

    Y3 <- T3[,,i] %*% Y2
\end_layout

\begin_layout Plain Layout

    AX[i] <- Y3[1]; AY[i] <- Y3[2]; AZ[i] <- Y3[3]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  AZ <- AZ - G
\end_layout

\begin_layout Plain Layout

  return (data.frame(AX=AX, AY=AY, AZ=AZ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-b-vector-and-transform, include=TRUE, fig.cap=c("Accelerations ($a_x$,
 $a_y$, $a_z$) measured by an INS during a circle maneuver, 3:40:00--3:55:00
 UTC on 3 July 2014, DEEPWAVE flight 15.
 Also shown as dotted lines are the accelerations deduced from differentiating
 the corresponding GPS-measured ground-speed components ($v_n$ and $v_e$).")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## these captions are just saved here; they apply to plots now suppressed
\end_layout

\begin_layout Plain Layout

FC1a <- "Measured accelerations translated to the l-frame (x east, y north,
 z up) for DEEPWAVE flight 15, 3 July 2014."
\end_layout

\begin_layout Plain Layout

FC1c <- "As for the preceding figure but for a pitch maneuver, 4:25:00--4:30:00
 UTC."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol = 1), widths = 1, heights = c(5))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G <- Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(D$BLONGA, D$BLATA, D$BNORMA+G), ncol=3) #aircraft-frame 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (D, AB)                                  #l-frame
\end_layout

\begin_layout Plain Layout

D$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

D$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

D$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

D$LACCX <- signal::sgolayfilt (D$LACCX, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D$LACCY <- signal::sgolayfilt (D$LACCY, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D$LACCZ <- signal::sgolayfilt (D$LACCZ, 3, 7, m=0)
\end_layout

\begin_layout Plain Layout

# plotWAC(D[, c("Time", "LACCX", "LACCY", "LACCZ")], ylab="acceleration
 [m/s^2]")
\end_layout

\begin_layout Plain Layout

V <- c("Time", "LACCX", "LACCY", "LACCZ", "vedot", "vndot")
\end_layout

\begin_layout Plain Layout

r <- setRange(D$Time, 33500,35500)
\end_layout

\begin_layout Plain Layout

plotWAC(D[r,V], lw=c(3,3,3,5,5), lty=c(1,1,1,3,3), 
\end_layout

\begin_layout Plain Layout

        ylab=expression ("acceleration [" ~ m/s^{2} ~ "]"), legend.position=NA)
\end_layout

\begin_layout Plain Layout

legend('bottomleft', legend=c(expression(a[x]), expression(a[y]), expression(a[z
]),
\end_layout

\begin_layout Plain Layout

       expression(dv[e]/dt), expression(dv[n]/dt)), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'darkgreen', 'red', 'cyan3', 'darkorange'),
\end_layout

\begin_layout Plain Layout

       text.col=c('blue', 'darkgreen', 'red', 'cyan3', 'darkorange'),
\end_layout

\begin_layout Plain Layout

       lwd=c(3,3,3,5,5), lty=c(1,1,1,3,3), bg='lightyellow')
\end_layout

\begin_layout Plain Layout

# r <- setRange(D$Time, 42500, 42830)
\end_layout

\begin_layout Plain Layout

# V <- c(V, "vzdot")
\end_layout

\begin_layout Plain Layout

# plotWAC(D[r,V], lw=c(3,3,3,5,5,5), lty=c(1,1,1,3,3,2))
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time[r], D$vzdot[r], col='green', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
To demonstrate that the accelerations obtained in this way are good matches
 to the accelerations determined by differentiation of GPS-determined velocities
 and to check the transformation matrix, an example of the two components
 of acceleration as determined in these two ways is shown in Fig.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform}
\end_layout

\end_inset

.
 This flight segment is a circle maneuver in which a full circle is flown
 twice drifting with the wind using constant-bank left turns and then twice
 using right turns.
 The acceleration components therefore have sinusoidal variations, and as
 shown in the figure the two independent measurements match very well.
 This checks the transformations and shows sufficient agreement without
 substantial noise, a requirement if the small difference is to be used
 to correct the measurements of heading.
 A similar plot, not shown, illustrated similar agreement in vertical components
 for a pitch maneuver in which the pitch of the aircraft is varied with
 about a 20
\begin_inset space \thinspace{}
\end_inset

s period while flying without roll and allowing the aircraft to climb and
 descend in response to the changes in pitch.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax-error"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) could then be used to estimate the heading error.
 However, if the accelerations (
\begin_inset Formula $a_{x},\,a_{y}$
\end_inset

) are small, as is common in straight-and-level flight, the resulting estimates
 may have large uncertainty.
 A more robust estimate is to calculate the difference 
\begin_inset Formula $\delta\psi=\psi_{g}-\psi_{a}$
\end_inset

 where 
\begin_inset Formula $\psi_{g}$
\end_inset

 is the angle obtained from the arctangent of the GPS-measured accelerations
 
\begin_inset Formula $\dot{V}$
\end_inset

 and 
\begin_inset Formula $\psi_{a}$
\end_inset

 is the corresponding angle obtained from the measured body accelerations
 after translation to the l
\emph on
-frame:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\psi_{g} & =\arctan\frac{\dot{V_{e}}}{\dot{V_{n}}}=\mathrm{atan2(\dot{V_{n}},\,\dot{V_{e}})}\label{eq:psi-g}\\
\psi_{a} & =\arctan\frac{a_{x}}{a_{y}}=\mathrm{atan2}(a_{y},\,a_{x})\label{eq:psi-a}
\end{align}

\end_inset


\emph default
A difference between these angles could arise from several sources:
\end_layout

\begin_layout Enumerate
An error in the heading measurement would result in incorrect rotation of
 the measured accelerations to the 
\emph on
l
\emph default
-frame;
\end_layout

\begin_layout Enumerate
There might be bias or scale errors in the accelerometers, leading to incorrect
 components of acceleration;
\end_layout

\begin_layout Enumerate
There could be offsets in the times at which the measured accelerations
 and the GPS ground-speed components are measured.
 This would appear clearly in turns, where clockwise and counterclockwise
 turns would reverse sign if other effects are negligible.
\end_layout

\begin_layout Plain Layout
These will be examined in following subsections.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection
The GPS-derived estimate of accelerations
\end_layout

\begin_layout Plain Layout
The variables 
\begin_inset Formula $\dot{V_{n}}$
\end_inset

 and 
\begin_inset Formula $\dot{V_{e}}$
\end_inset

 must be found from derivatives of the GPS-measured velocity components.
 For this purpose, as in the pitch-correction algorithm, the choice made
 here is to estimate the derivatives using Savitzky-Golay polynomials, which
 are computationally efficient, don't introduce a time shift, and can provide
 derivatives directly.
 A rather long averaging period of 1009 s, or about 1/5 of a Schuler oscillation
, was used to reduce noise in the result, and interpolation filled some
 gaps in the measurements.
 The ground-speed components measured via GPS are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sg-poly-smoothing1}
\end_layout

\end_inset

, and the derivative calculated and smoothed as described above is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sg-poly-smoothing2}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsection
The 
\emph on
l
\emph default
-frame accelerations
\end_layout

\begin_layout Plain Layout
The result of transforming the accelerations in the 
\emph on
b
\emph default
-frame to the 
\emph on
l
\emph default
-frame is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform1}
\end_layout

\end_inset

.
 This flight was devoted to calibration maneuvers, so there are circle maneuvers
 (e.g., about 3:45:00), pitch maneuvers (e.g., about 4:27:00) and yaw maneuvers
 (e.g., about 4:33:00) as well as speed runs (e.g., about 5:05:00).
 This accounts for the large horizontal accelerations (in the circles) and
 the large vertical accelerations (in the pitch maneuvers).
 The good matches between measured accelerations translated to the 
\emph on
l
\emph default
-frame and those deduced from the derivative of the GPS-measured ground-speed
 components, shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform2}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform3}
\end_layout

\end_inset

 provide good evidence for the approach being taken and the suitability
 of the transformation used.
 One aspect that is troubling, however, is the poorer agreement for the
 vertical accelerations compared in Fig.\SpecialChar softhyphen

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform3}
\end_layout

\end_inset

, dotted-green vs red lines.
 Peak values for the measured accelerations consistently exceed those determined
 by differentiation of the rat-of-climb of the aircraft.
 [look into this further]
\end_layout

\begin_layout Subsection
The differences in angles determined from the acceleration components
\end_layout

\begin_layout Plain Layout
Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

 is the basis for estimating the error in heading, so it is useful to consider
 the two terms in that equation and the combined prediction, to check for
 consistency.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

 shows the two estimates of error and their combination as in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Example: DEEPWAVE flight 15
\end_layout

\begin_layout Plain Layout
DEEPWAVE flight 15 was devoted to calibration maneuvers and included three
 circle maneuvers like that shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform}
\end_layout

\end_inset

 as well as some other maneuvers and turns that introduced horizontal accelerati
ons.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

 shows the estimated heading error obtained from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) for this flight.
 Values are plotted only where the total horizontal acceleration exceeded
 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

, the airspeed exceeded 130 m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (to exclude periods of strong acceleration or deceleration near the start
 and end of the flight), and the absolute value of the rate of climb was
 less than 3
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (to exclude climbs and descents).
 Also shown as the red line is a smoothed representation of the heading
 correction.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<error-components, fig.height=4.5, include=TRUE, fig.cap="Heading error as
 estimated from (
\backslash

\backslash
ref{eq:estimator-equation}) for DEEPWAVE flight 15.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# D$err1 <- (D$vedot - D$LACCX) / D$LACCY * 180/pi
\end_layout

\begin_layout Plain Layout

# D$err2 <- -(D$vndot - D$LACCY) / D$LACCX * 180/pi
\end_layout

\begin_layout Plain Layout

# hlim <- 0.1
\end_layout

\begin_layout Plain Layout

# D$herr <- D$err1
\end_layout

\begin_layout Plain Layout

# t <- abs(D$LACCY) < abs(D$LACCX)
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- D$err2[t]
\end_layout

\begin_layout Plain Layout

# t <- abs(D$LACCX) + abs(D$LACCY) < hlim*2
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- NA
\end_layout

\begin_layout Plain Layout

# D$herr <- zoo::na.approx (as.vector(D$herr), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# t <- is.na(D$herr)
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- 0
\end_layout

\begin_layout Plain Layout

# D$herr <- signal::sgolayfilt (D$herr, 3, 1021, m=0)  
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- NA
\end_layout

\begin_layout Plain Layout

# r <- setRange(D$Time, 33800,35500)
\end_layout

\begin_layout Plain Layout

# plotWAC (D[r, c("Time", "err1", "err2", "herr")], ylim=c(-10.,10.))
\end_layout

\begin_layout Plain Layout

D$ang1 <- atan2(D$vndot, D$vedot) / Cradeg
\end_layout

\begin_layout Plain Layout

D$ang2 <- atan2(D$LACCY, D$LACCX) / Cradeg
\end_layout

\begin_layout Plain Layout

#plotWAC(D[, c("Time", "ang1", "ang2")])
\end_layout

\begin_layout Plain Layout

#plotWAC(D$Time, D$ang1-D$ang2, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

A2 <- D$LACCX^2 + D$LACCY^2
\end_layout

\begin_layout Plain Layout

A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

D$herr <- (-D$LACCY*(D$vedot-D$LACCX)+D$LACCX*(D$vndot-D$LACCY)) / (Cradeg*A2)
\end_layout

\begin_layout Plain Layout

#plotWAC(D$Time, D$herr, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- D
\end_layout

\begin_layout Plain Layout

v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

v <- v & (A > 1) & abs (D$herr) < 0.3 & abs(D$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

plotWAC(DT$Time, DT$herr, ylim=c(-0.2,0.2), type='p', pch=20, col='blue',
\end_layout

\begin_layout Plain Layout

        ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

# he <- 0
\end_layout

\begin_layout Plain Layout

# tau <- 10
\end_layout

\begin_layout Plain Layout

# hea <- vector ('numeric', nrow(D))
\end_layout

\begin_layout Plain Layout

# k <- 0
\end_layout

\begin_layout Plain Layout

# for (i in 1:nrow(D)) {
\end_layout

\begin_layout Plain Layout

#   if (D$TASX[i] > 130 && A[i] > 1 && abs(D$herr[i]) < 0.3 && abs(D$GGVSPD[i])
 < 2) {
\end_layout

\begin_layout Plain Layout

#     he <- he + (D$herr[i]-he)/tau
\end_layout

\begin_layout Plain Layout

#     k <- k + 1
\end_layout

\begin_layout Plain Layout

#     if (k > 20) {tau = 60}
\end_layout

\begin_layout Plain Layout

#   }
\end_layout

\begin_layout Plain Layout

#   hea[i] <- he
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time, hea, col='red')
\end_layout

\begin_layout Plain Layout

ts <- DT[v,]
\end_layout

\begin_layout Plain Layout

meanDh <- mean(ts$herr)
\end_layout

\begin_layout Plain Layout

# plotWAC(ts[, c("Time", "herr"), ], ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

bf <- signal::butter(3,1/300)
\end_layout

\begin_layout Plain Layout

# ts$herr <- signal::filtfilt(bf, ts$herr)
\end_layout

\begin_layout Plain Layout

# lineWAC(ts$Time, ts$herr, col='red')
\end_layout

\begin_layout Plain Layout

D$hs <- rep(NA, nrow(DT))
\end_layout

\begin_layout Plain Layout

D$hs <- rep(meanDh, nrow(DT))
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(ts)) {
\end_layout

\begin_layout Plain Layout

  ix <- which(D$Time == ts$Time[i])
\end_layout

\begin_layout Plain Layout

  D$hs[ix] <- ts$herr[i]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

hs <- zoo::na.approx (as.vector(D$hs), maxgap=3000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

hs <- signal::filtfilt(bf, hs)
\end_layout

\begin_layout Plain Layout

lineWAC(D$Time, hs, col='red')
\end_layout

\begin_layout Plain Layout

legend('bottomleft', legend=expression(paste("smoothed ",delta,psi)), col='red',
\end_layout

\begin_layout Plain Layout

       text.col='red', lwd=2, lty=1, bg='lightyellow')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The mean estimated heading error for this flight was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanDh,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so the indicated heading correction is significant and would change the
 lateral component of the horizontal wind by about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanDh*220*pi/180,2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 for a representative flight speed of 220
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Also shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, as a red line, is a smoothed representation of the heading correction.
 This was obtained as follows:
\end_layout

\begin_layout Enumerate
A new variable was initialized at the mean value of 
\begin_inset Formula $\delta\psi$
\end_inset

 for the flight.
\end_layout

\begin_layout Enumerate
At each point where there was a valid estimate of 
\begin_inset Formula $\delta\psi$
\end_inset

, as defined above and displayed as blue dots in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, the value of the new variable was replaced by that estimate.
\end_layout

\begin_layout Enumerate
The resulting time series was then filtered via a Butterworth third-order
 low-pass filter with a cutoff frequency corresponding to a period of 5
 min.
 The filtering was applied both forward and backward to minimize phase shift.
 (Short periods at the start and end than turn down toward zero are the
 result of zero-padding to initialize the filter.)
\end_layout

\begin_layout Plain Layout
The result was a smoothly varying estimate of the heading correction that,
 in this case, showed little variation over the time of the flight.
 The mean value of the correction, quoted above, is also a reasonable estimate
 of the correction for the entire flight.
\end_layout

\begin_layout Plain Layout
The result of this procedure is very sensitive to differences in timing
 of measurements from the IRS and GPS, because in turns any lag appears
 as an offset in the accelerations that mimics a heading error.
 In the circle maneuvers shown, the circles were flown first in left and
 then in right turns, so any timing errors would result in an offset between
 the estimated errors for the two turn directions.
 Simulated shifts in the signals showed that even a 10
\begin_inset space ~
\end_inset

ms shift led to an evident offset, so this is a very sensitive test of the
 accuracy of the signal timing.
 The fluctuations shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, for any of the indicated segments, can be eliminated by appropriate shifting
 of the heading measurement, but slightly different values are then required
 for each circle pattern so there may be small changes in the time shift
 of the heading measurement during the flight.
 When applied to another dataset or another aircraft, this is an important
 check that is made best by using circles such as were flown here.
 However, it may be best to find the time shift that minimizes these fluctuation
s, as done here, and then use the mean correction for the flight because
 there is no indication of a change with time for this case.
\end_layout

\begin_layout Subsubsection
Example: DEEPWAVE flight 16
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<flight-16, include=FALSE, fig.cap="Flight track of DEEPWAVE flight 16,
 July 4 2014, with repeated passes over the South Island of New Zealand.
 Times are HH:MM UTC.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(maps)
\end_layout

\begin_layout Plain Layout

Flight <- "rf16h" 
\end_layout

\begin_layout Plain Layout

fname <- sprintf ("%s%s/%s%s.nc", DataDirectory(), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData4 <- sprintf("%s4.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF(fname, standardVariables(VarNames))
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData4)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData4)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##### TEMPORARY #####
\end_layout

\begin_layout Plain Layout

# print("heading adjustment applied as test of sign")
\end_layout

\begin_layout Plain Layout

# Data$THDG <- Data$THDG + 0.08
\end_layout

\begin_layout Plain Layout

#####################
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rate <- 1  
\end_layout

\begin_layout Plain Layout

if ((Data$Time[2]-Data$Time[1]) <= 0.04) {Rate <- 25} 
\end_layout

\begin_layout Plain Layout

LD <- nrow(Data)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[!is.na (Data$Time), ]
\end_layout

\begin_layout Plain Layout

s <- -60
\end_layout

\begin_layout Plain Layout

D$THDG <- ShiftInTime (D$THDG, Rate, s)
\end_layout

\begin_layout Plain Layout

D$VEW <- ShiftInTime (D$VEW, Rate, s)    ## this is needed for pitch correction
\end_layout

\begin_layout Plain Layout

D$VNS <- ShiftInTime (D$VNS, Rate, s)
\end_layout

\begin_layout Plain Layout

D$BLONGA <- ShiftInTime (D$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

D$BLATA <- ShiftInTime (D$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

D$BNORMA <- ShiftInTime (D$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

C <- CorrectPitch(D)
\end_layout

\begin_layout Plain Layout

D$PITCHC <- D$PITCH - C[,1]
\end_layout

\begin_layout Plain Layout

D$ROLLC  <- D$ROLL  - C[,2]
\end_layout

\begin_layout Plain Layout

DataSave <- D
\end_layout

\begin_layout Plain Layout

D$PITCH <- D$PITCHC
\end_layout

\begin_layout Plain Layout

D$ROLL <- D$ROLLC
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (Rate > 1) {
\end_layout

\begin_layout Plain Layout

  D1 <- D[(as.numeric(D$Time) %% 1) < 0.01,]
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D1 <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# plotTrack(D1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (ggvns, 3, 21, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (ggvew, 3, 21, m=1)
\end_layout

\begin_layout Plain Layout

G <- Gravity (D1$LATC, D1$GGALT)
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (D1, AB)                                  #l-frame
\end_layout

\begin_layout Plain Layout

D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<errors-rf16, fig.height=4.5, include=FALSE, fig.cap="Heading error as estimated
 from (
\backslash

\backslash
ref{eq:estimator-equation}) for DEEPWAVE flight 16.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A2 <- D1$LACCX^2 + D1$LACCY^2
\end_layout

\begin_layout Plain Layout

A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2)
\end_layout

\begin_layout Plain Layout

# plotWAC(D$Time, D$herr, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- D1
\end_layout

\begin_layout Plain Layout

v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

v <- v & (A > 1) & abs (DT$herr) < 0.3 & abs(DT$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

r <- setRange(D1$Time, 80000, 82500)
\end_layout

\begin_layout Plain Layout

r <- setRange(D1$Time, 0, 0)
\end_layout

\begin_layout Plain Layout

r <- DT$ROLL > 10
\end_layout

\begin_layout Plain Layout

l <- DT$ROLL < -10
\end_layout

\begin_layout Plain Layout

plotWAC(DT$Time[r], DT$herr[r], ylim=c(-0.5,0.5), type='p', pch=20, col='blue',
\end_layout

\begin_layout Plain Layout

        ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

lineWAC(DT$Time[l], DT$herr[l], type='p', pch=20, col='darkgreen')
\end_layout

\begin_layout Plain Layout

ts <- DT[v,]
\end_layout

\begin_layout Plain Layout

meanDh16 <- mean(ts$herr)
\end_layout

\begin_layout Plain Layout

# plotWAC(ts[, c("Time", "herr"), ], ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

bf <- signal::butter(3,1/300)
\end_layout

\begin_layout Plain Layout

D1$hs <- rep(meanDh16, nrow(D1))
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(ts)) {
\end_layout

\begin_layout Plain Layout

  ix <- which(D1$Time == ts$Time[i])
\end_layout

\begin_layout Plain Layout

  D1$hs[ix] <- ts$herr[i]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

hs <- zoo::na.approx (as.vector(D1$hs), maxgap=3000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

hs <- signal::filtfilt(bf, hs)
\end_layout

\begin_layout Plain Layout

lineWAC(D1$Time, hs, col='red')
\end_layout

\begin_layout Plain Layout

legend('topright', legend=expression(paste("smoothed ",delta,psi)), col='red',
\end_layout

\begin_layout Plain Layout

       text.col='red', lwd=2, lty=1, bg='lightyellow')
\end_layout

\begin_layout Plain Layout

sdDh16 <- sd(hs, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<spline-plot, include=TRUE, fig.cap="Estimates of heading errors arising
 from turns during DEEPWAVE flight 16 (4 July 2014).
 Estimates from each left and right turn are plotted separately, and two
 spline fits with different degrees of smoothing are shown.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

formatTime <- function (time) {
\end_layout

\begin_layout Plain Layout

  t <- as.POSIXlt (time)
\end_layout

\begin_layout Plain Layout

  tt <- sprintf ("%d:%02d:%02d", t$hour, t$min, t$sec)
\end_layout

\begin_layout Plain Layout

  return (tt)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$TestR <- (!is.na(DT$Time) & (DT$ROLL > 10))
\end_layout

\begin_layout Plain Layout

DT$TestL <- (!is.na(DT$Time) & (DT$ROLL < -10))
\end_layout

\begin_layout Plain Layout

DSET <- data.frame ()
\end_layout

\begin_layout Plain Layout

set <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmean <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsd <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbar <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmeanR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsdR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbarR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmeanL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsdL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbarL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setStart <- 0
\end_layout

\begin_layout Plain Layout

NRA <- 50
\end_layout

\begin_layout Plain Layout

for (k in 1:nrow(DT)) {
\end_layout

\begin_layout Plain Layout

  if (DT$TestR[k] || DT$TestL[k]) {
\end_layout

\begin_layout Plain Layout

    if (setStart == 0) {
\end_layout

\begin_layout Plain Layout

      setStart <- k
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

    } else if (as.numeric(difftime(DT$Time[k], DT$Time[setEnd], units='sec'))
 > 300) {
\end_layout

\begin_layout Plain Layout

      if (length(DSET[DSET$TestR == TRUE, "herr"]) > 50 &&
\end_layout

\begin_layout Plain Layout

          length(DSET[DSET$TestL == TRUE, "herr"]) > 50) {      
\end_layout

\begin_layout Plain Layout

        hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

                      sqrt (length (DSET$TestR)/NRA)
\end_layout

\begin_layout Plain Layout

        hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

                     sqrt (length (DSET$TestL)/NRA)
\end_layout

\begin_layout Plain Layout

        tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

       # print (sprintf ("R time %s count %d", as.POSIXct (tbrR, origin="2014-07-
04", tz="GMT"), length(DSET$TestR)))
\end_layout

\begin_layout Plain Layout

        hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

        hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

        tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

       # print (sprintf ("L time %s count %d", as.POSIXct (tbrL, origin="2014-07-
04", tz="GMT"), length(DSET$TestL)))
\end_layout

\begin_layout Plain Layout

        hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

        hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

        tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      setStart <- k
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- DT[k,]
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if (nrow(DSET) > 100) {
\end_layout

\begin_layout Plain Layout

  hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / sqrt (length (DSET$TestR)/NR
A)
\end_layout

\begin_layout Plain Layout

  hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / sqrt (length (DSET$TestL)/NR
A)
\end_layout

\begin_layout Plain Layout

  tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  if (length(DSET[DSET$TestR == TRUE, "herr"]) > 50 &&
\end_layout

\begin_layout Plain Layout

      length(DSET[DSET$TestL == TRUE, "herr"]) > 50) {
\end_layout

\begin_layout Plain Layout

    hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

    hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

    tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

    hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

    hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

    tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clr <- c("right", "left", "spline")
\end_layout

\begin_layout Plain Layout

col <- c ('blue', 'darkgreen', "red")
\end_layout

\begin_layout Plain Layout

EH <- data.frame(tbar=c(tbarL, tbarR), hmeanR=c(rep(NA, length(tbarL)), hmeanR),
 hmeanL=c(hmeanL, rep(NA, length(tbarR))), hsdR=c(rep(NA, length(tbarL)),
 hsdR), hsdL=c(hsdL, rep(NA, length(tbarR))))
\end_layout

\begin_layout Plain Layout

EH$tbar <- as.POSIXct (EH$tbar, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

whmean <- weighted.mean (c(EH$hmeanR, EH$hmeanL), 
\end_layout

\begin_layout Plain Layout

                         c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

whsd <- sqrt (1/sum(c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

p <- ggplot(EH, aes(x=tbar), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_errorbar(aes(ymin=hmeanR-hsdR, ymax=hmeanR+hsdR, colour=clr[1]),
\end_layout

\begin_layout Plain Layout

                       width=600, size=1.5, na.rm=TRUE) + ylim (-0.25,0.15)
\end_layout

\begin_layout Plain Layout

p <- p + geom_point (aes(y = hmeanR, colour=clr[1]),size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_errorbar(aes(ymin=hmeanL-hsdL, ymax=hmeanL+hsdL, colour=clr[2]),
\end_layout

\begin_layout Plain Layout

                       width=600, size=1.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_point (aes(y = hmeanL, colour=clr[2]), size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + ylab(expression(paste(delta,psi,' [',degree,']')))
\end_layout

\begin_layout Plain Layout

p <- p + xlab ("Time [UTC]")
\end_layout

\begin_layout Plain Layout

yss <- c(EH$hmeanL[!is.na(EH$hmeanL)], EH$hmeanR[!is.na(EH$hmeanR)])
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(EH$tbar, yss, df=8, spar=0.7)
\end_layout

\begin_layout Plain Layout

# xss <- as.POSIXct (SS$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

# p <- p + geom_line(aes(x=xss, y=SS$y, colour=clr[3]), lwd=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

D1$HC <- predict(SS, as.numeric(D1$Time))$y
\end_layout

\begin_layout Plain Layout

p <- p + geom_line (data=D1, aes (x=Time, y=HC, colour=clr[3]), lwd=2, na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

SS2 <- smooth.spline(EH$tbar, yss, df=8, spar=0.4)
\end_layout

\begin_layout Plain Layout

xss2 <- as.POSIXct (SS2$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

p <- p + geom_line(aes(x=xss2, y=SS2$y, colour=clr[3]), lwd=2, lty=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cols <- c("right"="blue", "left"="darkgreen", "spline"="red")
\end_layout

\begin_layout Plain Layout

p <- p + scale_colour_manual("turn direction:", values=cols)
\end_layout

\begin_layout Plain Layout

p <- p + guides(color=guide_legend(override.aes=list(shape=c(16,16,NA), 
\end_layout

\begin_layout Plain Layout

                                                     linetype=c(0,0,1))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p <- p + theme_WAC()
\end_layout

\begin_layout Plain Layout

print (p)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<construct-HR-correction>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## construct the high-rate heading correction HC
\end_layout

\begin_layout Plain Layout

D$HC <- predict(SS, as.numeric(D$Time))$y
\end_layout

\begin_layout Plain Layout

DSAVE <- D    # save for use in later section
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Flight 16 from the DEEPWAVE project was a more typical research flight,
 in which repeated passes were flown over the mountainous terrain of New
 Zealand.
 Legs of typically about 45 min duration started and ended with turns that
 usually reversed course and so provided good accelerations for correcting
 the measurement of heading.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 shows the deduced heading errors for this flight.
 The weighted mean error was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whmean,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circlearrowleft}$
\end_inset

 and the standard deviation in the weighted mean error was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whsd, 2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so this indicates that for this flight the mean correction was close to
 that for flight 15.
 The standard deviation represents a low uncertainty that, translated to
 the lateral component of the horizontal wind, would amount to an uncertainty
 of about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whsd*220*pi/180, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This uncertainty is small in comparison to other contributions, as discussed
 more extensively in the Appendix.
 The algorithm used to find these values and the spline representations
 shown in the figure is explained in more detail in the next subsection.
\end_layout

\begin_layout Subsubsection
Details regarding the correction algorithm
\end_layout

\begin_layout Plain Layout

\emph on
[maybe move this to an appendix?]
\end_layout

\begin_layout Plain Layout
The intent of this section is to provide an algorithm suitable for routine
 use.
 The requirements for this algorithm are as follows:
\end_layout

\begin_layout Itemize
The flight pattern must include maneuvers that provide horizontal accelerations,
 usually turns of at least 30
\begin_inset space \thinspace{}
\end_inset

s duration 
\emph on
in each direction.

\emph default
 The reason is that it is difficult to correct for timing errors in the
 measurements of heading relative to the measured ground-speed components
 from a GPS receiver, and even a delay of 50
\begin_inset space \thinspace{}
\end_inset

ms will, for a turn rate corresponding to a three-minute turn through 360
\begin_inset Formula $^{\circ}$
\end_inset

, lead to a 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 false indication of a heading error.
 However, the error reverses sign with the direction of the turn, so averaging
 the results from left turns and from right turns will correct for this
 false indication of a heading error.
 Course-reversal maneuvers like 
\begin_inset Quotes eld
\end_inset

90-270
\begin_inset Quotes erd
\end_inset

 turns (90
\begin_inset Formula $^{\circ}$
\end_inset

 one direction followed by 270
\begin_inset Formula $^{\circ}$
\end_inset

 the other direction) provide good data for this algorithm, as do 
\begin_inset Quotes eld
\end_inset

60-300-60
\begin_inset Quotes erd
\end_inset

 teardrop turns that are a faster means of returning to the starting point.
 If wind measurements are critical to the research, it may be useful to
 include patterns like 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 turns periodically, with 30
\begin_inset space \thinspace{}
\end_inset

s turns in opposite directions, to provide the needed accelerations.
\end_layout

\begin_layout Itemize
To the extent possible, sampled time series should be corrected for sampling
 delays.
 The most important such correction is the timing of the heading measurements
 from the INS relative to the ground-speed measurements from the GPS.
 In the examples shown in this note, the differences between different turn
 directions were minimized by shifting the heading forward in time by 140
 ms, so this shift was applied before calculations such as those shown in
 Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:errors-rf16}
\end_layout

\end_inset

.
 The averaging provided by the first item above helps reduce errors from
 timing, but it is still preferable to keep those errors small.
 Circle maneuvers such as used to construct Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:errors-rf16}
\end_layout

\end_inset

 provide a sensitive test of timing errors.
\end_layout

\begin_layout Plain Layout
Many research flights and research data sets meet these requirements, and
 they can be addressed in flight plans for future projects.
 The algorithm implemented here, for which specific R code is available,
 follows these steps:
\end_layout

\begin_layout Enumerate

\emph on
Shift the heading measurement as needed, where necessary using fractional
 increments in the time series.

\emph default
 For example, the standard high-rate data sets provided by the NCAR/EOL/RAF
 data processing are 25
\begin_inset space \thinspace{}
\end_inset

Hz time series, so a shift of 140
\begin_inset space \thinspace{}
\end_inset

ms represents a 3.5-increment.
 This can be accomplished using interpolation to higher-rate series, filtering
 of the high-rate file, and resampling at the original rate.
\end_layout

\begin_layout Enumerate

\emph on
For data files produced at rates above 1
\begin_inset space \thinspace{}
\end_inset

Hz, construct a 1
\begin_inset space \thinspace{}
\end_inset

Hz data set to use when calculating the heading correction.

\emph default
 These results change only slowly, as suggested in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 Because the application of the transformations, differentiations, and pitch
 corrections require considerable calculation, this results in considerably
 faster calculations.
 
\end_layout

\begin_layout Enumerate

\emph on
Apply the pitch and roll corrections using the algorithm developed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-pitch"

\end_inset

.
 
\emph default
The measurements of pitch and, to a lesser extent, roll affect the transformatio
n of the accelerations from the 
\begin_inset Formula $b$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame.
 Although the correction developed here depends only weakly on the correction
 to pitch and roll, inclusion of this step may protect against or at least
 identify anomalously large errors in pitch.
 Reciprocally, the pitch correction depends on the measured heading, but
 the effect of heading errors are insignificant.
 Omission of this step normally makes no detectable difference.
\end_layout

\begin_layout Enumerate

\emph on
Differentiate the ground-speed measurements provided by a GPS receiver,
\emph default
 using Savitzky-Golay polynomials, to obtain reference measurements of horizonta
l accelerations in the 
\begin_inset Formula $l$
\end_inset

-frame.
 The specific choice was to use third-order polynomials spanning 21
\begin_inset space \thinspace{}
\end_inset

s.
\end_layout

\begin_layout Enumerate

\emph on
Transform the accelerations measured by the INS in the 
\begin_inset Formula $b$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame.

\emph default
 Filter these results also using Savitzky-Golay polynomials of the same
 order and span so that they are smoothed in the same way as the ground-speed
 derivatives.
\end_layout

\begin_layout Enumerate

\emph on
Use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) to obtain estimates of the heading error 
\begin_inset Formula $\delta\psi$
\end_inset

 at each time.

\emph default
 However, apply data restrictions to avoid cases of high uncertainty.
 The most important restriction used here was to require that the total
 horizontal acceleration in the 
\begin_inset Formula $l$
\end_inset

-frame be larger than 
\begin_inset Formula $1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\emph on
Use a search algorithm to identify flight segments with turns
\emph default
 (specifically, magnitude of roll larger than 10
\begin_inset Formula $^{\circ}$
\end_inset

) continuously except for possible gaps of 5
\begin_inset space \thinspace{}
\end_inset

min.
 Require that these flight segments have both right and left turns, with
 at least 45
\begin_inset space \thinspace{}
\end_inset

s of each.
\end_layout

\begin_layout Enumerate

\emph on
For each such segment, calculate the mean correction
\emph default
 and its standard deviation and the mean time for each turn direction.
\end_layout

\begin_layout Enumerate

\emph on
Use cubic spline interpolation
\emph default
 to represent the variation in heading correction over the course of the
 flight.
 Two possible choices are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

; of these, the smoother choice is incorporated into the algorithm.
\end_layout

\begin_layout Enumerate

\emph on
Subtract the result given by the interopolation from the measured heading.
\end_layout

\begin_layout Plain Layout
The archives accompanying this note include specific algorithms for each
 step and a complete program constructing this text as well as performing
 the data-analysis steps.
 In particular, there are functions for the pitch correction and heading
 correction, for time-shifting, and for transformations between reference
 frames.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section
Comparison to an IRS with a Kalman filter
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<prelim>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(xts)
\end_layout

\begin_layout Plain Layout

require(zoo)
\end_layout

\begin_layout Plain Layout

require(signal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

transferAttributes <- function (dsub, d) {
\end_layout

\begin_layout Plain Layout

  ds <- dsub
\end_layout

\begin_layout Plain Layout

  for (nm in names (ds)) {
\end_layout

\begin_layout Plain Layout

    if (nm %in% names(d)) {
\end_layout

\begin_layout Plain Layout

      var <- sprintf ("d$%s", nm)
\end_layout

\begin_layout Plain Layout

      A <- attributes (eval (parse (text=var)))
\end_layout

\begin_layout Plain Layout

      A$dim <- NULL
\end_layout

\begin_layout Plain Layout

      if (nm != "Time") {
\end_layout

\begin_layout Plain Layout

        A$class <- NULL
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      attributes (ds[,nm]) <- A
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(ds)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<read-applanix, echo=TRUE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData5 <- sprintf("%s5.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  ApplanixRF16 <- read.table ("/Data/DEEPWAVE/ApplanixRF16.txt", 
\end_layout

\begin_layout Plain Layout

                            header=TRUE, quote="
\backslash
"", stringsAsFactors=FALSE)
\end_layout

\begin_layout Plain Layout

  ## convert times to a POSIX-format time, for merging with standard netCDF:
\end_layout

\begin_layout Plain Layout

  ## (note 2014-07-04 is the flight date)
\end_layout

\begin_layout Plain Layout

  ApplanixRF16$Time <- as.POSIXct (ApplanixRF16$time_.UTC_seconds_of_day.,
\end_layout

\begin_layout Plain Layout

                                 origin="2014-07-04", tz="GMT")
\end_layout

\begin_layout Plain Layout

  NewNames <- names (ApplanixRF16)
\end_layout

\begin_layout Plain Layout

  ## reassign names as specified in file NewNames:
\end_layout

\begin_layout Plain Layout

  source ('NewNames')
\end_layout

\begin_layout Plain Layout

  NewNames <- c(NewNames, "Time")
\end_layout

\begin_layout Plain Layout

  names (ApplanixRF16) <- NewNames
\end_layout

\begin_layout Plain Layout

  save(ApplanixRF16, file=SaveRData5)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(SaveRData5)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<read-HRT-netCDF, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## read variables from netCDF file, including those needed for pitch correction:
\end_layout

\begin_layout Plain Layout

# Flight <- "rf16h"
\end_layout

\begin_layout Plain Layout

# # Data <- getNetCDF ("/scr/raf/Prod_Data/DEEPWAVE/HRT/DEEPWAVErf16hPC.nc",
\end_layout

\begin_layout Plain Layout

# Data <- getNetCDF ("/Data/DEEPWAVE/DEEPWAVErf16h.nc",
\end_layout

\begin_layout Plain Layout

#                    standardVariables(c("PITCH", "ROLL", "THDG", "GGVSPD",
\end_layout

\begin_layout Plain Layout

#                                        "VNS", "VEW", "GGVNS", "GGVEW",
 "LATC")))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Rate <- 1
\end_layout

\begin_layout Plain Layout

# if ("sps25" %in% names(attributes(Data)$Dimensions)) {Rate <- 25}
\end_layout

\begin_layout Plain Layout

# s <- -60
\end_layout

\begin_layout Plain Layout

# Data$VEW <- ShiftInTime (Data$VEW, Rate, s)
\end_layout

\begin_layout Plain Layout

# Data$VNS <- ShiftInTime (Data$VNS, Rate, s)
\end_layout

\begin_layout Plain Layout

# Data$THDG <- ShiftInTime (Data$THDG, Rate, s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# C <- CorrectPitch(Data)
\end_layout

\begin_layout Plain Layout

# Data$PITCHC <- Data$PITCH - C[,1] 
\end_layout

\begin_layout Plain Layout

# Data$ROLLC <- Data$ROLL - C[,2]
\end_layout

\begin_layout Plain Layout

Data <- DataSave
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names(attributes(Data)$Dimensions)) {Rate <- 25}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## if Rate > 10, need to interpolate/filter the 10-Hz Applanix measurements
 to get 25 Hz;
\end_layout

\begin_layout Plain Layout

## if Rate == 1, need to average the 10-Hz Applanix measurements
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReloadDave <- FALSE
\end_layout

\begin_layout Plain Layout

ReloadDave <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadDave) {
\end_layout

\begin_layout Plain Layout

  if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    L <- 2.5 * nrow (ApplanixRF16)
\end_layout

\begin_layout Plain Layout

    for (nm in names (ApplanixRF16)) {
\end_layout

\begin_layout Plain Layout

      if (nm == "Time") {next}    ## skip Time; will handle specially below
\end_layout

\begin_layout Plain Layout

      ## angle variables require vector averaging to avoid wrap-around problems
\end_layout

\begin_layout Plain Layout

      if (nm == "THDG_APPX" || nm == "WANDER_APPX" || nm == "HDG_APPX")
 {
\end_layout

\begin_layout Plain Layout

        sina <- sin (ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        cosa <- cos (ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        X1 <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=sina,
\end_layout

\begin_layout Plain Layout

                            method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        X2 <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=cosa,
\end_layout

\begin_layout Plain Layout

                             method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        ## apply small amount of filtering to linearly interpolated values
\end_layout

\begin_layout Plain Layout

        X1$y <- signal::filter (signal::sgolay(3,7), X1$y)
\end_layout

\begin_layout Plain Layout

        X2$y <- signal::filter (signal::sgolay(3,7), X2$y)
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- (atan2(X1$y, X2$y) * 180/pi + 360) %% 360
\end_layout

\begin_layout Plain Layout

      } else {    ## these are now not-angle variables
\end_layout

\begin_layout Plain Layout

        X <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=ApplanixRF16[,
 nm], 
\end_layout

\begin_layout Plain Layout

                           method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        X$y <- signal::filter (signal::sgolay (3,7), X$y)
\end_layout

\begin_layout Plain Layout

        ## add variables to data.frame
\end_layout

\begin_layout Plain Layout

        if (grepl("time", nm)) {
\end_layout

\begin_layout Plain Layout

          Dave <- data.frame(time_seconds_APPX=X$y)
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          Dave[, nm] <- X$y
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  } else {  ## this is branch for 1-Hz data
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ## construct 1-Hz data by averaging 10-Hz data    
\end_layout

\begin_layout Plain Layout

    ep <- endpoints(ApplanixRF16$Time, 'seconds')
\end_layout

\begin_layout Plain Layout

    tt <- as.integer(period.apply(ApplanixRF16$time_seconds_APPX, ep, mean))
\end_layout

\begin_layout Plain Layout

    Dave <- data.frame(time_seconds_APPX=tt)
\end_layout

\begin_layout Plain Layout

    for (nm in names(ApplanixRF16)) {
\end_layout

\begin_layout Plain Layout

      print(nm)
\end_layout

\begin_layout Plain Layout

      if (nm == "Time") {next}
\end_layout

\begin_layout Plain Layout

      ## deal specially with THDG_APPX to handle wrap-around
\end_layout

\begin_layout Plain Layout

      if (nm == "THDG_APPX" || nm == "WANDER_APPX" || nm == "HDG_APPX")
 {
\end_layout

\begin_layout Plain Layout

        ## note that this is the preferred way to average angles
\end_layout

\begin_layout Plain Layout

        sina <- sin(ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        cosa <- cos(ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        sinave <- period.apply(sina, ep, mean)
\end_layout

\begin_layout Plain Layout

        cosave <- period.apply(cosa, ep, mean)
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- (atan2(sinave, cosave)*180/pi + 360) %% 360
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        if (grepl("time_s", nm)) {next}  ## already dealt with time_s
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- period.apply(ApplanixRF16[,nm], ep, mean)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Dave$Time <- as.POSIXct(Dave$time_seconds_APPX, origin="2014-07-04", tz="GMT")
\end_layout

\begin_layout Plain Layout

  save(Dave, file="APPX.Rdata")
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(file='APPX.Rdata')
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<match-times, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## now set consistent time limits and dimensions in the two files
\end_layout

\begin_layout Plain Layout

  ## The netCDF file is a subset of the Applanix file, so truncate the latter
\end_layout

\begin_layout Plain Layout

SE <- getStartEnd(Data$Time)
\end_layout

\begin_layout Plain Layout

r <- setRange(Dave$Time, SE[1], SE[2])
\end_layout

\begin_layout Plain Layout

Dave <- Dave[r, ]
\end_layout

\begin_layout Plain Layout

## need work here: match times
\end_layout

\begin_layout Plain Layout

## make sure they match:
\end_layout

\begin_layout Plain Layout

DVE <- Dave
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(Data)) {
\end_layout

\begin_layout Plain Layout

  DVE[i,] <- NULL
\end_layout

\begin_layout Plain Layout

  j <- which (abs(Dave$Time-Data$Time[i]) < 0.02)
\end_layout

\begin_layout Plain Layout

  if (length(j) > 1) {printf (sprintf ("multiple matches i=%d j=%d %d",
 i, j[1], j[2]))}
\end_layout

\begin_layout Plain Layout

  if (j == NA || j == 0) {print (sprintf ("no match for i=%d", i))}
\end_layout

\begin_layout Plain Layout

  DVE[i,] <- DAVE[j,]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DAVE <- DVE
\end_layout

\begin_layout Plain Layout

DS <- Data
\end_layout

\begin_layout Plain Layout

Data <- Data[1:nrow(Dave),]
\end_layout

\begin_layout Plain Layout

Data <- transferAttributes(Data, DS)
\end_layout

\begin_layout Plain Layout

Dave$Time <- NULL    ## this is a duplicate
\end_layout

\begin_layout Plain Layout

Dave <- cbind(Data, Dave)  ## merge the two data.files
\end_layout

\begin_layout Plain Layout

attributes(Dave) <- attributes(Data)
\end_layout

\begin_layout Plain Layout

NewNames <- NewNames[-which(NewNames == 'Time')]  ## eliminate Time for
 NewNames
\end_layout

\begin_layout Plain Layout

names (Dave) <- c(names (Data), NewNames)
\end_layout

\begin_layout Plain Layout

Dave <- transferAttributes (Dave, DS)             ## DS is saved 'Data'
\end_layout

\begin_layout Plain Layout

Dave$DTHDG <- Dave$THDG-Dave$THDG_APPX
\end_layout

\begin_layout Plain Layout

Dave$DTHDG[Dave$DTHDG > 180] <- Dave$DTHDG[Dave$DTHDG > 180] - 360
\end_layout

\begin_layout Plain Layout

Dave$DTHDG[Dave$DTHDG < -180] <- Dave$DTHDG[Dave$DTHDG < -180] + 360
\end_layout

\begin_layout Plain Layout

Dave$DPITCH <- Dave$PITCH-Dave$PITCH_APPX
\end_layout

\begin_layout Plain Layout

Dave$DPITCHC <- Dave$PITCHC-Dave$PITCH_APPX
\end_layout

\begin_layout Plain Layout

Dave$DROLL <- Dave$ROLL - Dave$ROLL_APPX
\end_layout

\begin_layout Plain Layout

Dave$DROLLC <- Dave$ROLLC-Dave$ROLL_APPX
\end_layout

\begin_layout Plain Layout

SE <- getStartEnd(Dave$Time)
\end_layout

\begin_layout Plain Layout

r <- setRange(Dave$Time, SE[1], SE[2])
\end_layout

\begin_layout Plain Layout

DT <- Dave[r, ]
\end_layout

\begin_layout Plain Layout

q <- (abs(DT$ROLL) > 5) | (DT$TASX < 130)
\end_layout

\begin_layout Plain Layout

DT$DROLL[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DPITCH[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DTHDG[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DPITCHC[q] <- NA
\end_layout

\begin_layout Plain Layout

mP <- mean(DT$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mPC <- mean(DT$PITCHC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mPA <- mean(DT$PITCH_APPX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DT$DP <- DT$DPITCH - mP + mPA
\end_layout

\begin_layout Plain Layout

DT$DPC <- DT$DPITCHC - mPC + mPA
\end_layout

\begin_layout Plain Layout

mR <- mean(DT$ROLL, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mRC <- mean(DT$ROLLC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mRA <- mean(DT$ROLL_APPX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DT$DR <- DT$DROLL - mR + mRA
\end_layout

\begin_layout Plain Layout

DT$DRC <- DT$DROLLC - mRC + mRA
\end_layout

\begin_layout Plain Layout

DT$PC <- DT$PITCHC - DT$PITCH
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Some properties of the corrections
\end_layout

\begin_layout Subsubsection
The pitch correction
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<typical-errors, include=TRUE, fig.height=4, fig.cap="Probability distribution
 of individual 1-Hz estimate of the pitch error as determined using the
 algorithm of Sect.2.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

Flight <- "rf16"
\end_layout

\begin_layout Plain Layout

DD <- getNetCDF (sprintf ("%s%s/%s%s.nc", DataDirectory(), Project, Project,
 Flight),
\end_layout

\begin_layout Plain Layout

                 c("PITCH", "ROLL", "THDG", "TASX", "VNS", "VEW", "GGVNS",
 "GGVEW",
\end_layout

\begin_layout Plain Layout

                   "LATC", "GGALT"))
\end_layout

\begin_layout Plain Layout

DD$PC <- CorrectPitch (DD)[,1]
\end_layout

\begin_layout Plain Layout

# hist(DD$PC, breaks=50, xlim=c(-0.05, 0.05), freq=FALSE, main=NULL)
\end_layout

\begin_layout Plain Layout

r <- (abs(DD$ROLL) < 5) & (DD$TASX > 130)
\end_layout

\begin_layout Plain Layout

ggplot (data=DD[r,], aes(x=PC)) +geom_density(fill='lightgrey')+xlim(-0.03,
 0.03)+xlab(expression(paste("estimated pitch error [", degree, "]")))+theme_WAC(
)
\end_layout

\begin_layout Plain Layout

meanPC <- mean(DD[r, "PC"], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

sdPC <- sd(DD[r, "PC"], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
As applied to most research flights, the corrections are fairly small.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:typical-errors}
\end_layout

\end_inset

 shows the density distribution of corrections calculated for one flight,
 filght 16 of the DEEPWAVE project.
 The standard deviation of the calculated corrections to pitch is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdPC, 2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, which would propagate to a standard error in measurements of vertical
 wind of about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdPC*Cradeg*220, 2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, and this is typical of most research flights examined including all but
 two of the 26 flights from the DEEPWAVE project.
 This is evidence that the measurement of pitch introduces little uncertainty
 into the measured vertical wind.
 Without this result, the instrument specification (0.05
\begin_inset Formula $^{\circ}$
\end_inset

) would be the estimated uncertainty in pitch, so the uncertainty in vertical
 wind is reduced significantly by this algorithm even if the correction
 is not applied.
 
\end_layout

\begin_layout Plain Layout
If the pitch correction reduces the error in pitch, wind measurements made
 before and after level course reversal would be expected to match better
 after correction because, if there is a pitch error, its contribution to
 the vertical wind would reverse sign between the two legs.
 The following is a tabulation of four instances where the flight track
 reversed course and remained at the same altitude.
 Some other candidates were excluded because conditions were too variable
 along the legs to produce a small-uncertainty estimate of the vertical
 wind, or because (as was the normal case in these research flights) the
 flight level changed.
 For these selected cases, the sample standard deviation for the vertical
 wind was typically about 0.3
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset


\begin_inset Formula $^{-1}$
\end_inset

, so in a 5-min leg with typical autocorrelation among measurements of about
 10
\begin_inset space ~
\end_inset

s the uncertainty in the comparison of two such means is estimated to be
 around 0.08
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 In each of the five cases, flight periods of about 5 min (sometimes adjusted
 in cases of strong wind to give similar-spatial-length segments flown upwind
 and downwind) are listed before and after the turn, but excluding the turn,
 to represent approximately overlapping flight segments where it would be
 expected that the vertical wind would be the same.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minipage}[t]{1
\backslash
columnwidth}%
\end_layout

\begin_layout Plain Layout


\backslash
hskip1in%
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c|c|c|}
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Flight} &
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Times before turn [m/s]} &
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Times after turn [m/s]}
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

2 &
\end_layout

\begin_layout Plain Layout

12:25:00--12:30:00 &
\end_layout

\begin_layout Plain Layout

12:37:00--12:43:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

10 &
\end_layout

\begin_layout Plain Layout

7:53:00--7:58:00 &
\end_layout

\begin_layout Plain Layout

8:05:00--8:10:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

19 &
\end_layout

\begin_layout Plain Layout

8:39:30--8:44:30 &
\end_layout

\begin_layout Plain Layout

8:51:30--8:56:30
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

21 &
\end_layout

\begin_layout Plain Layout

8:51:00--8:55:00 &
\end_layout

\begin_layout Plain Layout

9:03:00--9:07:30
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

% 21 &
\end_layout

\begin_layout Plain Layout

% 9:56:30--10:01:30 &
\end_layout

\begin_layout Plain Layout

% 10:08:00--10:13:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

% 
\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}%
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

% The average absolute value of the
\end_layout

\begin_layout Plain Layout

% difference before correction was smaller than 0.1
\backslash
,m/s, so the wind 
\end_layout

\begin_layout Plain Layout

% measurements were already in very good agreement for these pairs of legs
\end_layout

\begin_layout Plain Layout

% and not much improvement could be expected.
 
\end_layout

\begin_layout Plain Layout

% However, application of the
\end_layout

\begin_layout Plain Layout

% pitch-correction algorithm did reduce this average to about 36
\backslash
% of the
\end_layout

\begin_layout Plain Layout

% uncorrected value, as shown in Fig.
\backslash
 
\backslash
ref{fig:reverse-course-w-comparison}.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reverse-course-w-comparison, fig.height=3.5, fig.cap="Absolute difference
 in vertical wind for flight segments before and after level course-reversal
 maneuvers.
 The top panel shows the uncorrected measurements and the bottom panel shows
 the result of applying the pitch correction developed in Sect.
\backslash

\backslash
 2.", include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReverseW <- function (D, start1, end1, start2, end2) {
\end_layout

\begin_layout Plain Layout

  DD <- D[setRange (D$Time, start1, end1), ]
\end_layout

\begin_layout Plain Layout

  v1 <- mean (DD$WIC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  p1 <- mean (DD$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  DD <- D[setRange (D$Time, start2, end2), ]
\end_layout

\begin_layout Plain Layout

  v2 <- mean (DD$WIC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  p2 <- mean (DD$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  return (c(v1-v2, p1-p2))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

RC <- c(1,81000,81500,82500,83000,
\end_layout

\begin_layout Plain Layout

        2, 122500, 123000, 123700, 124300,
\end_layout

\begin_layout Plain Layout

        10, 75300, 75800, 80500, 81000,
\end_layout

\begin_layout Plain Layout

        10, 100400, 100800, 101600, 102100,
\end_layout

\begin_layout Plain Layout

        10, 104500, 105000, 105700, 110200,
\end_layout

\begin_layout Plain Layout

        14, 101300, 101800, 102400, 102900,
\end_layout

\begin_layout Plain Layout

        14, 113700, 114200, 114830, 115330,
\end_layout

\begin_layout Plain Layout

        16, 94000, 94500, 95400, 95900,
\end_layout

\begin_layout Plain Layout

        19, 83930, 84430, 85130, 85630,
\end_layout

\begin_layout Plain Layout

        21, 85100, 85500, 90300, 90730,
\end_layout

\begin_layout Plain Layout

#         21, 95400, 95900, 100900, 101400,
\end_layout

\begin_layout Plain Layout

        21, 95630, 100130, 100800, 101300,
\end_layout

\begin_layout Plain Layout

        21, 102900, 103400, 104700, 105230,
\end_layout

\begin_layout Plain Layout

        21, 114600, 115100, 120400, 121000)
\end_layout

\begin_layout Plain Layout

# many of the above (4,5,6,7,8,12,13) removed because there was altitude
 change
\end_layout

\begin_layout Plain Layout

# RC <- c(1,81000,81500,82500,83000,  ## for this, GGQUAL indicates problems
 and
\end_layout

\begin_layout Plain Layout

#                                     ## error signals vary rapidly here;
 exclude
\end_layout

\begin_layout Plain Layout

# 2, 122500, 123000, 123700, 124300,
\end_layout

\begin_layout Plain Layout

# 19, 83930, 84430, 85130, 85630,
\end_layout

\begin_layout Plain Layout

# 21, 85100, 85500, 90300, 90730,
\end_layout

\begin_layout Plain Layout

# 21, 95430, 95930, 101000, 101500)  ## WIC sdev high for this test? (ca
 0.3)
\end_layout

\begin_layout Plain Layout

dim(RC) <- c(5, length(RC)/5)
\end_layout

\begin_layout Plain Layout

wid <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

pid <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

widc <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

pidc <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

rr <- 1:dim(RC)[2]
\end_layout

\begin_layout Plain Layout

DDF <- data.frame()
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  for (j in rr) {
\end_layout

\begin_layout Plain Layout

    fnm <- sprintf ("%s%s/%srf%02d.nc", DataDirectory (), Project, Project,
 RC[1,j])
\end_layout

\begin_layout Plain Layout

    df <- getNetCDF (fnm, c("VNS", "VEW", "GGVNS", "GGVEW", "WIC", "TASX",
\end_layout

\begin_layout Plain Layout

                            "LATC", "GGALT", "THDG", "PITCH", "ROLL"))
\end_layout

\begin_layout Plain Layout

    Ts <- -80
\end_layout

\begin_layout Plain Layout

    if (j == 3 || j == 11) {Ts <- -800}
\end_layout

\begin_layout Plain Layout

    df$VNS <- ShiftInTime (df$VNS, 1, Ts)
\end_layout

\begin_layout Plain Layout

    df$VEW <- ShiftInTime (df$VEW, 1, Ts)
\end_layout

\begin_layout Plain Layout

    Ts <- -60
\end_layout

\begin_layout Plain Layout

    df$THDG <- ShiftInTime (df$THDG, 1, Ts)
\end_layout

\begin_layout Plain Layout

    PC <- CorrectPitch (df, .span=1013)
\end_layout

\begin_layout Plain Layout

    df$PITCHC <- df$PITCH - PC[,1]
\end_layout

\begin_layout Plain Layout

    df$WIX <- df$WIC + df$TASX * PC[,1] * pi / 180
\end_layout

\begin_layout Plain Layout

    df <- df[setRange(df$Time, RC[2,j], RC[5,j]), ]
\end_layout

\begin_layout Plain Layout

    df$RF <- rep (j, nrow(df))
\end_layout

\begin_layout Plain Layout

    DDF <- rbind (DDF, df)
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

  save (DDF, file="DataFrames/SchulerdfAll.Rdata")
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file="DataFrames/SchulerdfAll.Rdata")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (j in rr) {
\end_layout

\begin_layout Plain Layout

  df <- DDF[DDF$RF == j,]
\end_layout

\begin_layout Plain Layout

  if (j == 1) {next}     ## GPS problems here
\end_layout

\begin_layout Plain Layout

  if (sd (df$GGALT, na.rm=TRUE) > 200) {
\end_layout

\begin_layout Plain Layout

    rr[j] <- NA
\end_layout

\begin_layout Plain Layout

    next
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  x <- ReverseW (df, RC[2,j], RC[3,j], RC[4,j], RC[5,j])
\end_layout

\begin_layout Plain Layout

  wid[j] <- x[1]
\end_layout

\begin_layout Plain Layout

  pid[j] <- x[2]
\end_layout

\begin_layout Plain Layout

  df$PITCH <- df$PITCHC 
\end_layout

\begin_layout Plain Layout

  df$WIC <- df$WIX
\end_layout

\begin_layout Plain Layout

  x <- ReverseW (df, RC[2,j], RC[3,j], RC[4,j], RC[5,j])
\end_layout

\begin_layout Plain Layout

  widc[j] <- x[1]
\end_layout

\begin_layout Plain Layout

  pidc[j] <- x[2]
\end_layout

\begin_layout Plain Layout

  # print (sprintf ("set %d %.3f %.3f %.3f %.3f", j, wid[j], pid[j], widc[j],
 pidc[j]))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

rr[1] <- NA
\end_layout

\begin_layout Plain Layout

rr[11] <- NA
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5, 6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# op <- par (mfrow=c(2,1), mar=c(2,5,2,2)+0.1)
\end_layout

\begin_layout Plain Layout

hist (abs(wid[rr]), border='blue', col=rgb(0,0,100,30, maxColorValue=255),
 
\end_layout

\begin_layout Plain Layout

      breaks=20, angle=-45, xlim=c(0,0.2), 
\end_layout

\begin_layout Plain Layout

      xlab='absolute difference, uncorrected mean vertical wind [m/s]',
 main=NULL)
\end_layout

\begin_layout Plain Layout

legend('topright', legend='uncorrected', text.col='blue')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

hist (abs(widc[rr]), border='red', col=rgb(100,0,0,30,maxColorValue=255),lwd=3,
 
\end_layout

\begin_layout Plain Layout

      breaks=20, xlim=c(0,0.2), xlab='absolute difference, mean vertical
 wind [m/s]', main=NULL)
\end_layout

\begin_layout Plain Layout

legend('topright', legend="after correction", text.col='red')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# print (sprintf ("mean uncorrected %f, corrected %f", mean(abs(wid[rr]),
 na.rm=TRUE), mean(abs(widc[rr]), na.rm=TRUE)))
\end_layout

\begin_layout Plain Layout

# print (wid)
\end_layout

\begin_layout Plain Layout

# print (widc)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The difference between average vertical wind measurements for each pair
 of legs was calculated before and after applying the pitch-correction algorithm
 developed in this subsection.
 The results are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:reverse-course-w-comparison}
\end_layout

\end_inset

.
 The measurements were in good agreement without any pitch correction, with
 an average absolute value of the difference between opposing legs of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(abs(wid[rr]), na.rm=TRUE),2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, about comparable to the uncertainty estimate from natural variability
 as developed in the preceding paragraph.
 The pitch correction kept the averages quite small and improved the agreement,
 reducing the mean value of the difference to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(abs(widc[rr]), na.rm=TRUE), 2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This level of uncertainty would arise from an uncertainty in pitch of less
 than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, but the residual uncertainty may well be smaller than this because the
 mean difference in vertical wind may arise mostly from natural variability.
 
\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status open

\begin_layout Plain Layout
Estimated uncertainty in the corrected pitch
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
If the uncertainty in pitch is less than about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, it may be unnecessary to refine that estimate because at that level other
 effects dominate the uncertainty in vertical wind.
 However, some additional estimates can be obtained by considering the terms
 affecting the estimates (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

), dependent on how well the derivative of the errors in ground-speed components
 can be determined and how well this derivative can be transformed via (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) to the reference frame of the aircraft.
 Estimates based on this approach lead to exceptionally small uncertainty
 in the pitch correction, smaller than 0.0001
\begin_inset Formula $^{\circ}$
\end_inset

, so uncertainties arising from other sources are likely dominant.
 Most sources of error, however, are addressed by the correction algorithm.
 The basic measurements from the INS are the body accelerations and body
 rotations.
 An error in the integration of the body rotations leads to an error in
 pitch that produces a false component of horizontal acceleration, so this
 will appear as an erroneous contribution to the ground-speed components
 and will be detected by the proposed algorithm.
 If the measured accelerations are in error, this leads to a position error
 and so to a pitch error, but again the erroneous accelerations are detected
 by comparison to GPS measurements and lead to a correction.
 
\end_layout

\begin_layout Plain Layout
An error not addressed by the algorithm, however, is that arising from timing
 errors between INS and GPS.
 Especially in turns, a timing error will bias the measured errors in ground-spe
ed components and so bias the result.
 Therefore, if the samples are not synchronous they must be shifted to match.
 This can be done by minimizing the perturbations that occur in turns.
 However, even small timing differences can have serious effects on the
 correction algorithm.
 A timing delay of 10
\begin_inset space \thinspace{}
\end_inset

ms when turning at a rate of 2
\begin_inset Formula $^{\circ}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 can lead to errors in ground-speed components of 
\begin_inset Formula $0.02\pi V/180\simeq$
\end_inset

0.08
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 at a representative flight speed 
\begin_inset Formula $V$
\end_inset

 of 220
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This error changes direction at the turn rate so it leads to a false accelerati
on of about 
\begin_inset Formula $0.08\times2\pi/180\simeq0.003$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 Equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) then leads to an error in the pitch correction of about 0.015
\begin_inset Formula $^{\circ}$
\end_inset

.
 While this appears to be the dominant source of uncertainty in the pitch
 correction, it only occurs in turns and should not affect measurements
 during straight flight segments.
 
\end_layout

\begin_layout Plain Layout
It appears appropriate to use a conservative estimate of 
\begin_inset Formula $\ll0.01{}^{\circ}$
\end_inset

 as the uncertainty to be applied to pitch.
 At this level, for the NSF/NCAR GV, the Appendix illustrates that the uncertain
ty in vertical wind is determined primarily by uncertainty in the measurement
 of angle of attack, and the pitch uncertainty is of little significance.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
 Modern GPS receivers, especially if augmented by special signals or special
 processing, produce 1-Hz measurements with uncertainty of around 0.03
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

[ref] The consistency of the Schuler oscillation, as illustrated by the
 top panels in Figs.
\begin_inset space ~
\end_inset

1 and 2, suggest that derivatives in velocity can be determined by averaging
 over periods of at least 10 min or more, so if the ground-speed measurements
 from the INS have uncertainty of about 0.03
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (where variance spectra for the 1-Hz measurements begin to show noise),
 the uncertainty in differences between these two signals might be expected
 to be 
\begin_inset Formula $0.03\,\sqrt{2}\approx0.04$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, and averaged over 10
\begin_inset space ~
\end_inset

min or perhaps 60 autocorrelation times the resulting difference could be
 resolved to 
\begin_inset Formula $0.04/\sqrt{60}\approx0.005$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Over intervals separated by 10
\begin_inset space \thinspace{}
\end_inset

min, the derivative then might be determined to 
\begin_inset Formula $0.005\times1/600\approx10^{-5}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

, leading to an uncertainty in the pitch correction from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) of about 10
\begin_inset Formula $^{-6}$
\end_inset

 or 0.00005
\begin_inset Formula $^{\circ}$
\end_inset

.
 S-G polynomials reduce noise in an average by a factor of 
\begin_inset Formula $\sqrt{(3(3m^{2}-7)/4m(m^{2}-4)}\simeq0.05$
\end_inset

 for m=1013 or 
\begin_inset Formula $0.06$
\end_inset

 for m=601.
 
\begin_inset Formula $0.04*0.06=0.0024$
\end_inset

m/s, 600-s separation gives acceleration uncertainty of about 
\begin_inset Formula $0.0024/600=4e-6$
\end_inset

 or pitch uncertainty of 2e-5
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The heading correction
\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status open

\begin_layout Plain Layout
Typical magnitudes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The examples from DEEPWAVE flights 15 and 16, discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Examples-roll"

\end_inset

, provide an illustration of the representative magnitude of the correction
 applied to heading.
 Unlike pitch, the heading correction does not vary with the Schuler oscillation
 but remains almost constant for most flights, with typical values of about
 
\begin_inset Formula $-0.08$
\end_inset

 and
\begin_inset Formula $-0.06$
\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 for flights 15 and 16, respectively, and standard deviations in these estimates
 of about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
\begin_inset Note Note
status open

\begin_layout Plain Layout
A check based on circle maneuvers
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The circle maneuvers flown during flight 15 has been examined and discussed
 in some detail in [REF XXX].
 These provide an alternate and independent way of estimating the heading
 error, because if the wind remains steady over the course of the circle
 then a positive heading error will lead to an erroneous eastward component
 of the wind while flying northward and a similar negative component when
 flying southward.
 A similar effect is present in the measured northward component of the
 wind.
 It is therefore possible to estimate the heading error by fitting a sinusoidal
 variation to the wind speed or to components of the wind speed.
 The result of that analysis was an indicated heading error of 0.09
\begin_inset Formula $^{\circ}$
\end_inset

, consistent with the error found here, although with a significantly larger
 uncertainty of 0.09
\begin_inset Formula $^{\circ}$
\end_inset

 arising from variations among the three circle maneuvers analyzed.
 This variation likely arose from unsteady wind conditions around the circles,
 but the result is consistent with the heading error found here for flight
 15.
\end_layout

\begin_layout Subsection
Summary of the simplified correction algorithms
\end_layout

\begin_layout Plain Layout
An algorithm for correcting measurements of all three attitude angles (roll,
 pitch, and heading) apparently leads to significant improvement in conventional
 measurements from a high-quality inertial navigation system (INS) that
 does not use Kalman-filter updates to improve the measurements.
 The corrections are based on fits to centered portions of the flight and
 so can have advantages over recursive single-directional Kalman filters,
 and they do not require detailed knowledge of the error characteristics
 of the INS.
 In the case of pitch and roll, the procedure used neglects possible acceleromet
er biases by assuming that the velocity errors (determined by comparison
 to GPS-derived values) and attitude-angle errors are coupled via the Schuler
 oscillation.
 In the case of heading, the measured accelerations are transformed to an
 Earth-reference frame and compared to GPS measurements of acceleration,
 so this also neglects possible biases in the accelerometers.
 It is also necessary that the measurements from the INS and the GPS receiver
 be coincident in time or be shifted to coincide, preferably to a tolerance
 of around 20 ms.
 With these assumptions, corrections to pitch and roll result in residual
 uncertainties of less than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, and similar corrections to heading have uncertainty of about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 if there are periodic turns (at about 45-min intervals) that give the accelerat
ions required for this estimate.
\end_layout

\begin_layout Plain Layout
The algorithms are documented and available in supplementary material included
 with this paper.
 Those algorithms can be applied to past measurements as well as future
 projects to improve the measurements of wind.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## returns transformation matrix, a-frame to l-frame
\end_layout

\begin_layout Plain Layout

XfLArV <- function (data) {   ## XfLA but using input in radians and single
 row
\end_layout

\begin_layout Plain Layout

  # data must contain PITCH, ROLL, HEADING as components [7:9]
\end_layout

\begin_layout Plain Layout

  cosphi <- cos (data[8])
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (data[8])
\end_layout

\begin_layout Plain Layout

  costheta <- cos (data[7])
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (data[7])
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (data[9])
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (data[9])
\end_layout

\begin_layout Plain Layout

  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-
sinpsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinph
i-cospsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           -sintheta, costheta*sinphi, -costheta*cosphi)
\end_layout

\begin_layout Plain Layout

  RblM <- aperm( array (Rbl, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  return (RblM)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XPitch <- function (pitch, roll, heading, .inverse=FALSE) {  # a-frame to
 l-frame
\end_layout

\begin_layout Plain Layout

  ## note: all in units of radians
\end_layout

\begin_layout Plain Layout

  if (!.inverse) {
\end_layout

\begin_layout Plain Layout

    pitchL <- -asin(-cos (heading) * sin (pitch) * cos (roll) - sin (heading)
 * sin (roll))
\end_layout

\begin_layout Plain Layout

    rollL  <-  asin(-sin (heading) * sin (pitch) * cos (roll) + cos (heading)
 * sin (roll))
\end_layout

\begin_layout Plain Layout

    A <- c(pitchL, rollL)
\end_layout

\begin_layout Plain Layout

    dim(A) <- c(length(pitch),2)
\end_layout

\begin_layout Plain Layout

    return (A)
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    lx <- sin (roll)
\end_layout

\begin_layout Plain Layout

    ly <- -sin (pitch)
\end_layout

\begin_layout Plain Layout

    lz <- -sqrt (1 - lx^2 - ly^2)
\end_layout

\begin_layout Plain Layout

    pitchA <- atan2 (lx * sin (heading) + ly * cos (heading), lz)
\end_layout

\begin_layout Plain Layout

    pitchA[pitchA < -pi/2] <- pitchA[pitchA < -pi/2] + pi
\end_layout

\begin_layout Plain Layout

    pitchA[pitchA >  pi/2] <- pitchA[pitchA >  pi/2] - pi
\end_layout

\begin_layout Plain Layout

    # rollA <- acos (lz / cos (pitchA))
\end_layout

\begin_layout Plain Layout

    rollA <- atan ((-cos(heading)*lx+sin(heading)*ly) /
\end_layout

\begin_layout Plain Layout

                    (sin(heading) * sin(pitchA)*lx+cos(heading)*sin(pitchA)*ly+c
os(pitchA)*lz))
\end_layout

\begin_layout Plain Layout

    # rollA[rollA > pi/2] <- pi - rollA[rollA > pi/2] 
\end_layout

\begin_layout Plain Layout

    A <- c(pitchA, rollA)
\end_layout

\begin_layout Plain Layout

    dim(A) <- c(length(pitch), 2)
\end_layout

\begin_layout Plain Layout

    return (A)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XPitchAL <- function (pitch, roll, heading, dpitch, droll, .inverse=FALSE)
 {
\end_layout

\begin_layout Plain Layout

  ## all units must be radians
\end_layout

\begin_layout Plain Layout

  cp <- cos(pitch); cr <- cos(roll); ch <- cos(heading)
\end_layout

\begin_layout Plain Layout

  sp <- sin(pitch); sr <- sin(roll); sh <- sin(heading)
\end_layout

\begin_layout Plain Layout

  if (!.inverse) { # default is l-frame to a-frame
\end_layout

\begin_layout Plain Layout

    dpitchA <- ch*cp * dpitch - sh*cp * droll
\end_layout

\begin_layout Plain Layout

    drollA  <- -(ch*sp*sr-sh*cr) * dpitch + (sh*sp*sr+ch*cr) * droll
\end_layout

\begin_layout Plain Layout

    A <- c(dpitchA, drollA)
\end_layout

\begin_layout Plain Layout

  } else {  # a-frame to l-frame
\end_layout

\begin_layout Plain Layout

    D <- cp*cr
\end_layout

\begin_layout Plain Layout

    dpitchL <- ((sh*sp*sr+ch*cr) * dpitch + sh*cp * droll) / D
\end_layout

\begin_layout Plain Layout

    drollL  <- ((ch*sp*sr-sh*cr) * dpitch + ch*cp * droll) / D
\end_layout

\begin_layout Plain Layout

    A <- c(dpitchL, drollL)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dim(A) <- c(length(pitch), 2)
\end_layout

\begin_layout Plain Layout

  return (A)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# other-functions ---------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

dt <- 1/25               ## working with 25-Hz file
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

Ree <- 6378137
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

## The next correction calculates the correction needed to account for the
 rotation
\end_layout

\begin_layout Plain Layout

## of the Earth and of the l-frame (ENU frame).
 See Noureldin et al., 2013, 
\end_layout

\begin_layout Plain Layout

## Eqs.
 5.55--5.57.
 Subtract this from the transformed accelerations before using them.
\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  Ree <- 6378137
\end_layout

\begin_layout Plain Layout

  Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
\end_layout

\begin_layout Plain Layout

  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Gravity <- function (latitude, altitude=0.) {
\end_layout

\begin_layout Plain Layout

  sl2 <- (sin (latitude * pi / 180))^2
\end_layout

\begin_layout Plain Layout

  g <- 9.780327 * ((1.
 + 0.001931851 * sl2) / 
\end_layout

\begin_layout Plain Layout

                     (1.
 - 0.006694380 * sl2)) - 3.086e-6 * altitude
\end_layout

\begin_layout Plain Layout

  ## Somigliana formula 1980 GRS:
\end_layout

\begin_layout Plain Layout

  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
\end_layout

\begin_layout Plain Layout

  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 *
 altitude^2
\end_layout

\begin_layout Plain Layout

  return(g)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SummarizeFit <- function(ft) {
\end_layout

\begin_layout Plain Layout

  print (summary(ft)$call)
\end_layout

\begin_layout Plain Layout

  print ("Coefficients:")
\end_layout

\begin_layout Plain Layout

  print (summary(ft)$coefficients)
\end_layout

\begin_layout Plain Layout

  print (sprintf ("Residual standard deviation: %.3f, dof=%d", summary(ft)$sigma,
 summary(ft)$df[2]))
\end_layout

\begin_layout Plain Layout

  print (sprintf ("R-squared %.3f", summary(ft)$r.squared))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

LFrame <- TRUE
\end_layout

\begin_layout Plain Layout

STMFV <- function (sv, dbg=FALSE) { 
\end_layout

\begin_layout Plain Layout

  stmf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  ## transform pitch and roll back to a-frame
\end_layout

\begin_layout Plain Layout

  if (LFrame) {
\end_layout

\begin_layout Plain Layout

    x <- XPitch (sv[7], sv[8], sv[9], .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

    sv[7] <- x[1]
\end_layout

\begin_layout Plain Layout

    sv[8] <- x[2]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  rlm <- XfLArV(sv)     ## rotation matrix, a-frame to l-frame 
\end_layout

\begin_layout Plain Layout

  if (dbg) {
\end_layout

\begin_layout Plain Layout

    print (sprintf ('sv[7-9]=%f %f %f', sv[7],sv[8],sv[9]))
\end_layout

\begin_layout Plain Layout

    print (rlm)
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/Rn,
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
\end_layout

\begin_layout Plain Layout

  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2],
 omega[1], 0), ncol=3)
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  ## find the derivative of the transformation matrix:
\end_layout

\begin_layout Plain Layout

  ## (must recalculate SRM from measured rotation rates)
\end_layout

\begin_layout Plain Layout

  SRR <- c(0, -sv[12], -sv[10],
\end_layout

\begin_layout Plain Layout

           sv[12], 0, sv[11],
\end_layout

\begin_layout Plain Layout

           sv[10], -sv[11], 0)
\end_layout

\begin_layout Plain Layout

  SRM <- aperm( array (SRR, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  dRLA <- rlm %*% SRM - Oilb
\end_layout

\begin_layout Plain Layout

  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
\end_layout

\begin_layout Plain Layout

  # G <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    
\end_layout

\begin_layout Plain Layout

  Grav <- Gravity (sv[1]/Cradeg, sv[3])
\end_layout

\begin_layout Plain Layout

  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-fra
me
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
\end_layout

\begin_layout Plain Layout

  ## now correct for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  VL <- c(sv[4], sv[5], sv[6])
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3)
\end_layout

\begin_layout Plain Layout

  lat <- sv[1]
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  C[1] <- M12 * VL[2] + M13 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[2] <- M21 * VL[1] + M23 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[3] <- M31 * VL[1] + M32 * VL[2]
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (AL - C, mode='numeric')
\end_layout

\begin_layout Plain Layout

  AL[3] <- AL[3] + Grav
\end_layout

\begin_layout Plain Layout

  AL[3] <- -AL[3]
\end_layout

\begin_layout Plain Layout

  ## note re derivatives of attitude angles:
\end_layout

\begin_layout Plain Layout

  ##   in terms of transformation matrix, sin(pitch)=-rlm[3,1],
\end_layout

\begin_layout Plain Layout

  ##   tan(roll)=-rlm[3,2]/rlm[3,3], tan(thdg)=rlm[1,1]/rlm[1,2]
\end_layout

\begin_layout Plain Layout

  ##   get derivatives from d(arcsin(x))/dx=1/sqrt(1-x^2), d(arctan(x))/dx=1/(1+
x^2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
\end_layout

\begin_layout Plain Layout

              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
\end_layout

\begin_layout Plain Layout

              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
\end_layout

\begin_layout Plain Layout

            0, 0, 0, 0, 0, 0)
\end_layout

\begin_layout Plain Layout

  ## transform angle derivatives back to l-frame
\end_layout

\begin_layout Plain Layout

  if (LFrame) {
\end_layout

\begin_layout Plain Layout

    x <- XPitch (sv[7]+stmf[7], sv[8]+stmf[8], sv[9]+stmf[9]) -
\end_layout

\begin_layout Plain Layout

         XPitch (sv[7], sv[8], sv[9])
\end_layout

\begin_layout Plain Layout

    stmf[7] <- x[1]
\end_layout

\begin_layout Plain Layout

    stmf[8] <- x[2]
\end_layout

\begin_layout Plain Layout

    # x <- rlm %*% as.matrix (c(stmf[8], -stmf[7], 0))
\end_layout

\begin_layout Plain Layout

    # stmf7 <- stmf[7]
\end_layout

\begin_layout Plain Layout

    # stmf8 <- stmf[8]
\end_layout

\begin_layout Plain Layout

    # stmf[7] <- cos(sv[9])*cos(sv[7])*cos(sv[8]) * stmf7 + 
\end_layout

\begin_layout Plain Layout

    #   (-cos(sv[9])*sin(sv[7])*sin(sv[8]) + cos(sv[9])*cos(sv[8])) *  stmf8
\end_layout

\begin_layout Plain Layout

    # stmf[8] <- (cos(sv[9])*cos(sv[7]) - sin(sv[9])*cos(sv[7])*cos(sv[8]))
 * stmf7 +
\end_layout

\begin_layout Plain Layout

    #   sin(sv[9])*sin(sv[7])*sin(sv[8]) * stmf8
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (as.vector (stmf, mode='numeric'))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT', 'PALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG', 'PS_A')
\end_layout

\begin_layout Plain Layout

SaveRData3 <- sprintf("%s3.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  ## replace PALT by corresponding value from FS_A, to match INS baro loop
\end_layout

\begin_layout Plain Layout

  Data$PALT <- PressureAltitude (Data$PS_A)
\end_layout

\begin_layout Plain Layout

  Data$Grav <- Gravity (Data$LAT, Data$PALT)
\end_layout

\begin_layout Plain Layout

  Data$BLATA <- zoo::na.approx (Data$BLATA)
\end_layout

\begin_layout Plain Layout

  Data$BLONGA <- zoo::na.approx (Data$BLONGA)
\end_layout

\begin_layout Plain Layout

  Data$BNORMA <- zoo::na.approx (Data$BNORMA)
\end_layout

\begin_layout Plain Layout

  Data$BPITCHR <- zoo::na.approx (Data$BPITCHR)
\end_layout

\begin_layout Plain Layout

  Data$BROLLR <- zoo::na.approx (Data$BROLLR)
\end_layout

\begin_layout Plain Layout

  Data$BYAWR <- zoo::na.approx (Data$BYAWR)
\end_layout

\begin_layout Plain Layout

  ## remove the time lags
\end_layout

\begin_layout Plain Layout

  Data$PITCH <- ShiftInTime (Data$PITCH, .rate=25, .shift=60)
\end_layout

\begin_layout Plain Layout

  Data$ROLL <- ShiftInTime (Data$ROLL, .rate=25, .shift=60)
\end_layout

\begin_layout Plain Layout

  Data$THDG <- ShiftInTime (Data$THDG, .rate=25, .shift=35)
\end_layout

\begin_layout Plain Layout

  Data$VEW <- ShiftInTime (Data$VEW, .rate=25, .shift=80)
\end_layout

\begin_layout Plain Layout

  Data$VNS <- ShiftInTime (Data$VNS, .rate=25, .shift=80)
\end_layout

\begin_layout Plain Layout

  Data$VSPD <- ShiftInTime (Data$VSPD, .rate=25, .shift=60)
\end_layout

\begin_layout Plain Layout

  ## better without shifts in gyro rates
\end_layout

\begin_layout Plain Layout

  # Data$BYAWR <- ShiftInTime (Data$BYAWR, .rate=25, .shift=-30)
\end_layout

\begin_layout Plain Layout

  ## guard against bad values at wrap-around points, caused by ShiftInTime:
\end_layout

\begin_layout Plain Layout

  for (i in 2:(nrow(Data)-1)) {
\end_layout

\begin_layout Plain Layout

    if ((Data$THDG[i]-Data$THDG[i-1] > 30) && (Data$THDG[i+1]-Data$THDG[i]
 > 30)) {
\end_layout

\begin_layout Plain Layout

      # print (sprintf ("case 1, i=%d", i))
\end_layout

\begin_layout Plain Layout

      Data$THDG[i] <- Data$THDG[i+1]+Data$THDG[i-1]+360
\end_layout

\begin_layout Plain Layout

      if (Data$THDG[i] > 360) {Data$THDG[i] <- Data$THDG[i]-360}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if ((Data$THDG[i]-Data$THDG[i-1] < -30) && (Data$THDG[i+1]-Data$THDG[i]
 < -30)) {
\end_layout

\begin_layout Plain Layout

      # print (sprintf ("case 2, i=%d", i))
\end_layout

\begin_layout Plain Layout

      Data$THDG[i] <- Data$THDG[i+1]+Data$THDG[i-1]-360
\end_layout

\begin_layout Plain Layout

      if (Data$THDG[i] < 0) {Data$THDG[i] <- Data$THDG[i]+360}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData3)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, PALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR - 0.005  ## these adjustments avoid accumulation of
 offset in circles
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR + 0.0002
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

SP$BNORMA <- SP$BNORMA*0.9873 + 0.0104  ## see below for calibrations
\end_layout

\begin_layout Plain Layout

SP$BLONGA <- SP$BLONGA * 0.9810 + 0.0047
\end_layout

\begin_layout Plain Layout

# SP$BLATA <- SP$BLATA * 0.82099 - 0.005538  ## poorly costrained; omit
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) 
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mechanization
\end_layout

\begin_layout Subsection
General description
\end_layout

\begin_layout Standard
Although the implemented filter described in the next section will be an
 error-state Kalman filter, a necessary first step is to develop and verify
 a mechanization that duplicates the function of the INS by providing the
 history of the nine variables describing the position, velocity, and attitude
 angles of the aircraft.
 From an initial state, this mechanization uses only the IRU-provided measuremen
ts of acceleration and rotation rate in the reference frame of the aircraft.
 [See the code 
\begin_inset Quotes eld
\end_inset

chunk
\begin_inset Quotes erd
\end_inset

 labeled 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 for details.] The nine variables are specified by an aircraft-state vector
 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 that includes the aircraft variables in the local-level reference frame,
 also referred to as the 
\begin_inset Quotes eld
\end_inset

ENU
\begin_inset Quotes erd
\end_inset

 (for east, north, up) or
\emph on
 l-
\emph default
frame.
 That aircraft-state vector is propagated forward step-wise in time from
 time-step 
\begin_inset Formula $k-1$
\end_inset

 to step 
\begin_inset Formula $k$
\end_inset

 by a transformation matrix 
\begin_inset Formula $\boldsymbol{T}_{k|k-1}$
\end_inset

 consisting of the sum of the identity matrix and the product of a derivative
 matrix and a time step.
 The derivative matrix specifies the (linearized) change in each component
 of 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 as a function of each other component of 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 and the measurements of vector acceleration and vector rotation rate provided
 by the IRU.
 Repeated application of this transformation matrix then provides the history
 of the aircraft-state vector.
 The purpose of this section is to document this mechanization and demonstrate
 that it replicates, at least within reasonable error limites, the mechanization
 provided by the INS.
 This is a necessary step toward implementation of a Kalman filter, which
 would use the transformation matrix, or an error-state Kalman filter, for
 which the corresponding transformation matrix for the error state is the
 Jacobian of 
\begin_inset Formula $\boldsymbol{T}_{k|k-1}$
\end_inset

.
\end_layout

\begin_layout Standard
The data file used for this demonstration is a special data file resulting
 from processing DEEPWAVE flight 15 at high rate (25
\begin_inset space ~
\end_inset

Hz) and saving the resulting netCDF file as DWIRUrf15HR.nc.
 This file is archived along with the other files used to generate this
 document, as described in a table appended to the end of this report.
 To reproduce this document, that special data file will be needed, but
 the goal of this report is to ensure reproducibility by preserving the
 specific data file and program used to generate the report, as described
 in that appendix.
\end_layout

\begin_layout Standard
The procedure used for this test of the mechanization equations is as follows:
\end_layout

\begin_layout Enumerate
Initialize a special state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

, used only for these tests, having these components:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the 
\emph on
l-
\emph default
frame;
\end_layout

\begin_layout Enumerate
east velocity, north velocity, upward velocity in the 
\emph on
l-
\emph default
frame;
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the 
\emph on
a
\emph default
-frame;
\end_layout

\begin_layout Enumerate
rotation rates about the pitch, roll, and yaw axes of the aircraft;
\end_layout

\begin_layout Enumerate
acceleration in the lateral, longitudinal, and normal direction relative
 to the a-frame.
\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Store the measured rotations and accelerations in the last 6 components
 of the state vector.
\end_layout

\begin_layout Enumerate
Via the function STMFV, calculate the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the 
\emph on
a
\emph default
-frame to the 
\emph on
l-
\emph default
frame and then using the definition of components of that matrix to find
 the derivative of the attitude angles.
\end_layout

\begin_layout Enumerate
Use that derivative vector to increment the state vector.
\end_layout

\begin_layout Enumerate
Compensate for possible wrap-around of the heading at 0 and 360
\begin_inset Formula $^{\circ}$
\end_inset

 so that values stay within that range.
\end_layout

\begin_layout Enumerate
Save the first 9 components of the state vector in a new R data.frame that
 represents an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the solution
 provided by the standard INS.
\end_layout

\end_deeper
\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

workflow
\begin_inset Quotes erd
\end_inset

 document, referenced and made available as described in the appendix, provides
 some additional details, and the R code is included in the primary reference
 document 
\begin_inset Quotes eld
\end_inset

KalmanFilter.Rnw.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
Tests of the mechanization
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, PALT, VEW, VNS, VSPD, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$PALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

## convert pitch/roll of SV to l-frame components:
\end_layout

\begin_layout Plain Layout

if (LFrame) {  ## initialize state vector in l-frame 
\end_layout

\begin_layout Plain Layout

  x <- XPitch (SV$PITCH, SV$ROLL, SV$THDG)
\end_layout

\begin_layout Plain Layout

  SV$PITCH <- x[1]
\end_layout

\begin_layout Plain Layout

  SV$ROLL  <- x[2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

Rn <- SP$Rn[1] + sv[3]
\end_layout

\begin_layout Plain Layout

Rm <- SP$Rm[1] + sv[3]
\end_layout

\begin_layout Plain Layout

Grav <- SP$Grav[1]
\end_layout

\begin_layout Plain Layout

stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

## feedback coefficients for baro loop:
\end_layout

\begin_layout Plain Layout

lambda <- 0.075
\end_layout

\begin_layout Plain Layout

C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
\end_layout

\begin_layout Plain Layout

C0 <- 3*lambda; C1 <- 4*lambda^2; C2 <- 2*lambda^3
\end_layout

\begin_layout Plain Layout

wp3F <- 0;
\end_layout

\begin_layout Plain Layout

hxF <- hxxF <- 0
\end_layout

\begin_layout Plain Layout

hi3F <- SP$PALT[1]
\end_layout

\begin_layout Plain Layout

RK <- TRUE    ## use Runge-Kutta integration if true
\end_layout

\begin_layout Plain Layout

RK <- FALSE
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (i in 2:nrow(SP)) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i] + sv[3]  ## using height from last step...
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i] + sv[3]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i]
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i]
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i]
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  if (RK) {
\end_layout

\begin_layout Plain Layout

    stmf1 <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

    sv1 <- sv + stmf1 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf2 <- STMFV (sv1)
\end_layout

\begin_layout Plain Layout

    sv2 <- sv + stmf2 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf3 <- STMFV (sv2)
\end_layout

\begin_layout Plain Layout

    sv3 <- sv + stmf3 * dt
\end_layout

\begin_layout Plain Layout

    stmf4 <- STMFV (sv3)
\end_layout

\begin_layout Plain Layout

    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    if (i == 12001) {
\end_layout

\begin_layout Plain Layout

      dbg <- TRUE
\end_layout

\begin_layout Plain Layout

      print (sv)
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      dbg <- FALSE
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    stmf <- STMFV (sv, dbg)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (!is.na(sv[9])) {
\end_layout

\begin_layout Plain Layout

    if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

    if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ## baro-loop
\end_layout

\begin_layout Plain Layout

  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
\end_layout

\begin_layout Plain Layout

  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
\end_layout

\begin_layout Plain Layout

  hxF <- hi3F - SP$PALT[i]
\end_layout

\begin_layout Plain Layout

  hxxF <- hxxF + hxF * dt
\end_layout

\begin_layout Plain Layout

  sv[6] <- 0.5 * (sv[6] + wp3F)
\end_layout

\begin_layout Plain Layout

  sv[3] <- hi3F
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

## convert pitch/roll to a-frame components:
\end_layout

\begin_layout Plain Layout

if (LFrame) {
\end_layout

\begin_layout Plain Layout

  x <- XPitch (SP$PITCH, SP$ROLL, SP$THDG, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

  SP$PITCH <- x[,1]
\end_layout

\begin_layout Plain Layout

  SP$ROLL <- x[,2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<plot-mech, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap='Comparison
 of INS-provided attitude angles (PITCH, ROLL and THDG shown as dashed blue
 lines) and integration-derived attitude angles (PITCHX, ROLLX and THDGX
 shown as solid dark-green lines).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- Data$ROLLX-Data$ROLL
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- Data$THDGX-Data$THDG
\end_layout

\begin_layout Plain Layout

Data$DTHDG[Data$DTHDG > 180] <- Data$DTHDG[Data$DTHDG > 180] - 360
\end_layout

\begin_layout Plain Layout

Data$DTHDG[Data$DTHDG < -180] <- Data$DTHDG[Data$DTHDG < -180] + 360
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 33000, 35500)
\end_layout

\begin_layout Plain Layout

DL <- r[length(r)]
\end_layout

\begin_layout Plain Layout

Data <- Data[r, ]
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'PITCH', 'PITCHX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

         ylab=expression (paste ('PITCH [',degree,']')), legend.position='toprigh
t')
\end_layout

\begin_layout Plain Layout

sdPitch <- sd (Data$DPITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

plotWAC(Data[, c('Time', 'ROLL', 'ROLLX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

        ylab=expression (paste ('ROLL [',degree,']')), legend.position='bottomrig
ht')
\end_layout

\begin_layout Plain Layout

sdRoll <- sd(Data$DROLL, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC(Data[, c('Time', 'THDG', 'THDGX')],
\end_layout

\begin_layout Plain Layout

        ylab=expression (paste ('HEADING [',degree,']')), ylim=c(0,360),
\end_layout

\begin_layout Plain Layout

        lty=c(2,1), legend.position='topright')
\end_layout

\begin_layout Plain Layout

sdThdg <- sd (Data$DTHDG, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# lines(c(Data$Time[r[1]], Data$Time[DL]), c(180,180), col='green')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mech1a, include=TRUE, fig.height=3, fig.cap='The difference between
 THDG and THDGX (as plotted individually in the preceding figure) on a magnified
 scale.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

plotWAC(Data$Time, Data$DTHDG, ylab=expression(paste(Delta,"heading [",degree,"]
")))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attitude angles
\end_layout

\begin_layout Standard
The result of that integration for the attitude angles is compared to the
 INS-produced solution in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech}
\end_layout

\end_inset

.
 Throughout this flight segment, which included some perturbations in pitch
 and yaw and some complete-circle maneuvers, the attitude angles produced
 by this integration show the same variations as those from the INS, with
 only small exceptions.
 The standard deviations between the new values for pitch or roll and the
 corresponding values from the INS are 
\begin_inset Formula $<0.1^{\circ}$
\end_inset

, but the comparison for heading shows a larger standard deviation, about
 
\begin_inset Formula $2.5^{\circ}$
\end_inset

.
 The general agreement for the attitude angles verifies that the angle transform
ations are correct, but the larger deviations for heading were unexpected.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech1a}
\end_layout

\end_inset

 shows that the difference between the INS-provided heading and the value
 recalculated from the recorded rotation rates exhibits a systematic variation
 in the two 360
\begin_inset Formula $^{\circ}$
\end_inset

 turns between 3:40 and 3:55, which is suggestive of some problem even though
 the larger-scale variation shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech}
\end_layout

\end_inset

 is mostly correct.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<byawr-check, include=TRUE, fig.cap='Rate of change of heading obtained
 by differentiating the INS-produced measurements of heading, plotted against
 the corresponding IRU-provided measurement of the rotation rate about the
 yaw axis.
 The dashed orange line is a 1:1 line provided for reference.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

Data$YAWR <- c(diff(Data$THDG),0) * 25 * cos (Data$ROLL*pi/180)
\end_layout

\begin_layout Plain Layout

plotWAC(data.frame(Data$BYAWR, Data$YAWR), xlab='BYAWR', ylab='d(THDG)/dt',
 type='p', 
\end_layout

\begin_layout Plain Layout

        pch=20, col='blue', xlim=c(-2,2), ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

lines(c(-2,2), c(-2,2), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

Data$YAWR[abs(Data$YAWR) > 2] <- NA
\end_layout

\begin_layout Plain Layout

fm <- with(Data, lm(YAWR ~ BYAWR+I(BYAWR^2)+I(BYAWR^3)+I(BYAWR^4)))
\end_layout

\begin_layout Plain Layout

cfhdg <- coef(fm)
\end_layout

\begin_layout Plain Layout

X <- -200:200
\end_layout

\begin_layout Plain Layout

X <- X / 100
\end_layout

\begin_layout Plain Layout

Y <- cfhdg[1]+X*(cfhdg[2]+X*(cfhdg[3]+X*(cfhdg[4]+X*cfhdg[5])))
\end_layout

\begin_layout Plain Layout

# lines(X,Y, col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To investigate the origin of this variation, the measurement of heading
 provided by the INS was differentiated and the result was compared to the
 IRU-provided measurement of the rate of change in yaw angle.
\begin_inset Foot
status open

\begin_layout Plain Layout
For this comparison, the derivative of the heading must be multiplied by
 the cosine of the roll angle to represent the heading in the a-frame.
\end_layout

\end_inset

 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:byawr-check}
\end_layout

\end_inset

 shows a comparison of the differentiated heading and the measured yaw-rotation
 rate.
 The two measurements are in good agreement, and an attempt to improve the
 calibration of the IRU-measured rotation rate about the yaw axis by fitting
 a fourth-order polynomial to the points in this figure did not give significant
 improvement is the standard deviation of the difference between THDG and
 THDGX.
 The small differences shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech1a}
\end_layout

\end_inset

 are a troubling unexplained difference, but for the purposes of the error-state
 Kalman filter the important result is that the derivatives of all the attitude
 angles are reasonable and should be suitable for use in that filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mech-2, include=TRUE, fig.cap='Comparison of INS-provided and integration-
derived components of the aircraft velocity.
 The INS-provided values are VEW, VNS and VSPD and are shown as dashed blue
 lines.
 The new-mechanization values are VEWX, VNSX and VSPDX and are shown as
 solid dark-green lines.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VEW', 'VEWX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

         ylab="VEW [m/s]", legend.position='topright')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VNS', 'VNSX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

         ylab="VNS [m/s]", legend.position='topright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'VSPD', 'VSPDX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

         ylab="VSPD [m/s]", legend.position='topright')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'LAT', 'LATX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

          ylab=expression (paste ('Latitude [',degree,']')), legend.position='top
right')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'LON', 'LONX')], lty=c(2,1),
\end_layout

\begin_layout Plain Layout

          ylab=expression (paste ('Longitude [',degree,']')), legend.position='to
pright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

Data$PALT <- SmoothInterp (Data$PALT, .Length=121)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[, c('Time', 'ALT', 'ALTX', 'PALT')], lwd=c(2,3,2),
\end_layout

\begin_layout Plain Layout

          ylab="Altitude [m]", lty=c(2,1,3), legend.position='topright')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Velocity components
\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech-21}
\end_layout

\end_inset

 shows a comparison of velocity measurements obtained by the test mechanization
 scheme in comparison to the measurements provided by the INS.
 To construct comparable vertical-motion measurements, a baro-loop updated
 to the pressure altitude was introduced in order to obtain results comparable
 to those provided by the INS, which also uses this method to control instabilit
y in the variable representing vertical motion of the aircraft.
 The resulting variable VSPDX is in good agreement with the INS-provided
 measurement, with similar fluctuations during some short-period maneuvers
 around 3:34:00 UTC.
 Some of the difference in peak amplitude in this region likely originates
 from intrinsic filtering (of undisclosed character) applied by the INS
 but not included in the new mechanization.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<acceleration-check, include=TRUE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load (file=SaveRData3)
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

ggvns <- zoo::na.approx (as.vector(Data$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

ggvew <- zoo::na.approx (as.vector(Data$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

ggvspd <- zoo::na.approx (as.vector(Data$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

Data$BLONGA <- zoo::na.approx (as.vector (Data$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$BLATA <- zoo::na.approx (as.vector (Data$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$BNORMA <- zoo::na.approx (as.vector (Data$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

## The following are accelerations determined from derivatives of the GPS
 velocities.
\end_layout

\begin_layout Plain Layout

## These should match the measured accelerations after transformation to
 the l-frame
\end_layout

\begin_layout Plain Layout

## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

.span <- 11
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1) * 25  # m=1 for first
 deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1) * 25
\end_layout

\begin_layout Plain Layout

vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1) * 25
\end_layout

\begin_layout Plain Layout

## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

G <- Data$Grav
\end_layout

\begin_layout Plain Layout

VL <- matrix(c(Data$GGVEW, Data$GGVNS, Data$GGVSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection
 (Data, VL)
\end_layout

\begin_layout Plain Layout

AA <- XformLA (Data, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

## smooth to match values from differentiation
\end_layout

\begin_layout Plain Layout

# AA[,1] <- signal::sgolayfilt (AA[,1], 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

# AA[,2] <- signal::sgolayfilt (AA[,2], 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

# AA[,3] <- signal::sgolayfilt (AA[,3], 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

fa1 <- lm(Data$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

fa2 <- lm(Data$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

fa3 <- lm(Data$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

cfa1 <- coef(fa1)
\end_layout

\begin_layout Plain Layout

cfa2 <- coef(fa2)
\end_layout

\begin_layout Plain Layout

cfa3 <- coef(fa3)
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(Data$BLONGA, Data$BLATA, Data$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (Data, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

AL <- AL - RotationCorrection (Data, VL)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

Data$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

Data$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

Data$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

Data$LACCZ <- -Data$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

Data$LACCX <- signal::sgolayfilt (Data$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

Data$LACCY <- signal::sgolayfilt (Data$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

Data$LACCZ <- signal::sgolayfilt (Data$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because small offsets appear in the measurements of velocity, the IRU-provided
 measurements of acceleration were checked by differentiating the GPS measuremen
ts of velocity components and comparing the results, after correction for
 motion of the 
\emph on
l-
\emph default
frame relative to an inertial frame and for the Earth's rotation, to the
 corresponding IRU-provided measurements.
 The resulting regression-fit coefficients (constant offset and slope) for
 the normal and longitudinal components of the acceleration (BNORMA and
 BLONGA) were respectively {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa3[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa3[2], 4)}
\end_layout

\end_inset

} and {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa1[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa1[2], 4)}
\end_layout

\end_inset

}, so the deduced calibrations are very close to those that provide BNORMA
 and BLONGA.
 For the lateral component (BLATA), accelerations were usually too small
 to give a good calibration; although the same procedure applied to this
 component gives regression coefficients of {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa2[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfa2[2], 4)}
\end_layout

\end_inset

}, this result appeared too unreliable to use to adjust the calibration
 in use.
 The calibrations for BNORMA and BLONGA, however, have been used in the
 preceding methanization, where they made only very small changes in results.
\end_layout

\begin_layout Subsubsection
Position
\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mech-22}
\end_layout

\end_inset

 compares the results obtained for position.
 There are only small offsets in the horizontal positions that result from
 the small differences in horizontal velocity componenets, and the vertical
 position also agrees well with the INS-provided value except for a small
 offset that apparently originates in different reference pressures used
 internally by the INS vs that used in this new mechanization.
 The remaining differences between the values provided by this new mechanization
 and the result provided by the INS call for further investigation, but
 the key result from this part of the study is that as implemented above
 the derivatives of components of the state vector are approximately correct
 and integrate to reasonable values.
 This is a good check on the angle transformations, coordinate systems,
 and signs used in the equations giving the mechanization,.
 The function providing the required derivatives is therefore a reasonable
 basis for the Kalman filter that follows.
\end_layout

\begin_layout Section
Detailed description of the error-state Kalman filter
\end_layout

\begin_layout Subsection
Definitions of vectors and matrices
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The error-state Kalman filter was introduced in Sects.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-Kalman-filter"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:An-error-state-Kalman"

\end_inset

.
\end_layout

\end_inset

 There are many descriptions of the Kalman filter that provide detailed
 algorithms, among them 
\begin_inset CommandInset citation
LatexCommand cite
key "noureldin2013fundamentals"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "groves2013PrinciplesGNSS"

\end_inset

, The implementation here mostly follows the notation of 
\begin_inset CommandInset citation
LatexCommand cite
key "noureldin2013fundamentals"

\end_inset

.The error-state Kalman filter developed here is based on the assumption
 that the INS-provided solution is likely close enough to the true solution
 that errors can be represented as linear departures from that solution
 where the linear coefficients are given by the Jacobian of the derivative
 function that provides the reference solution.
 That is, if 
\begin_inset Formula $\dot{\boldsymbol{x}}=\boldsymbol{D}(\boldsymbol{x})$
\end_inset

 where 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 is the aircraft-state vector and 
\begin_inset Formula $\boldsymbol{D}(\boldsymbol{x})$
\end_inset

 is the derivative vector provided by the function STMFV(sv) where sv is
 the R vector containing the aircraft-state vector and STMFV() is the R
 function that generates the derivative vector represented by 
\begin_inset Formula $\boldsymbol{D}(\boldsymbol{x})$
\end_inset

, the normal mechanization discussed in the preceding section advances 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

 in time by taking time steps using the derivative vector 
\begin_inset Formula $\boldsymbol{D}(\boldsymbol{x})$
\end_inset

 to determine the required change in each component of 
\begin_inset Formula $\boldsymbol{x}$
\end_inset

.
 If instead an error-state vector 
\begin_inset Formula $\delta\boldsymbol{x}$
\end_inset

 is propagated forward, the linear estimate of the change in the error-state
 at each time step will be given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\dot{\boldsymbol{x}}=\frac{\partial\boldsymbol{D}(\boldsymbol{x})}{\partial\boldsymbol{x}}\delta\boldsymbol{x}=\mathcal{\boldsymbol{J}}(x)\delta\boldsymbol{x}\,\,\,\,.\label{eq:jacobian}
\end{equation}

\end_inset

where 
\emph on

\begin_inset Formula $\boldsymbol{\mathcal{J}}$
\end_inset


\emph default
 is the Jacobian matrix of the derivative vector 
\begin_inset Formula $\boldsymbol{D}$
\end_inset

, defined by this equation.
\begin_inset Foot
status open

\begin_layout Plain Layout
Cf.
\begin_inset space ~
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, Eq.
\begin_inset space ~
\end_inset

6.2.
\end_layout

\end_inset

 Sources like this footnoted one provide detailed equations for the Jacobian
 matrix.
 However, a different approach has been taken here because of doubt that
 deriving, coding, and verifying all the components of that 15
\begin_inset Formula $\times$
\end_inset

15 matrix (where the 15 components are three position-errors, three velocity-err
ors, three attitude-errors, three rotation-rate errors, and three accelerometer
 errors) could be done without a difficult amount of work.
 Instead, once the derivative function is determined and verified as in
 the preceding section, a numerical Jacobian function (here, the R routine
\begin_inset Foot
status open

\begin_layout Plain Layout
numDeriv::jacobian())
\end_layout

\end_inset

 provides the required matrix 
\begin_inset Formula $\boldsymbol{\mathcal{J}}$
\end_inset

 without further specification.
 Furthermore, the common approximations involved in analytical solutions,
 where terms expected to be small are dropped, are not necessary with this
 approach.
 
\end_layout

\begin_layout Standard
The error-state Kalman filter sequentially uses a set of matrices, so it
 is useful to define those as follows.
 (Variable names following the symbols are the R variable names used in
 the associated code.)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{x}_{k}$
\end_inset


\begin_inset space ~
\end_inset

[SVE] The error-state vector at sequential time interval 
\begin_inset Formula $k$
\end_inset

, where values are separated in time by 
\begin_inset Formula $\Delta t$
\end_inset

.
 In the present case, the error-state vector consists of 15 components,
 the estimated errors in position coordinates, aircraft velocity vector,
 aircraft attitude angles, IRU-measured rotation rates, and IRU-measured
 accelerations.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{T}_{k|k-1}$
\end_inset


\begin_inset space ~
\end_inset

[dcm] The 15x15 state transformation matrix describing the forward propagation
 of the error state from time 
\begin_inset Formula $k-1$
\end_inset

 to time 
\begin_inset Formula $k$
\end_inset

.
 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is the sum of the identity (diagonal) matrix 
\begin_inset Formula $\boldsymbol{I}$
\end_inset

 and the time step multiplied by the Jacobian matrix 
\begin_inset Formula $\boldsymbol{\mathcal{J}}$
\end_inset

 defined in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:jacobian"

\end_inset

).
 Then 
\begin_inset Formula $\delta\boldsymbol{x}_{k}=\boldsymbol{T}_{k,k-1}\delta\boldsymbol{x}_{k-1}=(\boldsymbol{I}+\boldsymbol{\mathcal{J}}(\boldsymbol{x}_{k-1})\Delta t)\delta\boldsymbol{x}_{k-1}$
\end_inset

(or, alternately, the equivalent fourth-order Runge-Kutta step) propagates
 the error state forward in time.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{V}$
\end_inset


\begin_inset space ~
\end_inset

[CV] The covariance matrix that applies to the state vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

, a 15x15 matrix.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}$
\end_inset


\begin_inset space ~
\end_inset

[K] The Kalman-gain matrix representing how the error-state vector is updated
 using the current error state and the new GPS measurements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{z}$
\end_inset


\begin_inset space ~
\end_inset

[DZ] The 6-component measured differences between the INS and GPS measurements
 of position and velocity.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{H}$
\end_inset


\begin_inset space ~
\end_inset

[H] The 15x6-component matrix representing how the measured differences
 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 correspond to the error-state vector.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{Q},\,\mathbf{R}$
\end_inset


\begin_inset space ~
\end_inset

[Q,
\begin_inset space ~
\end_inset

R] Matrices representing respectively the anticipated noise contributions
 affecting the error-state vector (15x15) and the measurements from the
 GPS (6x6).
\end_layout

\begin_layout Standard
The approach taken here will be to filter the error-state vector that represents
 the difference between the best-estimate measurements and those originally
 provided by the INS.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The INS integration does not need to be duplicated to obtain the reference
 solution because that has already been done by the INS with higher accuracy
 than can be duplicated.
 However, the error-state Kalman filter does need the aircraft-state transition
 matrix that represents the original forward integration, so the first step
 in this analysis was to obtain the matrix xxxsuch a matrix and validate
 results obtained by using it by comparing to the available INS solution.
 The Jacobian of that state-transition function then provides the matrix
 
\begin_inset Formula $\mathbf{T}$
\end_inset

 used in this filter.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Some component functions
\end_layout

\begin_layout Standard
Some of the operations involved in that 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 are contained in the following functions, with code as in the associated
 R 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 that are embedded in the 
\begin_inset Quotes eld
\end_inset

KalmanFilter.Rnw
\begin_inset Quotes erd
\end_inset

 file that produces this document and also controls the associated calculations.
 The code for the functions is not listed here but is available in that
 file which is archived with the text document
\end_layout

\begin_layout Enumerate

\emph on
\bar under
XfLArV()
\emph default
\bar default
, a function of the current state vector, provides a 3x3 matrix that transforms
 a vector from the 
\emph on
a-
\emph default
frame (the aircraft reference frame) to the 
\emph on
l-
\emph default
frame, the local-level frame (with {x,y,z} coordinates toward the East,
 North, and upward directions).
 
\end_layout

\begin_layout Enumerate

\emph on
\bar under
RotationCorrection()
\emph default
\bar default
 calculates the correction to accelerations needed to account for the rotation
 of the Earth and of the 
\emph on
l-
\emph default
frame relative to an inertial frame.
 This function provides corrections to subtract from transformed accelerations
 before using them in the 
\emph on
l-
\emph default
frame.
\end_layout

\begin_layout Enumerate

\emph on
\bar under
STMFV()
\emph default
\bar default
 calculates the 15-component derivative of the state vector given the state
 vector and the measurements from the IRU.
 This function is then used in the R function numDeriv::jacobian to find
 the Jacobian needed for the state transformation matrix.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

,  'Comparison of INS-provided and integration-derived position.'
\end_layout

\begin_layout Plain Layout

SP <- SPR    ## restore to state before integration
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sequential steps in the error-state Kalman filter
\end_layout

\begin_layout Standard
The preceding steps verify that reasonable derivatives of the state variables
 are available.
 On that basis, an error-state Kalman filter can be developed as follows:
\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position and velocity.
 Other errors are unknown at the start of the integration and so will be
 initialized as zero.
\end_layout

\begin_layout Enumerate
The covariance matrix 
\begin_inset Formula $\mathbf{V}$
\end_inset

 characterizing the errors in the error-state-vector is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\Phi$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units escelt those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides a reasonable representat
ion of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function, so the state transition matrix
 is the sum of that Jacobian (multiplied by the time step) and the 15-element
 diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF().
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are specified, the covariance matrix can be updated via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X6 diagonal matrix representing how the 6 measured differences (GPS-INS)
 correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise covariance matrix representing the GPS noise,
 a 6x6 matrix having diagonal elements that are taken to be the squares
 of these components: {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1}.
\end_layout

\begin_layout Enumerate
Define 
\series bold

\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 
\series default
as the set of six measurements consisting of the differences between GPS
 and INS positions and velocities.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate because it is expected that the errors vary slowly.
 However, turns and other maneuvers can introduce spurious effects if there
 are time delays among the measurements, so adjustment for these sub-second
 delays will be made before the filter is applied.
 A 1-Hz data file will be used for the following example, and the measurements
 of components of the velocity and of the attitude angles as well as the
 rotation rates and accelerations will be smoothed before applying the Kalman
 filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-point third-order Savitzky-Golay smoothing of accelerations and 301-point
 smoothing of measured velocity components and attitude angles.
 The effective cutoff frequencies for these filters are about 0.3
\begin_inset space ~
\end_inset

Hz and 0.008
\begin_inset space ~
\end_inset

Hz, respectively.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 				
\end_layout

\begin_layout Plain Layout

Project = "DW"     			 
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

SaveRData4 <- sprintf("%s4.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  D1 <- getNetCDF (fname, c(VarList, "TASX"))		
\end_layout

\begin_layout Plain Layout

  save(D1, file=SaveRData4)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData4)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

s <- -120
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

s <- 92
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

SHIFT <- FALSE
\end_layout

\begin_layout Plain Layout

SHIFT <- TRUE
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if (SHIFT) {
\end_layout

\begin_layout Plain Layout

  # D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)    ## this is needed for
 pitch and heading corrections
\end_layout

\begin_layout Plain Layout

  # D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- ShiftInTime (D1$THDG, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- ShiftInTime (D1$PITCH, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- ShiftInTime (D1$ROLL, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$VEW <- ShiftInTime (D1$VEW, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$VNS <- ShiftInTime (D1$VNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$VSPD <- ShiftInTime (D1$VSPD, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- ShiftInTime (D1$BLONGA, Rate, si)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- ShiftInTime (D1$BLATA, Rate, si)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- ShiftInTime (D1$BNORMA, Rate, si)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## remove the cal-coefficient offset: (+0.08)
\end_layout

\begin_layout Plain Layout

# D1$THDG <- D1$THDG + 0.08
\end_layout

\begin_layout Plain Layout

dt <- 1
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')  
\end_layout

\begin_layout Plain Layout

# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT *
 Cradeg)^2 + D1$GGALT)
\end_layout

\begin_layout Plain Layout

  #interpolate if necessary:
\end_layout

\begin_layout Plain Layout

  MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LON <- zoo::na.approx (as.vector (D1$LON), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ALT <- zoo::na.approx (as.vector (D1$ALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  ## smooth the measurements
\end_layout

\begin_layout Plain Layout

  .span <- 11    
\end_layout

\begin_layout Plain Layout

  ## The following are accelerations determined from derivatives of the
 GPS velocities.
\end_layout

\begin_layout Plain Layout

  ## These should match the measured accelerations after transformation
 to the l-frame
\end_layout

\begin_layout Plain Layout

  ## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  ## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

  G <- D1$Grav
\end_layout

\begin_layout Plain Layout

  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection
 (D1, VL)
\end_layout

\begin_layout Plain Layout

  AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

  AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

  fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

  fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

  fa3 <- lm(D1$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

  AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

  ## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  AL <- AL - RotationCorrection (D1, VL)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  .span <- 301
\end_layout

\begin_layout Plain Layout

  SMOOTH <- FALSE
\end_layout

\begin_layout Plain Layout

  if (SMOOTH) {
\end_layout

\begin_layout Plain Layout

    vns <- signal::sgolayfilt (vns, 3, .span)
\end_layout

\begin_layout Plain Layout

    vew <- signal::sgolayfilt (vew, 3, .span)
\end_layout

\begin_layout Plain Layout

    vspd <- signal::sgolayfilt (vspd, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvns <- signal::sgolayfilt (ggvns, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvew <- signal::sgolayfilt (ggvew, 3, .span)
\end_layout

\begin_layout Plain Layout

    ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
\end_layout

\begin_layout Plain Layout

    pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
\end_layout

\begin_layout Plain Layout

    roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
\end_layout

\begin_layout Plain Layout

    thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    D1$VNSF <- vns
\end_layout

\begin_layout Plain Layout

    D1$VEWF <- vew
\end_layout

\begin_layout Plain Layout

    D1$VSPDF <- vspd
\end_layout

\begin_layout Plain Layout

    D1$GGVNSF <- ggvns
\end_layout

\begin_layout Plain Layout

    D1$GGVEWF <- ggvew
\end_layout

\begin_layout Plain Layout

    D1$GGVSPDF <- ggvspd
\end_layout

\begin_layout Plain Layout

    D1$PITCHF <- pitch
\end_layout

\begin_layout Plain Layout

    D1$ROLLF <- roll
\end_layout

\begin_layout Plain Layout

    D1$THDGF <- thdg
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

## get the pitch and roll in the l-frame:
\end_layout

\begin_layout Plain Layout

.pitch <- D1$PITCH * Cradeg
\end_layout

\begin_layout Plain Layout

.roll <- D1$ROLL * Cradeg
\end_layout

\begin_layout Plain Layout

.thdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

x <- XPitch (.pitch, .roll, .thdg)
\end_layout

\begin_layout Plain Layout

# pitchL <- x[,1]
\end_layout

\begin_layout Plain Layout

# rollL <- x[,2]
\end_layout

\begin_layout Plain Layout

  ## note: all in units of radians
\end_layout

\begin_layout Plain Layout

  # pitchL <- cos (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg)
 - sin (.thdg) * sin (D1$ROLL*Cradeg)
\end_layout

\begin_layout Plain Layout

  # rollL  <- sin (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg)
 + cos (.thdg) * sin (D1$ROLL*Cradeg)
\end_layout

\begin_layout Plain Layout

D1$PITCHL <- x[, 1] / Cradeg  #pitchL
\end_layout

\begin_layout Plain Layout

D1$ROLLL <-  x[, 2] / Cradeg  #rollL
\end_layout

\begin_layout Plain Layout

A2 <- D1$LACCX^2 + D1$LACCY^2
\end_layout

\begin_layout Plain Layout

  A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

  D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2
)
\end_layout

\begin_layout Plain Layout

  D1$herr <- (D1$LACCX*(vedot-D1$LACCX)-D1$LACCY * (vndot-D1$LACCY)) / (2*D1$LAC
CX*D1$LACCY)
\end_layout

\begin_layout Plain Layout

  D1$herr <- (atan2(D1$LACCX, D1$LACCY) - atan2 (vedot, vndot))/Cradeg
\end_layout

\begin_layout Plain Layout

  D1$herr[D1$herr > 180] <- D1$herr[D1$herr > 180] - 360
\end_layout

\begin_layout Plain Layout

  D1$herr[D1$herr < -180] <- D1$herr[D1$herr < -180] + 360
\end_layout

\begin_layout Plain Layout

  D1$varh <- runVar (D1$herr, n=30)  ## runVar is part of the package TTR
 (running variance)
\end_layout

\begin_layout Plain Layout

  D1$varh[is.na(D1$varh)] <- 1000
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## a test of the time shift:
\end_layout

\begin_layout Plain Layout

  D1$sdh <- sqrt(D1$varh)
\end_layout

\begin_layout Plain Layout

  D1$he <- D1$herr
\end_layout

\begin_layout Plain Layout

  D1$he[D1$sdh > 0.1] <- NA
\end_layout

\begin_layout Plain Layout

  DD1 <- D1[setRange(D1,61000,123000),]
\end_layout

\begin_layout Plain Layout

  plotWAC(DD1$ROLL, DD1$he, xlab='Roll', type='p', col='blue')
\end_layout

\begin_layout Plain Layout

  fff <- lm(DD1$he ~ I(tan(DD1$ROLL*Cradeg)))
\end_layout

\begin_layout Plain Layout

  b <- coef(fff)[2]*Cradeg
\end_layout

\begin_layout Plain Layout

  deltaT <- -b * mean (DD1$TASX, na.rm=TRUE) / 9.8
\end_layout

\begin_layout Plain Layout

  print (sprintf ('time shift is %f after shift of %f applied', deltaT,
 s/1000))
\end_layout

\begin_layout Plain Layout

fm1 <- lm (vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the 
\emph on
a
\emph default
-frame and compared to the measured accelerations from the IRU (with correction
 for the Earth's rotation and the motion of the 
\emph on
l
\emph default
-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

, with residual standard deviation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The differentiated measurements of velocity components from the GPS might
 be considered as additional measurements corresponding to the measured
 accelerations that could be incorporated into the Kalman filter.
 This is discussed later in this report.
\end_layout

\begin_layout Subsection
Treatment of the pitch and roll angles
\end_layout

\begin_layout Standard
The error-state vector consists of the errors in all components in the 
\emph on
l-
\emph default
frame.
 In the case of pitch and roll, this requires transforming the resulting
 corrected angles back to the 
\emph on
a-
\emph default
frame, where for example pitch is used in the calculation of vertical wind,
 to obtain archived results.
 Using pitch and roll in the 
\emph on
l-
\emph default
frame results in better Kalman-filter integration because the errors are
 smoothly varying in that frame, while in the 
\emph on
a-
\emph default
frame there are frequent jumps in the error terms arising from turns.
 In the 
\emph on
l-
\emph default
frame, the errors vary slowly because they arise primarily from mis-alignment
 of the platform.
 While that mis-alignment undergoes the usual Schuler oscillation arising
 from strong coupling between the angle errors and the velocity errors,
 it otherwise does not change rapidly, but any misalignment translates to
 heading-dependent errors in the 
\emph on
a-
\emph default
frame so the errors in 
\emph on
a-
\emph default
frame pitch and roll can change rapidly in turns.
 Updating of these errors is therefore smoother in the 
\emph on
l-
\emph default
frame, and that is the approach taken in this report.
\end_layout

\begin_layout Standard
Because the IRU-reported measurements of pitch and roll are in the 
\emph on
a-
\emph default
frame, those measurements and the rotation-rate measurements must be translated
 to the 
\emph on
l-
\emph default
frame when they are used in the calculation of the derivative of the error-state
 vector.
 Therefore the following transformation of pitch and roll from the 
\emph on
a-
\emph default
frame to the 
\emph on
l
\emph default
-frame is used: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\theta^{(l)}=-\arcsin(-\cos(\psi)\sin(\theta)\cos(\phi)-\sin(\psi)\sin(\phi))\label{eq:pitchAtoL}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\phi^{(l)}=\arcsin(-\sin(\psi)\sin(\theta)\cos(\phi)+\cos(\psi)\sin(\phi))\label{eq:RollAtoL}
\end{equation}

\end_inset

The inverse transformation from the 
\emph on
l-
\emph default
frame to the 
\emph on
a-
\emph default
frame is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\theta=-\arctan(\frac{\sin(\phi^{(l)})\sin(\psi)-\sin(\theta^{(l)})\cos(\psi)}{\sqrt{1-\sin^{2}(\phi^{(l)})-\sin^{2}(\theta^{(l)})}}\label{eq:PitchLtoA}
\end{equation}

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\phi=-\arctan(\frac{-\sin(\phi^{(l)})\cos(\psi)-\sin(\theta^{(l)})\sin(\psi)}{\sin(\psi)\sin(\theta^{(l)})\sin(\phi^{(l)})-\cos(\psi)\sin^{2}(\theta^{(l)})+\cos(\theta^{(l)})\sqrt{1-\sin^{2}(\phi^{(l)})-\sin^{2}(\theta^{(l)})}}\label{eq:RollLtoA}
\end{equation}

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection
Detecting the error in heading
\end_layout

\begin_layout Standard
Most of the components of the state vector have good feedback from GPS-derived
 measurements, but an exception is the measurement of heading.
 For position and velocity, there is direct correspondence between INS-
 and GPS-derived measurements.
 For pitch and roll, there is strong coupling to errors in the eastward
 and northward components of aircraft velocity.
 However, the coupling of INS-measured heading to GPS observations is not
 a case of strong coupling (to which the Schuler oscillation applies), and
 it is more difficult to update via measurements from the GPS receiver.
 The source of coupling between GPS-derived measurements and heading is
 via the aircraft-velocity components, because an error in heading causes
 the IRU-measured accelerations to be resolved into the 
\emph on
l-
\emph default
frame incorrectly and so introduces errors in the aircraft-velocity components
 that can be detected via comparison to GPS-provided velocity components.
 Unfortunately, in most cases the measured accelerations are small, resulting
 in large uncertainties in the correction term except during turns, and
 there are alternative adjustments to the accelerations or rotation rates
 that can account for the same errors.
 Therefore, heading will receive special treatment here.
\end_layout

\begin_layout Standard
Three approaches were tried:
\end_layout

\begin_layout Enumerate
The Kalman-filter structure as described above will use the errors in velocity
 to correct the error-state vector.
 The coupling to heading is typically an order of magnitude weaker than
 that to pitch or roll.
 Without special attention, the coupling to heading potentially can be obscured
 by the other sensitivities, through which the errors in velocity can be
 attributed to error-state components in horizontal acceleration and in
 roll and pitch.
 In turn, an error in heading is dependent mostly on errors in the gyro
 rotation rates.
 These sensitivities make it difficult to obtain a reliable adjustment of
 heading in the standard approach, and the results from this approach were
 generally disappointing.
\end_layout

\begin_layout Enumerate
The 
\emph on
l-
\emph default
frame accelerations measured by differentiating the GPS-derived horizontal
 velocity components can be used as additional components of the observation
 vector, complementing the position and velocity measurements from GPS.
 These accelerations can then be used as independent measurements of acceleratio
n.
 While this provides some additional adjustable parameters for the filter
 associated with the covariances of the GPS-derived accelerations, the errors
 in acceleration can still be attributed to errors in the measured accelerations.
 In tests, this seemed to add little to the sensitivity of the Kalman filter
 to errors in heading.
\end_layout

\begin_layout Enumerate
The most successful approach was to compare the measured horizontal-acceleration
 vector, obtained by transforming the measured 
\emph on
a-
\emph default
frame accelerations to the 
\emph on
l-
\emph default
frame, to the acceleration determined by differentiating the GPS-measured
 components of horizontal velocity.
 The angle between these two vectors is a measure of the heading error and
 can be used as a component of the observation vector 
\begin_inset Formula $\mathbf{Z}$
\end_inset

 with which to update the heading.
 Specifically, the error in heading (
\begin_inset Formula $\delta\psi)$
\end_inset

 is measured to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}

\end_inset

where 
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

 and 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

 are the 
\emph on
l-
\emph default
frame accelerations obtained by transforming the IRU-measured accelerations
 from the 
\emph on
a-
\emph default
frame to the 
\emph on
l-
\emph default
frame and 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

 are the eastward and northward components of the acceleration obtained
 from the time-derivatives of the GPS-measured eastward and northward velocity
 components 
\begin_inset Formula $v_{e}$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

.
 The assumption made when using this formula is that the errors in the INS-produ
ced accelerations in the 
\emph on
l-
\emph default
frame arise from the heading error, with negligible contribution from the
 errors in the accelerometers.
 If this is the case, it would be possible to base the heading correction
 on this formula alone, but the more general case needs to consider how
 this might be influenced by errors in accelerations, so it is preferable
 to incorporate this into the Kalman filter and allow for the possibility
 that measured accelerations need to be adjusted.
\end_layout

\begin_layout Standard
The third approach leads to noisy estimates of the correction 
\begin_inset Formula $\delta\psi$
\end_inset

 under most conditions, but will give reliable results when horizontal accelerat
ions are significant (e.g., 
\begin_inset Formula $>1$
\end_inset


\begin_inset space ~
\end_inset

m/s
\begin_inset Formula $^{2}$
\end_inset

).
 Because such accelerations often occur in turns when both angles in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) are changing rapidly, it is very important to have correct relative timing
 between the INS measurement of heading and the GPS measurement of velocity.
\begin_inset Foot
status open

\begin_layout Plain Layout
As an illustration, a 50-ms delay in heading during a 3-min turn causes
 a shift in heading relative to the correct time of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

, so adjustment to at least this uncertainty is desirable.
 
\end_layout

\end_inset

 The GPS measurements are assigned correct times by the GPS receiver and
 represent a standard clock against which to compare other measurements.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that the relative timing between the IRU and the GPS can drift
 enough during some flights to introduce significant errors.
\end_layout

\end_inset

 If the GPS-vs-INS time shift is not removed, a bias will be introduced
 into the heading correction that varies with turn direction.
 Therefore the following procedure is followed to remove this time shift:
\end_layout

\begin_layout Enumerate
Differentiate the GPS-provided measurements to obtain 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

, the eastward and northward accelerations in the 
\emph on
l-
\emph default
frame.
\end_layout

\begin_layout Enumerate
Transform the unshifted body accelerations to the 
\emph on
l-
\emph default
frame, with rotation corrections, to obtain the eastward and northward component
s of the IRU-measured acceleration (
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

, 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

) in the local-level frame.
 
\end_layout

\begin_layout Enumerate
Find the heading correction for unshifted measurements by calculating 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

).
\end_layout

\begin_layout Enumerate
Calculate the running-standard-deviation of 
\begin_inset Formula $\delta\psi$
\end_inset

 spanning 30 seconds.
 Select the subset of 
\begin_inset Formula $\delta\psi$
\end_inset

 for which that standard deviation is less than 0.2
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fit the subset to find the slope 
\begin_inset Formula $b$
\end_inset

 in the relationship 
\begin_inset Formula $\delta\psi=a+b\thinspace\tan\phi$
\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle.
 The rate of turn 
\begin_inset Formula $R$
\end_inset

 is related to the roll angle 
\begin_inset Formula $\phi$
\end_inset

 according to the relationship 
\begin_inset Formula $R=g\thinspace\tan\phi/V$
\end_inset

 where 
\begin_inset Formula $V$
\end_inset

 is the airspeed, so 
\begin_inset Formula $\tan\phi=RV/g$
\end_inset

 and 
\begin_inset Formula $\delta\psi=a+bRV/g$
\end_inset

.
 A time delay of 
\begin_inset Formula $\delta t$
\end_inset

 produces a heading error of 
\begin_inset Formula $-R\delta t$
\end_inset

, so 
\begin_inset Formula $-R\delta t=a+bRV/g$
\end_inset

 and the time shift can be estimated from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta t=-b\frac{V}{g}\label{eq:deltaT}
\end{equation}

\end_inset

For example, for DEEPWAVE flight 16, 
\begin_inset Formula $b=0.2146^{\circ}$
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 = 0.003745
\begin_inset space \thinspace{}
\end_inset

rad
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and 
\begin_inset Formula $V\simeq240$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, so (with g=9.8
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

) 
\begin_inset Formula $\delta t=$
\end_inset

-0.092
\begin_inset space ~
\end_inset

s.
 The negative sign indicates that the INS-derived measurement of heading
 should be shifted forward in time by 92
\begin_inset space \thinspace{}
\end_inset

ms relative to the GPS-derived measurements of aircraft velocity.
 The standard error from the fit indicates that this shift was determined
 with an uncertainty of about 3
\begin_inset space \thinspace{}
\end_inset

ms, so this is a very sensitive method for determining the time shift.
\end_layout

\begin_layout Enumerate
Apply this time shift to the measurements of heading.
 For a file containing measurements at 1
\begin_inset space ~
\end_inset

Hz, this requires creating an interpolated high-rate vector of measurements,
 shifting that vector, and then extracting a shifted 1-Hz-averaged vector
 from the shifted measurements.
 The Ranadu function ShiftInTime() accomplishes this by interpolating to
 a 125-Hz variable.
 The result can be checked by repeating step 5 using the shifted measurements;
 for this case, the deduced shift needed for the shifted time series was
 only 1
\begin_inset space ~
\end_inset

ms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
It may be useful to incorporate in addition a time dependence, either to
 the time shift or to the correction factor.
 Preliminary study of this indicates that a time dependence is significant,
 as represented for example via he~tan(ROLL)+Ts where Ts=as.vector(Data$Time-Data
$Time[1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
, but this will not be part of this initial study because the accelerometers
 appear to have low uncertainty and because the effect of errors in acceleration
 would also appear as errors in velocity and so should be detected by the
 conventional 6-component measurement vector for Kalman filtering.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, echo=FALSE, cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## also need the noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 30 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 30 / (sp$Rn * cos (sv[1]))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 150
\end_layout

\begin_layout Plain Layout

  gcf[4:5] <- 0.15
\end_layout

\begin_layout Plain Layout

  gcf[6] <- 1.5
\end_layout

\begin_layout Plain Layout

  gcf[7:8] <- 0.03*Cradeg # 0.001 * 10  ##TEST
\end_layout

\begin_layout Plain Layout

  gcf[9] <- 0.01*Cradeg
\end_layout

\begin_layout Plain Layout

  gcf[10:12] <- 0.015*Cradeg*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.0005*sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

i <- 1
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[i, ]))
\end_layout

\begin_layout Plain Layout

# Gnoise <- gcf * rnorm(15)
\end_layout

\begin_layout Plain Layout

# dsve <- dcm %*% SVE   # + Gnoise
\end_layout

\begin_layout Plain Layout

# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model:
\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS,
 VSPD-GGVSPD))
\end_layout

\begin_layout Plain Layout

DZ <- c(DZ, D1$LACCX-vedot, D1$LACCY-vndot, D1$LACCZ-vudot, D1$herr*Cradeg)
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 10)
\end_layout

\begin_layout Plain Layout

DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the observation matrix: (the first six components of the state error
 vector are observable)
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=10, ncol=15)
\end_layout

\begin_layout Plain Layout

for (k in 7:9) {
\end_layout

\begin_layout Plain Layout

  H[k,k] <- 0
\end_layout

\begin_layout Plain Layout

  # H[k,k+6] <- 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

H[10,10] <- 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

## GPS measurement noise
\end_layout

\begin_layout Plain Layout

# RN <- c(50/D1$Rm[1], 50/(D1$Rn[1]*cos(SV[1])), 10, 0.1, 0.1, 0.1)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,100), ncol=10)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (1500/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (1500/(D1$Rn[1]*cos(SV[1])))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 300^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 3^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 3^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 3^2
\end_layout

\begin_layout Plain Layout

RCV[7,7] <- 1^2
\end_layout

\begin_layout Plain Layout

RCV[8,8] <- 1^2
\end_layout

\begin_layout Plain Layout

RCV[9,9] <- 1^2
\end_layout

\begin_layout Plain Layout

RCV10 <- (0.5*Cradeg)^2  #0.1
\end_layout

\begin_layout Plain Layout

RCV[10,10] <- RCV10 / A[i]^4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, echo=FALSE, eval=TRUE, fig.cap=' ', cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- D1
\end_layout

\begin_layout Plain Layout

DL <- nrow (Data)
\end_layout

\begin_layout Plain Layout

BACKWARD <- FALSE
\end_layout

\begin_layout Plain Layout

s <- -120
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

SHIFT <- FALSE
\end_layout

\begin_layout Plain Layout

SHIFT <- TRUE
\end_layout

\begin_layout Plain Layout

if (SHIFT) {
\end_layout

\begin_layout Plain Layout

  Data$GGVEW <- ShiftInTime (Data$GGVEW, Rate, s)    ## this is needed for
 pitch correction
\end_layout

\begin_layout Plain Layout

  Data$GGVNS <- ShiftInTime (Data$GGVNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  # Data$BLONGA <- ShiftInTime (Data$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BLATA <- ShiftInTime (Data$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BNORMA <- ShiftInTime (Data$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  # find PITCHL, ROLLL in the l-frame
\end_layout

\begin_layout Plain Layout

  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal
 to AC
\end_layout

\begin_layout Plain Layout

  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
\end_layout

\begin_layout Plain Layout

  # UVL <- XformLA (Data, UV)
\end_layout

\begin_layout Plain Layout

  # PitchL <- asin (-UVL[,2])
\end_layout

\begin_layout Plain Layout

  # RollL <- asin (UVL[,1])
\end_layout

\begin_layout Plain Layout

  #   .hdg <- Data$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## note: using l-frame PITCH and ROLL; STMFV must account for this
\end_layout

\begin_layout Plain Layout

i <- 1
\end_layout

\begin_layout Plain Layout

if (BACKWARD) {i <- DL}
\end_layout

\begin_layout Plain Layout

SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

NSTEP <- 5      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

CVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

SVE[7:8] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

SVE[9] <- -0.08 * Cradeg
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

CVEF[1, ] <- diag (CV)
\end_layout

\begin_layout Plain Layout

# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
\end_layout

\begin_layout Plain Layout

# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
\end_layout

\begin_layout Plain Layout

nStart <- 1+NSTEP
\end_layout

\begin_layout Plain Layout

nEnd <- DL
\end_layout

\begin_layout Plain Layout

NS <- NSTEP
\end_layout

\begin_layout Plain Layout

if (BACKWARD) {
\end_layout

\begin_layout Plain Layout

  nStart <- DL-NSTEP
\end_layout

\begin_layout Plain Layout

  nEnd <- 1
\end_layout

\begin_layout Plain Layout

  NS <- -NSTEP
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

pcntlast <- 0
\end_layout

\begin_layout Plain Layout

# for (i in seq (2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

for (i in seq (nStart, nEnd, by=NS)) {
\end_layout

\begin_layout Plain Layout

  pcnt <- as.integer ((i-nStart) / (nEnd-nStart) * 100)
\end_layout

\begin_layout Plain Layout

  if ((pcnt %% 10) == 0 && pcnt != pcntlast) {
\end_layout

\begin_layout Plain Layout

    print (sprintf ('percent done=%d', pcnt))
\end_layout

\begin_layout Plain Layout

    pcntlast <- pcnt
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL,
 ROLLL, THDG,
\end_layout

\begin_layout Plain Layout

                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- Data$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- Data$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- Data$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  ## in the following, STMFV returns the attitude-angle derivatives in the
 l-frame
\end_layout

\begin_layout Plain Layout

  ## if LFrame is TRUE
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  if (i == 1+NS*500) {dcmSave <- dcm}
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new state vector:
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE
\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  # RCV[10,10] <- Data$varh[i]
\end_layout

\begin_layout Plain Layout

  RCV[10, 10] <- Data$varh[i] 
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

  CVEF[i/NSTEP, ] <- diag(CV)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

  IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

    if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

    x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

    T <- A$y
\end_layout

\begin_layout Plain Layout

    T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

    ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

    n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

    NL = length(T)
\end_layout

\begin_layout Plain Layout

    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

    return (T)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

  dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

  VCor <- vector ('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

  dim (VCor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

  X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

  for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

    VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ALTKF <- Data$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

  Data$VEWKF <- Data$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

  Data$VNSKF <- Data$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

  Data$VSPDKF <- Data$VSPD - Cor[, 6]
\end_layout

\begin_layout Plain Layout

  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$BLATAKF <- Data$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## smooth the pitch, roll, and heading corrections:
\end_layout

\begin_layout Plain Layout

  for (k in 7:9) {
\end_layout

\begin_layout Plain Layout

    Cor[, k] <- SmoothInterp (Cor[, k], .Length=1801)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  x <- XPitch(Data$PITCHL*Cradeg-Cor[,7], Data$ROLLL*Cradeg-Cor[,8], Data$THDG*C
radeg-Cor[,9], .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

  Data$PITCHKF <- x[,1]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$ROLLKF <- x[,2]/Cradeg
\end_layout

\begin_layout Plain Layout

  Data$THDGKF <- Data$THDG-Cor[,9]/Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$DLAT <- Data$LATKF-Data$GGLAT
\end_layout

\begin_layout Plain Layout

Data$CLAT <- -Cor[,1] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DLON <- Data$LONKF-Data$GGLON
\end_layout

\begin_layout Plain Layout

Data$CLON <- -Cor[,2] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DALT <- Data$ALTKF-Data$GGALT
\end_layout

\begin_layout Plain Layout

Data$CALT <- -Cor[,3]
\end_layout

\begin_layout Plain Layout

Data$DVEW <- Data$VEWKF-Data$GGVEW
\end_layout

\begin_layout Plain Layout

Data$CVEW <- -Cor[,4]
\end_layout

\begin_layout Plain Layout

Data$DVNS <- Data$VNSKF-Data$GGVNS
\end_layout

\begin_layout Plain Layout

Data$CVNS <- -Cor[,5]
\end_layout

\begin_layout Plain Layout

Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$CVSPD <- -Cor[,6]
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- Data$PITCHKF-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$CROLL <- Data$ROLLKF-Data$ROLL
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- Data$THDGKF-Data$THDG
\end_layout

\begin_layout Plain Layout

KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude,
 longitude, and altitude for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                    "Comparison of the KF, GPS, and INS values of aircraft-veloc
ity components for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines show the corrections
 applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                      "Pitch Correction from the Kalman filter (CPITCH,
 blue line) and from Ranadu::CorrectPitch (PC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Roll Correction from the Kalman filter (CROLL) and
 from Ranadu::CorrectPitch (RC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Heading Correction from the Kalman filter (CTHDG)
 and from Ranadu::CorrectHeading (HC, green line)")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
There are several tests that the corrected values should pass:
\end_layout

\begin_layout Enumerate
Because the GPS measurements of position and aircraft velocity have low
 uncertainty, the results from the Kalman filter should match the GPS-provided
 values for these variables in long-term average, perhaps with some high-frequen
cy components not present in the GPS-provided measurements.
\end_layout

\begin_layout Enumerate
The pitch-correction algorithm developed in the Technical Note on Wind Uncertain
ty should give results in reasonable agreement with the values of pitch
 and roll resulting from the Kalman filter.
\end_layout

\begin_layout Enumerate
The heading-correction algorithm developed previously should also produce
 results consistent with the results from the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=KalmanCaptions, cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch(Data, .span=601)
\end_layout

\begin_layout Plain Layout

Data$PC <- -PC[, 1]
\end_layout

\begin_layout Plain Layout

Data$RC <- -PC[, 2]
\end_layout

\begin_layout Plain Layout

## translate pitch/roll corrections to the a-frame:
\end_layout

\begin_layout Plain Layout

.hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

# CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# Data$CPITCH <- CPITCH / Cradeg
\end_layout

\begin_layout Plain Layout

# Data$CROLL <- CROLL / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- Data$PITCHKF-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$CROLL <- Data$ROLLKF-Data$ROLL
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- Data$THDGKF-Data$THDG
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
\end_layout

\begin_layout Plain Layout

## data processing introduced a shift of -0.08
\end_layout

\begin_layout Plain Layout

Data$HC <- CorrectHeading (Data, .plotfile='./HCPlot.pdf')
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 70000, 123000)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH
 CORRECTION',' [',degree,']')), ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

ival <- abs(Data$ROLL) > 4
\end_layout

\begin_layout Plain Layout

PE <- VCor[,7]
\end_layout

\begin_layout Plain Layout

PE[PE < 1.e-10] <- 1.e-10
\end_layout

\begin_layout Plain Layout

PE <- PE / 1015
\end_layout

\begin_layout Plain Layout

PE <- sqrt(PE)
\end_layout

\begin_layout Plain Layout

Data$CPITCH[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$PC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), ylab=expression(paste('ROLL
 CORRECTION [',degree,']')), ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

Data$CROLL[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$RC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylab=expression(paste('heading
 correction [',degree,']')), ylim=c(-0.15,0.15), lwd=0.7)
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

HE <- VCor[,9]
\end_layout

\begin_layout Plain Layout

HE[HE < 0.0025] <- 0.0025
\end_layout

\begin_layout Plain Layout

HE <- sqrt(HE)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

iv <- HE > 0.051
\end_layout

\begin_layout Plain Layout

CCTHDG <- Data$CTHDG
\end_layout

\begin_layout Plain Layout

CCTHDG[iv] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r]^2, spar=1.25)
\end_layout

\begin_layout Plain Layout

Data$HCS <- predict(SS, as.numeric(Data$Time))$y
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$HCS[r], col='red')
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)))
\end_layout

\begin_layout Plain Layout

Data$pitch_L <- Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$roll_L <- Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

plotWAC (subset(Data[r,],,c(Time, pitch_L, roll_L)), ylim=c(-0.05,0.05), ylab=expr
ession (paste ('correction [',degree,']')), main="l-frame pitch correction")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], (Cor[r,7]+PE[r])/Cradeg, col='darkorange', lwd=1)
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], (Cor[r,7]-PE[r])/Cradeg, col='darkorange', lwd=1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "WAC"
options "copernicus"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
– End of Memo –
\end_layout

\begin_layout Standard
Reproducibility:
\begin_inset Note Note
status open

\begin_layout Plain Layout
include enough info to re-run.
 in zip, include program, pdf if not too big, and subset data, not entire
 file.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.zip
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.Rnw
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

/scr/raf
\backslash
_data/
\backslash
Sexpr{Project}/
\backslash
Sexpr{Flight}.nc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.pdf
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/
\backslash
Sexpr{thisFileName}.git
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
