#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={Wind Uncertainty TN file}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A Kalman filter to apply corrections to the wind measurements
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilter"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/theme_WAC.R')
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/Ranadu/KalmanFilter')
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction and scope
\end_layout

\begin_layout Standard
The intent of this study is to evaluate the errors present in the measurements
 of attitude angles from the IRU on the NSF/NCAR
\begin_inset space ~
\end_inset

GV by means of a Kalman filter applied to the difference between measurements
 from a GPS and corresponding measurements from the IRU.
 The redundant measurements are those of position and velocity,
\begin_inset Foot
status open

\begin_layout Plain Layout
Because GPS measurements of velocity have low uncertainty, those measurements
 could be differentiated and, after transformation to the aircraft reference
 frame, used as error measurements for the measured accelerations.
\end_layout

\end_inset

 for which the GPS measurements are clearly superior especially at low rate,
 so a necessary result will be that the corrected measurements should be
 quite close to those from the GPS.
 The advantage of this analysis, though, is that the coupling between errors
 in the attitude angles and those in velocity makes it possible to evaluate
 the errors in the attitude angles.
\end_layout

\begin_layout Standard
Before describing the implementation of the filter, it is useful to explain
 the basic concept underlying a Kalman filter.
 A Kalman filter provides a means of updating a sequence of state vectors
 (consisting, in the present case, of INS measurements of position, velocity,
 and attitude angles) by comparison to an independent set of measurements
 (e.g., GPS-derived measurements of position and velocity).
 The updated state vector obtained by this process consists of an appropriately
 weighted combination of the state vector projected forward using normal
 INS 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 (i.e., determining the next step by using the measured acceleration and rotation
 from the IRU) and the independent measurements from GPS.
 Because errors in the state vector are coupled, the update procedure can
 estimate errors in the attitude angles as well as the components of the
 state vector that are measured directly by the GPS.
 This is the primary reason for using a Kalman filter to improve the wind
 measurements: Although the measurements of position and velocity that result
 should differ little from those provided by the GPS, the corrections to
 the attitude angles (pitch, roll, and heading) can be estimated even though
 there is no direct measurement of these except from the INS.
\end_layout

\begin_layout Standard
The weighting of the projected-forward state and new measurements from GPS
 depends on obtaining estimates of the covariance matrix describing the
 state vector as well as estimates of the noise sources contaminating the
 measurements from both the GPS and the IRU-provided accelerations and rotations.
 With proper weighting, the result should combine the good high-frequency
 response of the INS with the good long-term stability of the GPS.
 The covariance matrix characterizing the state vector is updated as the
 filter is applied, but appropriate weighting depends on reasonable estimation
 of the other error terms.
\end_layout

\begin_layout Standard
The operation of the filter depends on sequential use of a set of matrices,
 so it is useful to define those as follows, where the variable names following
 the symbols are the R variable names used in the following code:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{x}_{k}$
\end_inset


\begin_inset space ~
\end_inset

[SVE] The error-state vector at time index 
\begin_inset Formula $k$
\end_inset

.
 In the present case, this consists of these 15 components: estimated errors
 in position, aircraft velocity, aircraft attitude, IRU-measured rotation
 rate, and IRU-measured accelerations.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{T}_{k|k-1}$
\end_inset


\begin_inset space ~
\end_inset

[dcm] The 15x15 state transformation matrix describing INS mechanism for
 the change from time 
\begin_inset Formula $k-1$
\end_inset

 to time 
\begin_inset Formula $k$
\end_inset

.
 Then 
\begin_inset Formula $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
\end_inset

 where 
\begin_inset Formula $\mathbf{T}$
\end_inset

 combines the unit diagonal matrix with the time step multiplied by the
 derivative matrix describing the state transformation.
 As applied to the state vector, this state transformation matrix would
 involve the derivatives used for normal INS mechanization to get how the
 state vector advances, and so would duplicate the action of the internal
 INS data processing.
 As interpreted for an error-state Kalman filter, the matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is obtained by calculating the Jacobian of that state-transition function
 as a function of the error-state components.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{V}$
\end_inset


\begin_inset space ~
\end_inset

[CV] The covariance matrix that applies to the state vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

, a 15x15 matrix
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}$
\end_inset


\begin_inset space ~
\end_inset

[K] The Kalman-gain matrix representing how the error-state vector is updated
 using the current error state and the new GPS measurements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{z}$
\end_inset


\begin_inset space ~
\end_inset

[DZ] The 9-component measured differences between the INS and GPS measurements
 of position, velocity and acceleration.
 The latter three components are obtained by differentiating the GPS-provided
 velocity components.
 This differs from most conventional approaches but proves useful for contrainin
g the measurement of heading.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{H}$
\end_inset


\begin_inset space ~
\end_inset

[H] The 15x9-component matrix representing how the measured differences
 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 correspond to the state vector.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{Q},\,\mathbf{R}$
\end_inset


\begin_inset space ~
\end_inset

[Q,
\begin_inset space ~
\end_inset

R] Matrices representing respectively the anticipated noise contributions
 affecting the error-state vector (15x15) and the measurements from the
 GPS (9x9).
\end_layout

\begin_layout Standard
The approach taken here will be to filter the error-state vector that represents
 the difference between the best-estimate measurements and those originally
 provided by the INS.
 The INS integration does not need to be duplicated here to obtain the reference
 solution because that is already available.
 However, the Kalman filter does need the 
\begin_inset Quotes eld
\end_inset

state transition matrix
\begin_inset Quotes erd
\end_inset

 that represents the forward integration, so the first step in this analysis
 is to obtain such a matrix and validate results using it against the available
 INS solution.
 The Jacobian of that state-transition function then provides the matrix
 
\begin_inset Formula $\mathbf{T}$
\end_inset

 later used in this filter.
\end_layout

\begin_layout Section
Some component functions
\end_layout

\begin_layout Standard
Some of the operations involved in that 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 to replicate the operation of the INS are contained in the following functions,
 with code as in the associated R 
\begin_inset Quotes eld
\end_inset

chunks.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate

\emph on
\bar under
XfLArV()
\emph default
\bar default
, a function of the current state vector, provides a 3x3 matrix that transforms
 a vector from the a-frame (the aircraft reference frame) to the l-frame,
 the local-level frame (with {x,y,z} coordinates toward the East, North,
 and upward directions).
 
\end_layout

\begin_layout Enumerate

\emph on
\bar under
RotationCorrection()
\emph default
\bar default
 calculates the correction to accelerations needed to account for the rotation
 of the Earth and of the l-frame relative to an inertial frame.
 This function provides corrections to subtract from transformed accelerations
 before using them in the l-frame.
\end_layout

\begin_layout Enumerate

\emph on
\bar under
STMFV()
\emph default
\bar default
 calculates the 15-component derivative of the state vector given the state
 vector and the measurements from the INU.
 This function is then used in the R function numDeriv::jacobian to find
 the Jacobian needed later for the state transformation matrix used to construct
 the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XfLArV <- function (data) {   ## XfLA but using input in radians and single
 row
\end_layout

\begin_layout Plain Layout

  # data must contain PITCH, ROLL, HEADING as components [7:9]
\end_layout

\begin_layout Plain Layout

  cosphi <- cos (data[8])
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (data[8])
\end_layout

\begin_layout Plain Layout

  costheta <- cos (data[7])
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (data[7])
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (data[9])
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (data[9])
\end_layout

\begin_layout Plain Layout

  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-
sinpsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinph
i-cospsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           -sintheta, costheta*sinphi, -costheta*cosphi)
\end_layout

\begin_layout Plain Layout

  RblM <- aperm( array (Rbl, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  return (RblM)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# other-functions ---------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

dt <- 1/25               ## working with 25-Hz file
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

Ree <- 6378137
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

## The next correction calculates the correction needed to account for the
 rotation
\end_layout

\begin_layout Plain Layout

## of the Earth and of the l-frame (ENU frame).
 See Noureldin et al., 2013, 
\end_layout

\begin_layout Plain Layout

## Eqs.
 5.55--5.57.
 Subtract this from the transformed accelerations before using them.
\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  Ree <- 6378137
\end_layout

\begin_layout Plain Layout

  Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
\end_layout

\begin_layout Plain Layout

  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Gravity <- function (latitude, altitude=0.) {
\end_layout

\begin_layout Plain Layout

  sl2 <- (sin (latitude * Cradeg))^2
\end_layout

\begin_layout Plain Layout

  g <- 9.780327 * ((1.
 + 0.001931851 * sl2) / 
\end_layout

\begin_layout Plain Layout

                     (1.
 - 0.006694380 * sl2)) - 3.086e-6 * altitude
\end_layout

\begin_layout Plain Layout

  ## Somigliana formula 1980 GRS:
\end_layout

\begin_layout Plain Layout

  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
\end_layout

\begin_layout Plain Layout

  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 *
 altitude^2
\end_layout

\begin_layout Plain Layout

  return(g)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

# The following is commented because it is already in the Somagliana equation
\end_layout

\begin_layout Plain Layout

# Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
\end_layout

\begin_layout Plain Layout

#   (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

############# this function calculates the derivatives of the state vector
 ###########
\end_layout

\begin_layout Plain Layout

STMFV <- function (sv, .aaframe='a') { 
\end_layout

\begin_layout Plain Layout

  stmf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  ## transform back to a-frame if necessary
\end_layout

\begin_layout Plain Layout

  if (.aaframe == 'l') {  ## if pitch/roll are in l-frame, translate to a-frame
\end_layout

\begin_layout Plain Layout

    svs7 <- sv[7]
\end_layout

\begin_layout Plain Layout

    svs8 <- sv[8]
\end_layout

\begin_layout Plain Layout

    sv[7] <- cos (sv[9]) * svs7 - sin (sv[9]) * svs8
\end_layout

\begin_layout Plain Layout

    sv[8] <- sin (sv[9]) * svs7 + cos (sv[9]) * svs8
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  rlm <- XfLArV(sv)    
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/(Rn),
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
\end_layout

\begin_layout Plain Layout

  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2],
 omega[1], 0), ncol=3)
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  ## find the derivative of the transformation matrix:
\end_layout

\begin_layout Plain Layout

  ## (must recalculate SRM from measured rotation rates)
\end_layout

\begin_layout Plain Layout

  SRR <- c(0, -sv[12], -sv[10],
\end_layout

\begin_layout Plain Layout

           sv[12], 0, sv[11],
\end_layout

\begin_layout Plain Layout

           sv[10], -sv[11], 0)
\end_layout

\begin_layout Plain Layout

  SRM <- aperm( array (SRR, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  dRLA <- rlm %*% SRM - Oilb
\end_layout

\begin_layout Plain Layout

  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
\end_layout

\begin_layout Plain Layout

  Grav <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch
 and roll!
\end_layout

\begin_layout Plain Layout

  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-fra
me
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
\end_layout

\begin_layout Plain Layout

  ## now correct for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  VL <- c(sv[4], sv[5], sv[6])
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3)
\end_layout

\begin_layout Plain Layout

  lat <- sv[1]
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  C[1] <- M12 * VL[2] + M13 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[2] <- M21 * VL[1] + M23 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[3] <- M31 * VL[1] + M32 * VL[2]
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (AL - C, mode='numeric')
\end_layout

\begin_layout Plain Layout

  AL[3] <- AL[3] + Grav
\end_layout

\begin_layout Plain Layout

  AL[3] <- -AL[3]
\end_layout

\begin_layout Plain Layout

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
\end_layout

\begin_layout Plain Layout

              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
\end_layout

\begin_layout Plain Layout

              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
\end_layout

\begin_layout Plain Layout

            0, 0, 0, 0, 0, 0)
\end_layout

\begin_layout Plain Layout

  ## return sv to original if necessary
\end_layout

\begin_layout Plain Layout

  if (.aaframe == 'l') {
\end_layout

\begin_layout Plain Layout

    sv[7] <- svs7
\end_layout

\begin_layout Plain Layout

    sv[8] <- svs8
\end_layout

\begin_layout Plain Layout

    stmf7 <- stmf[7]
\end_layout

\begin_layout Plain Layout

    stmf[7] <- cos(sv[9])*stmf7 + sin(sv[9])*stmf[8]
\end_layout

\begin_layout Plain Layout

    stmf[8] <- -sin(sv[9])*stmf7 + cos(sv[9])*stmf[8]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (as.vector (stmf, mode='numeric'))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR + 0.0005
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

# SP$BLATA <- SP$BLATA * 1.1
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
The integration steps
\end_layout

\begin_layout Standard
The purpose of this section is to demonstrate that the calculated derivatives
 of the INS-provided variables lead to a reasonable 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 that approximately duplicates the original calculations from the INS.
 It is not necessary or expected that this mechanization will duplicate
 that from the INS with high precision because the INS has information and
 high-rate data not available to this new calculation.
 However, if the results are reasonably close to those from the INS then
 that provides some evidence that the derivatives being calculated are reeasonab
ly close to the correct values.
 These derivatives will then be used in the implementation of the Kalman
 filter, where the filter will adjust to compensate for remaining errors
 in these derivatives.
 
\end_layout

\begin_layout Standard
The procedure used to produce variables corresponding to position, velocity,
 and attitude angles for this test is as follows:
\end_layout

\begin_layout Enumerate
Initialize a state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

 having these components:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the l-frame
\end_layout

\begin_layout Enumerate
east velocity, north velocity, upward velocity in the l-frame
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the a-frame
\begin_inset Foot
status open

\begin_layout Plain Layout
With appropriate transformations these calculations of attitude angles can
 be performed in the l-frame instead, and there are some advantages because
 the l-frame values of errors in pitch and roll, respectively representing
 southward and westward tilts of the inertial platform, are not mixed together
 when the heading changes as they are in the a-frame.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
rotation rates about the pitch, roll, and yaw axes of the aircraft
\end_layout

\begin_layout Enumerate
acceleration in the lateral, longitudinal, and normal direction relative
 to the aircraft reference frame.
\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
store the measured rotations and accelerations in the last 6 components
 of the state vector
\end_layout

\begin_layout Enumerate
via the function STMFV, calculated the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the a-frame to the l-frame and then using
 the definition of components of that matrix to find the derivative of the
 attitude angles.
\end_layout

\begin_layout Enumerate
use that derivative vector to increment the state vector
\end_layout

\begin_layout Enumerate
compensate for possible wrap-around of the heading a 0 and 360 deg so that
 values stay within that range.
\end_layout

\begin_layout Enumerate
save the first 9 components of the state vector in a new data.frame that
 represents an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the INS
 solution.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' ', cache=TRUE>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH,
 ROLL, THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$GGALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

Rn <- SP$Rn[1]
\end_layout

\begin_layout Plain Layout

Rm <- SP$Rm[1]
\end_layout

\begin_layout Plain Layout

Grav <- SP$Grav[1]
\end_layout

\begin_layout Plain Layout

stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

## feedback coefficients for baro loop:
\end_layout

\begin_layout Plain Layout

C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
\end_layout

\begin_layout Plain Layout

wp3F <- 0;
\end_layout

\begin_layout Plain Layout

hxF <- hxxF <- 0
\end_layout

\begin_layout Plain Layout

hi3F <- SP$GGALT[1]
\end_layout

\begin_layout Plain Layout

RK <- TRUE    ## use Runge-Kutta integration if true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (i in 2:DL) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i]
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i]
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i]
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  if (RK) {
\end_layout

\begin_layout Plain Layout

    stmf1 <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

    sv1 <- sv + stmf1 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf2 <- STMFV (sv1)
\end_layout

\begin_layout Plain Layout

    sv2 <- sv + stmf2 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf3 <- STMFV (sv2)
\end_layout

\begin_layout Plain Layout

    sv3 <- sv + stmf3 * dt
\end_layout

\begin_layout Plain Layout

    stmf4 <- STMFV (sv3)
\end_layout

\begin_layout Plain Layout

    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  ## baro-loop
\end_layout

\begin_layout Plain Layout

  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
\end_layout

\begin_layout Plain Layout

  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
\end_layout

\begin_layout Plain Layout

  hxF <- hi3F - SP$GGALT[i]
\end_layout

\begin_layout Plain Layout

  hxxF <- hxxF + hxF * dt
\end_layout

\begin_layout Plain Layout

  sv[6] <- 0.5 * (sv[6] + wp3F)
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparis
on of INS-provided and integration-derived positions.', 'Comparison of INS-provid
ed and integration-derived components of the aircraft velocity.', 'Comparison
 of INS-provided and integration-derived attitude angles.')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 33000, 35500)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LON', 'LONX')])
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
\end_layout

\begin_layout Plain Layout

## find attitude angles from RaLM:
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
\end_layout

\begin_layout Plain Layout

lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

SP <- SPR    ## restore to state before integration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result of that integration is compared to the INS-produced solution
 in Figs.
\begin_inset space ~
\end_inset

1â€“3.
 There are some differences, but they are mostly understandable and could
 be corrected.
 For example, the attitude angles show sine-wave differences during the
 circles flown during this time segment and suggest a timing error that
 causes one signal to be delayed relative to the comparable signal.
 The INS-produced solution for altitude has a baro-loop applied to keep
 the altitude near the pressure altitude, and that is not applied in this
 solution so the vertical wind and position show large drifts.
 Perhaps the one aspect that is troublesome is that in VNS and consequently
 in latitude.
 Also, the data used here are the 25-Hz records, while the INS uses a higher
 data rate for its corresponding integration.
 The remaining differences need further investigation, but the key result
 from this part of the study is that as implemented above the derivatives
 of components of the state vector are approximately correct and integrate
 to reasonable values.
 The function providing those derivatives is therefore a reasonable basis
 for the Kalman filter that follows.
\end_layout

\begin_layout Section
The Kalman filter
\end_layout

\begin_layout Standard
The preceding steps verify that at least an approximate calculation of the
 derivatives of the state variables is available.
 On that basis, an error-state Kalman filter can be developed, as follows:
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Before presenting that development, however, it is necessary to discuss
 two aspects of the Kalman filter developed here: 
\end_layout

\begin_layout Enumerate
Errors in the pitch and roll angles represent errors in the calculated level
 position of the IRU.
 For a fixed orientation error, when the aircraft turns, the errors in pitch
 and roll intermix, with for example a pitch error during northbound flight
 becoming a roll error during eastbound flight while the roll error becomes
 a pitch error.
 If a Kalman filter is implemented with error terms for pitch and roll in
 the a-frame, there will be large transient errors arising from course changes
 that must be corrected via the Kalman filter, whereas if the filter is
 implemented with errors in the l-frame the respective north and east components
 of the attitude-angle errors remain approximately constant.
 For this reason, it is preferable to implement the filter using attitude-angle
 errors as they appear in the l-frame.
 The correction terms developed by the Kalman filter must then be transformed
 back to the a-frame before they are applied to the measurements of pitch
 and roll.
 
\end_layout

\begin_layout Enumerate
Conventional implementations of Kalman-filter updating use the measurements
 of position and velocity from the GPS receiver as the external measurements
 to which the INS measurements are compared.
 This works well for all but the heading measurement.
 A heading error results in erroneous resolution of measured accelerations
 into l-frame components and so to errors in velocity, but the feedback
 of these errors to heading is slow and noisy.
 Therefore, a more direct method of coupling GPS-derived measurements to
 heading errors will be used by differentiating the GPS-measured valocities
 to obtain independent measurements of acceleration and then using these
 measured l-frame accelerations as additional measurements to be compared
 to the INS solution.
 If there is an error in heading, these accelerations will lead to a difference
 between the GPS-derived direction of l-frame acceleration and the INS-derived
 direction, and this can be considered a direct measurement of heading error.
 Except in turns, the measured l-frame acceleration is too small and noisy
 for this to be effective, but turns produce strong signals and consequent
 constraints on the heading error.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The Kalman filter is then constructed as follows:
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position and velocity.
 Other errors in components of the state vector are unknown at the start
 of the integration and so will be initialized as zero.
 The 15-component vector used here contains the respective errors in latitude,
 longitude, altitude, eastward ground speed, northward ground speed, rate
 of climb, pitch, roll, heading, pitch-axis rotation rate, roll-axis rotation
 rate, yaw-axis rotation rate, lateral component of acceleration, longitudinal
 component of acceleration, and normal component of acceleration.
\end_layout

\begin_layout Enumerate
The covariance matrix 
\begin_inset Formula $\mathbf{V}$
\end_inset

 characterizing the errors in the error-state-vector is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components and that will constrain the covariance matrix
 during the calculation.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\lambda$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units except those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth and 
\begin_inset Formula $\lambda$
\end_inset

 is the latitude.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides at least an approximate
 calculation of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function of the state vector, so the
 error-state transition matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is the sum of that Jacobian (multiplied by the time step) and the 15-element
 diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF.
 The results can be sensitively dependent on these values, and the choices
 made here are the result of tuning to find a set of values that provides
 reasonable results.
 The 15 values used are the squares of the following: {30/
\begin_inset Formula $R_{m}$
\end_inset

, 30/
\begin_inset Formula $(R_{n}\cos\lambda$
\end_inset

), 150, 0.3, 0.3, 0.3, 0.005
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}$
\end_inset

, 0.05
\begin_inset Formula $^{\circ}$
\end_inset

, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.00002
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

}.
 All units are SI units except for those labeled as degrees, and in those
 cases the values are converted to radians before use.
 These values are used with a 5-s time step, and they may need adjustment
 if a different time step is used.
 The very low value representing noise in the measured accelerations had
 a significant effect on the results.
 Larger values tended to degrade the results for the attitude angles, presumably
 because errors could be attributed to errors in measured accelerations.
 The results from this particular filter will then rely on the assumption
 that, for the most part, errors in acceleration are not significant.
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are known, the covariance matrix can be updated each time step via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X6 diagonal matrix representing how the six measured differences
 (GPS-INS) correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise-covariance matrix representing the GPS noise,
 a 6x6 matrix having diagonal elements that are the squares of these components:
 {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1}.
\begin_inset Foot
status open

\begin_layout Plain Layout
Four additional measurements were explored for inclusion, the three measurements
 of acceleration determined by differentiating the measurements of velocity
 components from the GPS receiver and a representation of heading error
 derived from the difference between the angle determined by transforming
 measured accelerations to the l-frame and the corresponding angle determined
 from the GPS-derived horizontal components of the acceleration.
 These complicate the tuning and will not be discussed in this report.
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
Define 
\series bold

\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 
\series default
as the set of nine measurements consisting of the differences between GPS
 and INS positions and velocities.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate because it is expected that the errors vary slowly.
 However, turns and other maneuvers can introduce spurious effects if time
 delays are not adjusted well.
 For these reasons, a 1-Hz data file will be used for the following example,
 and the measurements of components of the velocity and of the attitude
 angles as well as the rotation rates and accelerations will be shifted
 in time where needed and then smoothed before applying the Kalman filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-s smoothing of accelerations and 301-s smoothing of measured velocity
 components and attitude angles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, echo=FALSE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 			
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"     		
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%srf%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

D1 <- getNetCDF (fname, c(VarList, 'PSXC', 'ATX', 'ACINS'))
\end_layout

\begin_layout Plain Layout

## remove heading adjustments as added during initial processing
\end_layout

\begin_layout Plain Layout

Z <- data.frame(getAttributes(D1$THDG, .print=FALSE))
\end_layout

\begin_layout Plain Layout

if ('CalibrationCoefficients' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

  THDGoffset <- Z$CalibrationCoefficients[1]
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  THDGoffset <- 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if ('TimeLag' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

  D1$THDG <- ShiftInTime(D1$THDG, -Z$TimeLag[1])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

D1$THDG <- (D1$THDG - THDGoffset) %% 360
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

# D1$BYAWR <- D1$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

# D1$BROLLR <- D1$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

# D1$BPITCHR <- D1$BPITCHR + 0.0005
\end_layout

\begin_layout Plain Layout

# D1$BNORMA <- D1$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# D1$BLONGA <- D1$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

# D1$BLATA <- D1$BLATA * 1.1
\end_layout

\begin_layout Plain Layout

s <- -120
\end_layout

\begin_layout Plain Layout

# s <- -92
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

SHIFT <- FALSE
\end_layout

\begin_layout Plain Layout

SHIFT <- TRUE
\end_layout

\begin_layout Plain Layout

if (SHIFT) {
\end_layout

\begin_layout Plain Layout

  D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  # D1$BLONGA <- ShiftInTime (D1$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # D1$BLATA <- ShiftInTime (D1$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # D1$BNORMA <- ShiftInTime (D1$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$DPDT <- c(0, diff(D1$PSXC))
\end_layout

\begin_layout Plain Layout

Rd <- StandardConstant('Rd')
\end_layout

\begin_layout Plain Layout

TK <- 273.15 + D1$ATX
\end_layout

\begin_layout Plain Layout

g <- 9.80
\end_layout

\begin_layout Plain Layout

D1$WPPRIME <- -Rd * TK / (D1$PSXC * g) * D1$DPDT
\end_layout

\begin_layout Plain Layout

D1$WPSTAR <- cumsum(D1$ACINS)
\end_layout

\begin_layout Plain Layout

D1$DIF <- D1$WPPRIME - D1$WPSTAR
\end_layout

\begin_layout Plain Layout

D1$DIF <- zoo::na.approx (as.vector(D1$DIF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

tau <- 300
\end_layout

\begin_layout Plain Layout

D1$DIFW <- signal::filter (signal::butter (3, 2/tau), D1$DIF)
\end_layout

\begin_layout Plain Layout

D1$ROC <- D1$WPSTAR + D1$DIFW
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dt <- 1    ## this is a 1-Hz file
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

## the following is commented because the centripetal effect is already
 included in 'Gravity()'
\end_layout

\begin_layout Plain Layout

# Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT *
 Cradeg)^2 + D1$GGALT)
\end_layout

\begin_layout Plain Layout

#interpolate if necessary: otherwise later filters fail
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

D1$GGVNS <- ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGVEW <- ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGVSPD <- ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D1$VNS <- vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm =
 FALSE)
\end_layout

\begin_layout Plain Layout

D1$VEW <- vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm =
 FALSE)
\end_layout

\begin_layout Plain Layout

D1$VSPD <- vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

## smooth the measurements when determining derivatives
\end_layout

\begin_layout Plain Layout

.span <- 11    
\end_layout

\begin_layout Plain Layout

## The following are accelerations determined from derivatives of the GPS
 velocities.
\end_layout

\begin_layout Plain Layout

## These should match the measured accelerations after transformation to
 the l-frame
\end_layout

\begin_layout Plain Layout

## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

D1$vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

D1$vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

D1$vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

G <- D1$Grav
\end_layout

\begin_layout Plain Layout

VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection
 (D1, VL)
\end_layout

\begin_layout Plain Layout

AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

fa3 <- lm(D1$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

AL <- AL + RotationCorrection (D1, VL)  ##### check this sign and prev call
 above
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

.span <- 301
\end_layout

\begin_layout Plain Layout

SMOOTH <- FALSE
\end_layout

\begin_layout Plain Layout

if (SMOOTH) {
\end_layout

\begin_layout Plain Layout

  vns <- signal::sgolayfilt (vns, 3, .span)
\end_layout

\begin_layout Plain Layout

  vew <- signal::sgolayfilt (vew, 3, .span)
\end_layout

\begin_layout Plain Layout

  vspd <- signal::sgolayfilt (vspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
\end_layout

\begin_layout Plain Layout

  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
\end_layout

\begin_layout Plain Layout

  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  D1$VNSF <- vns
\end_layout

\begin_layout Plain Layout

  D1$VEWF <- vew
\end_layout

\begin_layout Plain Layout

  D1$VSPDF <- vspd
\end_layout

\begin_layout Plain Layout

  D1$GGVNSF <- ggvns
\end_layout

\begin_layout Plain Layout

  D1$GGVEWF <- ggvew
\end_layout

\begin_layout Plain Layout

  D1$GGVSPDF <- ggvspd
\end_layout

\begin_layout Plain Layout

  D1$PITCHF <- pitch
\end_layout

\begin_layout Plain Layout

  D1$ROLLF <- roll
\end_layout

\begin_layout Plain Layout

  D1$THDGF <- thdg
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## get the pitch and roll in the l-frame:
\end_layout

\begin_layout Plain Layout

.thdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

D1$PITCHL <- D1$PITCH * cos (.thdg) + D1$ROLL * sin (.thdg)
\end_layout

\begin_layout Plain Layout

D1$ROLLL <-  -D1$PITCH * sin (.thdg) + D1$ROLL * cos (.thdg)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fm1 <- lm (D1$vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (D1$vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (D1$vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the a-frame and compared to the measured accelerat
ions from the IRU (with correction for the Earth's rotation and the motion
 of the l-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

., with a residual standard error of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The differentiated measurements of velocity components from the GPS can
 be considered as additional measurements corresponding to the measured
 accelerations.
 This is discussed further in the following sections.
\end_layout

\begin_layout Subsection
Detecting the error in heading
\begin_inset CommandInset label
LatexCommand label
name "subsec:heading-error"

\end_inset


\end_layout

\begin_layout Standard
Most of the components of the state vector have good feedback from GPS-derived
 measurements, but an exception is the measurement of heading.
 For position and velocity, there is direct correspondence between INS-
 and GPS-derived measurements.
 For pitch and roll, there is strong coupling to errors in the eastward
 and northward components of aircraft velocity.
 However, the coupling of INS-measured heading to GPS observations is not
 a case of strong coupling (to which the Schuler oscillation applies), and
 it is more difficult to update via measurements from the GPS receiver.
 
\end_layout

\begin_layout Standard
As specified above, the differentiated GPS velocities provide an l-frame
 measurement of acceleration, and these can be transformed back to the a-frame
 to provide measurements that correspond to BLATA, BLONGA, and BNORMA.
 However, a difference in a-frame accelerations from the two sources can
 arise not only from errors in the measured accelerations but also (and
 more likely) from an error in heading, which would cause incorrect translation
 between l-frame and a-frame components.
 The source of coupling between GPS-derived measurements and heading is
 via the aircraft-velocity components, because an error in heading causes
 the IRU-measured accelerations to be resolved into the 
\emph on
l-
\emph default
frame incorrectly and so introduces errors in the aircraft-velocity components
 that can be detected via comparison to GPS-provided velocity components.
 Unfortunately, in most cases the measured accelerations are small, resulting
 in large uncertainties in any correction term except during turns.
 
\end_layout

\begin_layout Standard
For these reasons, it is useful to treat heading differently.
 Most of the evidence from filghts that have been examined suggests that
 the heading error is small and changes little during the flight.
 However, the Kalman filter often leads to significant variations (often
 0.2
\begin_inset Formula $^{\circ}$
\end_inset

 or more) accompanied by large variances (of similar magnitude or larger)
 that call the varying result into question.
 The only periods when the heading error is constrained well is during turns,
 when there are significant horizontal accelerations.
 With strong accelerations, the direction of the acceleration is determined
 well and an error in heading leads to errors in how those accelerations
 are translated into the l-frame where they affect the ground-speed vector,
 leading to errors in that vector that can be detected by the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are three possible approaches, all of which have been tried in this
 study:
\end_layout

\begin_layout Enumerate
The Kalman-filter structure as described above will use the errors in velocity
 to correct the state vector.
 Via the derivative coefficient matrix, the horizontal-velocity errors are
 dependent on errors in horizontal-acceleration as well as on attitude-angle
 errors, esp.
\begin_inset space ~
\end_inset

via strong coupling to the errors in roll and pitch.
 The coupling to heading is typically an order of magnitude weaker.
 Without special attention, the coupling to heading potentially can be obscured
 by the other sensitivities, through which the errors in velocity can be
 attributed to error-state components in horizontal acceleration and in
 roll and pitch.
 In turn, an error in heading is dependent mostly on errors in the gyro
 rotation rates.
 These sensitivities make it difficult to obtain a reliable adjustment of
 heading in the standard approach, although an estimate can be obtained.
\end_layout

\begin_layout Enumerate
The 
\emph on
l-
\emph default
frame accelerations measured by differentiating the GPS-derived horizontal
 velocity components can be used as additional components of the observation
 vector, complementing the position and velocity measurements from GPS.
 These accelerations can then be used as independent measurements of acceleratio
n.
 While this provides some additional adjustable parameters for the filter
 associated with the covariances of the GPS-derived accelerations, the errors
 in acceleration can still be attributed to errors in the measured accelerations.
 This seems to add little to the sensitivity, and indeed in tests this led
 to changes in pitch and roll corrections that appeared to produce degraded
 results.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To illustrate the problem, consider the measured horizontal-acceleration
 vector obtained by transforming the measured 
\emph on
a-
\emph default
frame accelerations to the 
\emph on
l-
\emph default
frame.
 If there is no heading error, the azimuth angle corresponding to this l-frame
 vector acceleration should be the same as the azimuth angle of the vector
 acceleration determined by differentiating the GPS-measured components
 of horizontal velocity.
 The difference is a measure of the heading error: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}

\end_inset

where 
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

 and 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

 are the 
\emph on
l-
\emph default
frame accelerations obtained by transforming the IRU-measured accelerations
 from the 
\emph on
a-
\emph default
frame to the 
\emph on
l-
\emph default
frame and 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

 are the eastward and northward components of the acceleration obtained
 from the time-derivatives of the GPS-measured eastward and northward velocity
 components 
\begin_inset Formula $v_{e}$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

.
 The assumption made when using this formula is that the errors in the INS-produ
ced accelerations in the 
\emph on
l-
\emph default
frame arise from the heading error with negligible contribution from errors
 in the accelerometers themselves.
 If this is the case, it would be possible to base the heading correction
 on this formula alone, but the more general case needs to consider how
 this might be influenced by errors in accelerations.
 Appropriately incorporating this measurement of heading error into the
 Kalman filter would allow for the possibility that measured accelerations
 as well as the heading need to be adjusted.
\end_layout

\begin_layout Standard
Because significant horizontal accelerations occur mostly in turns when
 both angles in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) are changing rapidly, it is very important to have correct relative timing
 between the INS measurement of heading and the GPS measurement of velocity.
\begin_inset Foot
status open

\begin_layout Plain Layout
As an illustration, a 50-ms delay in heading during a 3-min turn causes
 a shift in heading relative to the correct time of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

, so adjustment to at least this uncertainty is desirable.
 
\end_layout

\end_inset

 The GPS measurements are assigned correct times by the GPS receiver and
 represent a standard clock against which to compare other measurements.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that the relative timing between the IRU and the GPS can drift
 enough during some flights to introduce significant errors.
\end_layout

\end_inset

 If the GPS-vs-INS time shift is not removed, a bias will be introduced
 into the heading correction that varies with turn direction.
 Therefore the following procedure will be followed to remove this time
 shift:
\end_layout

\begin_layout Enumerate
Differentiate the GPS-provided measurements to obtain 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Transform the unshifted body accelerations to the 
\emph on
l-
\emph default
frame, with rotation corrections, to obtain the eastward and northward component
s of acceleration (
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

, 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

) in the local-level frame.
 
\end_layout

\begin_layout Enumerate
Find the heading correction for unshifted measurements by calculating 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

).
\end_layout

\begin_layout Enumerate
Calculate the running-standard-deviation of 
\begin_inset Formula $\delta\psi$
\end_inset

 spanning 30 seconds.
 Select the subset of 
\begin_inset Formula $\delta\psi$
\end_inset

 for which that standard deviation is less than 0.2
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fit the subset to find the slope 
\begin_inset Formula $b$
\end_inset

 in the relationship 
\begin_inset Formula $\delta\psi=a+b\thinspace\tan\phi$
\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle.
 The rate of turn 
\begin_inset Formula $R$
\end_inset

 is related to the roll angle 
\begin_inset Formula $\phi$
\end_inset

 according to the relationship 
\begin_inset Formula $R=g\thinspace\tan\phi/V$
\end_inset

 where 
\begin_inset Formula $V$
\end_inset

 is the airspeed, so 
\begin_inset Formula $\tan\phi=RV/g$
\end_inset

 and 
\begin_inset Formula $\delta\psi=a+bRV/g$
\end_inset

.
 A time delay of 
\begin_inset Formula $\delta t$
\end_inset

 produces a heading error of 
\begin_inset Formula $-R\delta t$
\end_inset

, so 
\begin_inset Formula $-R\delta t=a+bRV/g$
\end_inset

 and the time shift can be estimated from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta t=-b\frac{V}{g}\,\,\,\,.\label{eq:deltaT}
\end{equation}

\end_inset

For example, for DEEPWAVE flight 16, 
\begin_inset Formula $b=0.2146^{\circ}$
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 = 0.003745
\begin_inset space \thinspace{}
\end_inset

rad
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and 
\begin_inset Formula $V\simeq240$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, so (with g=9.8
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

) 
\begin_inset Formula $\delta t=$
\end_inset

-0.092
\begin_inset space ~
\end_inset

s.
 The negative sign indicates that the INS-derived measurement of heading
 appears to be shifted backward (earlier) in time by 92
\begin_inset space \thinspace{}
\end_inset

ms relative to the GPS-derived measurements of aircraft velocity.
 The standard error from the fit indicates that this shift was determined
 with an uncertainty of about 3
\begin_inset space \thinspace{}
\end_inset

ms, so this is a very sensitive way to determine the time shift.
 Note that the result is not influenced by a real error in heading.
\end_layout

\begin_layout Enumerate
Apply this time shift to the measurements of ground speed from the GPS (GGVEW
 and GGVNS), in this case shifting them backward (earlier) in time by 92
\begin_inset space ~
\end_inset

ms while leaving the heading unshifted.
\begin_inset Foot
status open

\begin_layout Plain Layout
The reason that it is preferable to shift GGVEW and GGVNS rather than THDG
 is that it is common in processed files for heading to already be shifted.
 In the case discussed here, heading was already shifted by 
\begin_inset Formula $-80$
\end_inset


\begin_inset space ~
\end_inset

ms.
 However, this was done after processing by the INS, so measurements like
 VEW and VNS have been determined with the heading as used inteernally by
 the INS, not as shifted during subsequent processing.
 The feedback provided by the Kalman filter then relies on the heading before
 shifting, and subsequent shifting of the heading has no effect on those
 measurements.
 It does affect the recalculated transformation from a-frame to l-frame,
 so there would be an inconsistency between (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) and other estimates of the heading error arising from the Kalman filter.
\end_layout

\end_inset

 For a file containing measurements at 1
\begin_inset space ~
\end_inset

Hz, this requires creating an interpolated high-rate vector of measurements,
 shifting that vector, and then extracting a shifted 1-Hz vector from the
 shifted measurements.
 The Ranadu function ShiftInTime() accomplishes this by interpolating to
 a 125-Hz variable.
 The result can be checked by repeating step 5 using the shifted measurements;
 for this case, the deduced shift needed for the shifted time series was
 only 1
\begin_inset space ~
\end_inset

ms.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It may be useful to incorporate in addition a time dependence, either to
 the time shift or to the correction factor.
 Preliminary study of this indicates that a time dependence is significant,
 as represented for example via he~tan(ROLL)+Ts where Ts=as.vector(Data$Time-Data
$Time[1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After an appropriate time shift is introduced, (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is an appropriate measurement of heading error to include in the error-measure
ment vector 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

.
 Here, that is accomplished by adding a seventh component to the measurement
 vector and a seventh row to
\begin_inset Formula $\mathbf{H}$
\end_inset

, where a matrix element 1 then appears in row 7, column 9.
 should have contributions from rows 7 and 8.
 Formulated in this way, the dependence is complex and non-linear, so it
 is simpler to add a 10th component to the measurement vector with value
 given by 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) and associate that directly (with coefficient 1 after appropriate conversion
 from radians to degrees) with column 9 of the information matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, which then must have 10 rows and 15 columns.
\end_layout

\begin_layout Standard
Because typical horizontal accelerations in the l-frame are small, this
 estimate of the heading error is too noisy to be useful except in turns
 where the horizontal accelerations are significant, often about 3
\begin_inset space ~
\end_inset

m/s
\begin_inset Formula $^{2}$
\end_inset

.
 In normal straight flight, the standard deviation in the estimate obtained
 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is around 15
\begin_inset Formula $^{\circ}$
\end_inset

, but in turns this standard deviation reduces to typically about 0.15
\begin_inset Formula $^{\circ}$
\end_inset

.
 This has two important consequences.
 First, flights without turns or other sources of horizontal acceleration
 will lack the information for adjusting the heading.
 so in flights where good wind measurements are important regular turns
 should be part of the flight plans.
 Second, when the GPS-based estimate of the heading error is used, an appropriat
e variance should be assigned to prevent excessive noise from affecting
 the result from the Kalman filter and it will be best to suppress updating
 to the GPS result except when horizontal accelerations are significant
 (perhaps >1
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

).
 For the flight being used as an example, the mean and standard deviation
 of the correction from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) for all cases where the horizontal accelerations exceed this criterion
 are 0.003
\begin_inset Formula $\pm0.15{}^{\circ}$
\end_inset

 for 4295 1-Hz measurements, and the mean error is determined to about 0.002
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Subsection
Smoothing the errors in pitch and roll
\begin_inset CommandInset label
LatexCommand label
name "subsec:Smoothing-the-errors"

\end_inset


\end_layout

\begin_layout Standard
Because the errors in pitch and roll are strongly coupled to the errors
 in velocity, good estimates of these errors should arise naturally from
 the Kalman filter.
 However, the errors so obtained are sometimes noisy in comparison to the
 direct measurements, so application of those corrections will introduce
 undesirable noise into the results from the filter.
 Because it i8s expected that the main source of error is reflected in the
 slowly varying Schuler oscillation, it is preferable to smooth the corrections
 before application to the original measurements to avoid the introduction
 of noise.
 As described above, the errors in pitch and roll are those that apply to
 the original measurements in the a-frame.
 However, if a major source of those errors is platform misalignment that
 varies slowly, the errors will vary smoothly in the l-frame, where l-frame
 pitch error refers to platform north-south tilt and l-frame roll error
 refers to platform east-west tilt.
 In the a-frame, each turn leads to mixing of the pitch and roll errors
 and to abrupt changes, so smoothing in the l-frame followed by transformation
 back to the a-frame produces a better result.
 This will be discussed further after the results from the Kalman filter
 are presented.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, but this will not be part of this initial study because the accelerometers
 appear to have low uncertainty and because the effect of errors in acceleration
 would also appear as errors in velocity and so should be detected by the
 conventional 6-component measurement vector for Kalman filtering.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initial values of the state vector and error-state vector:
\end_layout

\begin_layout Plain Layout

SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

## also need the corresponding noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data
 record
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 30 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 30 / (sp$Rn * cos (sv$LAT))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 150
\end_layout

\begin_layout Plain Layout

  gcf[4:6] <- 0.3    ## 0.3
\end_layout

\begin_layout Plain Layout

  gcf[7:8] <- 0.005*Cradeg  ## 0.005
\end_layout

\begin_layout Plain Layout

  gcf[9] <- 0.05*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[10:11] <- 0.003*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[12] <- 0.003*Cradeg       ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.00002
\end_layout

\begin_layout Plain Layout

  # gcf <- as.vector(gcf) * sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[1, ]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model: calculate the measurements of acceleration from
 the GPS to add to the measurement vector
\end_layout

\begin_layout Plain Layout

GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
\end_layout

\begin_layout Plain Layout

dim(GAEL) <- c(DL, 3)
\end_layout

\begin_layout Plain Layout

## transform to the a-frame
\end_layout

\begin_layout Plain Layout

GAE <- XformLA (D1, GAEL, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS,
 ROC-GGVSPD))
\end_layout

\begin_layout Plain Layout

# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later
\end_layout

\begin_layout Plain Layout

## The last three components provide direct feedback to measured acceleration
\end_layout

\begin_layout Plain Layout

## in the a-frame but also provide feedback to heading, as developed below
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 9)
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 6)
\end_layout

\begin_layout Plain Layout

# DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

## now add the pseudo-measurement of heading error found from the accelerations:
\end_layout

\begin_layout Plain Layout

D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
\end_layout

\begin_layout Plain Layout

D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the
 std dev
\end_layout

\begin_layout Plain Layout

## add the heading correction to the measurement vector
\end_layout

\begin_layout Plain Layout

DZ <- c(as.vector(DZ), D1$deltaPsi)
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 7)
\end_layout

\begin_layout Plain Layout

DZ[ ,1:2] <- DZ[ ,1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The observation matrix: (the first six and last three components of the
 state error 
\end_layout

\begin_layout Plain Layout

## vector are observable, the latter requiring transformation from l-frame
 to a-frame)
\end_layout

\begin_layout Plain Layout

## components 7-9 are connected to IRU-measured rotation rates via the transform
ation matrix l->a,
\end_layout

\begin_layout Plain Layout

## so matrix H must vary with aircraft attitude angles.
 This is addressed by the GAEL->GAE transform.
\end_layout

\begin_layout Plain Layout

# H <- diag(1, nrow=10, ncol=15)
\end_layout

\begin_layout Plain Layout

# for (k in 7:9) {
\end_layout

\begin_layout Plain Layout

#   H[k,k] <- 0
\end_layout

\begin_layout Plain Layout

#   H[k,k+6] <- 1
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

# H[10,9] <- 1
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=7, ncol=15)
\end_layout

\begin_layout Plain Layout

H[7,7] <- 0
\end_layout

\begin_layout Plain Layout

H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component
 9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,100), ncol=10)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,49), ncol=7)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (10/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (10/(D1$Rn[1]*cos(SV$LAT)))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 100^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 0.3^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 0.3^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 0.3^2
\end_layout

\begin_layout Plain Layout

# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measureme
nt.
\end_layout

\begin_layout Plain Layout

# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an
 error in heading, not
\end_layout

\begin_layout Plain Layout

# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration
 is used for that.
\end_layout

\begin_layout Plain Layout

# RCV[10,10] <- D1$sdPsi[1]^2
\end_layout

\begin_layout Plain Layout

# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
\end_layout

\begin_layout Plain Layout

# # RCV[10, 10] <- 1000  ## suppress effect
\end_layout

\begin_layout Plain Layout

RCV[7,7] <- 1000  ## but update this each time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix with generous variances
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, echo=FALSE, eval=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- D1
\end_layout

\begin_layout Plain Layout

DL <- nrow (Data)
\end_layout

\begin_layout Plain Layout

  # find PITCHL, ROLLL in the l-frame
\end_layout

\begin_layout Plain Layout

  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal
 to AC
\end_layout

\begin_layout Plain Layout

  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
\end_layout

\begin_layout Plain Layout

  # UVL <- XformLA (Data, UV)
\end_layout

\begin_layout Plain Layout

  # PitchL <- asin (-UVL[,2])
\end_layout

\begin_layout Plain Layout

  # RollL <- asin (UVL[,1])
\end_layout

\begin_layout Plain Layout

  #   .hdg <- Data$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## note: if using l-frame PITCH and ROLL; STMFV must account for this
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

NSTEP <- 5      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

CVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

                    ## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

## pitch and roll errors are going to be those in the l-frame
\end_layout

\begin_layout Plain Layout

SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

CVEF[1, ] <- diag (CV)
\end_layout

\begin_layout Plain Layout

# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
\end_layout

\begin_layout Plain Layout

# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
\end_layout

\begin_layout Plain Layout

pctL <- 0
\end_layout

\begin_layout Plain Layout

MH <- 0    ## 0 suppresses use of deltaPsi as error in heading
\end_layout

\begin_layout Plain Layout

for (i in seq(2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

  pct <- as.integer(100*i/DL)
\end_layout

\begin_layout Plain Layout

  # if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d',
 pct));pctL <- pct}
\end_layout

\begin_layout Plain Layout

  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- Data$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- Data$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- Data$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv, .aaframe='a') * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new error-state vector:
\end_layout

\begin_layout Plain Layout

  ## the pitch and roll error derivatives are now those in the a-frame,
 but
\end_layout

\begin_layout Plain Layout

  ##   the pitch/roll error state is in the l-frame.
 Save the l-frame error state:
\end_layout

\begin_layout Plain Layout

#   SVEL <- SVEA <- SVE
\end_layout

\begin_layout Plain Layout

#   ## Transform l-frame pitch/roll error state to a-frame
\end_layout

\begin_layout Plain Layout

#   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

#   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

#   ## apply derivatives to get a-frame change
\end_layout

\begin_layout Plain Layout

#   SVEA <- dcm %*% SVEA
\end_layout

\begin_layout Plain Layout

#   ## transform back to l-frame
\end_layout

\begin_layout Plain Layout

#   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

#   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE    ## take time step in error-state vector
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  if (is.na(Data$sdPsi[i]) || (sqrt(Data$LACCX[i]^2+Data$LACCY[i]^2) < 1))
 {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- 0
\end_layout

\begin_layout Plain Layout

    # DZ[i, 7] <- NA
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- MH
\end_layout

\begin_layout Plain Layout

    RCV[7, 7] <- 10*Data$sdPsi[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

  CVEF[i/NSTEP, ] <- diag(CV)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

  if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

  x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

  T <- A$y
\end_layout

\begin_layout Plain Layout

  T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

  ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

  n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

  NL = length(T)
\end_layout

\begin_layout Plain Layout

  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

  return (T)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

VCor <- vector ('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (VCor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  VCor[VCor[,j] < 0] <- 0 
\end_layout

\begin_layout Plain Layout

  if (j > 6) {next}
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- zoo::na.approx (as.vector (Cor[, j]), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  Cor[is.na(Cor[, j]), j] <- 0
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- signal::filtfilt (signal::butter (3, 1/600), Cor[, j])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Cor7 <- Cor[, 7]
\end_layout

\begin_layout Plain Layout

# VC7 <- VCor[, 7]
\end_layout

\begin_layout Plain Layout

# .hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

# Cor[, 7] <- cos(.hdg) * Cor7 - sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# Cor[, 8] <- sin(.hdg) * Cor7 + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# VCor[, 7] <- cos(.hdg) * VC7 - sin(.hdg) * VCor[, 8]
\end_layout

\begin_layout Plain Layout

# VCor[, 8] <- sin(.hdg) * VC7 + cos(.hdg) * VCor[, 8]
\end_layout

\begin_layout Plain Layout

Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$ALTKF <- Data$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

Data$VEWKF <- Data$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

Data$VNSKF <- Data$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

Data$ROCKF <- Data$ROC - Cor[, 6]
\end_layout

\begin_layout Plain Layout

Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BLATAKF <- Data$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$DLAT <- Data$LATKF-Data$GGLAT
\end_layout

\begin_layout Plain Layout

Data$CLAT <- -Cor[, 1] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DLON <- Data$LONKF-Data$GGLON
\end_layout

\begin_layout Plain Layout

Data$CLON <- -Cor[, 2] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DALT <- Data$ALTKF-Data$GGALT
\end_layout

\begin_layout Plain Layout

Data$CALT <- -Cor[, 3]
\end_layout

\begin_layout Plain Layout

Data$DVEW <- Data$VEWKF-Data$GGVEW
\end_layout

\begin_layout Plain Layout

Data$CVEW <- -Cor[, 4]
\end_layout

\begin_layout Plain Layout

Data$DVNS <- Data$VNSKF-Data$GGVNS
\end_layout

\begin_layout Plain Layout

Data$CVNS <- -Cor[, 5]
\end_layout

\begin_layout Plain Layout

Data$DROC <- Data$ROCKF-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$CROC <- -Cor[, 6]
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- -Cor[, 7] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CROLL <- -Cor[, 8] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- -Cor[, 9] / Cradeg
\end_layout

\begin_layout Plain Layout

KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude,
 longitude, and altitude for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                    "Comparison of the KF, GPS, and INS values of aircraft-veloc
ity components for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines show the corrections
 applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                      "Pitch Correction from the Kalman filter (CPITCH,
 blue line) and from Ranadu::CorrectPitch (PC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Roll Correction from the Kalman filter (CROLL) and
 from Ranadu::CorrectPitch (RC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Heading Correction from the Kalman filter (CTHDG)
 and from Ranadu::CorrectHeading (HC, green line)")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are several tests that the corrected values should pass:
\end_layout

\begin_layout Enumerate
Because the GPS measurements of position and aircraft velocity have low
 uncertainty, the corrected values from the Kalman filter should match these
 in long-term average, perhaps with some high-frequency components not present
 in the GPS-provided measurements.
\end_layout

\begin_layout Enumerate
The pitch-correction algorithm developed in the Tech Note that describes
 wind uncertainty for the NSF/NCAR GV should give results in reasonable
 agreement with the corrected values of pitch and roll from the Kalman filter.
\end_layout

\begin_layout Enumerate
The heading-correction algorithm discussed in this memo should also produce
 results consistent with the Kalman-filter results.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Position
\end_layout

\begin_layout Standard
The KF (Kalman filter) results for position, for DEEPWAVE flight 16, are
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-position}
\end_layout

\end_inset

.
 The blue lines in the top two panels show that differences between the
 KF and GPS measurements (DLAT=LAT
\begin_inset Formula $-$
\end_inset

GGLAT+CLAT and DLON=LON
\begin_inset Formula $-$
\end_inset

GGLON+CLON where CLAT and CLON are the corrections produced by the Kalman
 filter) are neglibly small for latitude and longitude, at the resolution
 of these plots.
 (0.01
\begin_inset Formula $^{\circ}$
\end_inset

 in latitude corresponds approximately to 1 km.) This good agreement arises
 from the corrections CLAT and CLON shown as the green lines, which show
 a smoothly varying Schuler oscillation.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
Before subtraction from the original measurement, this correction has been
 filtered using a three-pole low-pass Butterworth filter with cutoff frequency
 corresponding to a period of 600
\begin_inset space ~
\end_inset

s.
 This avoids the introduction of noise from the Kalman filter that otherwise
 would contaminate the high-frequency variance spectra.
\end_layout

\end_inset

 When the differences are examined at higher resolution, however, there
 are step-change features in the KF result that are not present in the GPS
 measurement, at a level of about 10
\begin_inset space ~
\end_inset

m.
 The reason is that this is the resolution at which the original measurements
 from the INS (variables LAT and LON) are recorded, so a smoothly varying
 correction as provided by the Kalman filter preserves these step changes.
 Because the true values of latitude and longitude are not expected to show
 high-frequency components at these frequencies, the results after correction
 are further filtered using a low-pass filter with a cutoff frequency correspond
ing to about 10
\begin_inset space ~
\end_inset

s.
 This effectively smooths the jumps arising from the original measurements
 from the INS and leads to agreement between the KF and GPS values corresponding
 to about 10
\begin_inset space ~
\end_inset

m standard deviation for the part of the flight track that excludes the
 initial climb and final descent.
 Some part of this standard deviation likely arises from minor time shifts
 between the measurements from the INS and GPS.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-position, include=TRUE, echo=FALSE, fig.cap="Comparison of
 the KF (Kalman filter), GPS, and INS values of latitude, longitude, and
 altitude for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 70000, 122000)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
\end_layout

\begin_layout Plain Layout

sdZ <- with (Data[r, ], sd(DALT, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

## filter the result to smooth the jumps arising from limited INS resolution:
\end_layout

\begin_layout Plain Layout

Data$LATKF <- zoo::na.approx (as.vector (Data$LATKF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$LONKF <- zoo::na.approx (as.vector (Data$LONKF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$LATKF[is.na(Data$LATKF)] <- 0
\end_layout

\begin_layout Plain Layout

Data$LONKF[is.na(Data$LONKF)] <- 0
\end_layout

\begin_layout Plain Layout

Data$LATKF <- signal::filtfilt (signal::butter (3, 1/10), Data$LATKF)
\end_layout

\begin_layout Plain Layout

Data$LONKF <- signal::filtfilt (signal::butter (3, 1/10), Data$LONKF)
\end_layout

\begin_layout Plain Layout

sdvew <- with(Data[r, ], sd(GGVEW-VEWKF, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdvns <- with(Data[r, ], sd(GGVNS-VNSKF, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

meanvz <- with (Data[r, ], mean(ROCKF-GGVSPD, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdvz <- with (Data[r, ], sd(GGVSPD-ROCKF, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bottom panel in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-position}
\end_layout

\end_inset

 shows that a significant offset is required to correct the altitude, as
 expected because the INS-provided altitude is updated to the pressure altitude
 while the GPS provides geometric altitude above MSL.
 The repetitive pattern in the correction arises from the repeated portions
 of the flight track, which passed over the South Island of New Zealand
 in retracing patterns.
 The updating effectively adjusts the altitude to match the GPS-measured
 altitude, with a standard deviation in the central part of this flight
 track that was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdZ, 0)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m.
 
\end_layout

\begin_layout Standard
The result then is that the KF values are in agreement with the GPS-provided
 measurements of position to within about 10
\begin_inset space ~
\end_inset

m in each component of the position vector.
 The uncertainty arising from the calculated covariance matrix also indicates
 uncertainty for individual measurements of latitude or longitude corresponding
 to about 10
\begin_inset space ~
\end_inset

m.
\end_layout

\begin_layout Subsection
Ground-speed components
\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-velocity}
\end_layout

\end_inset

 shows the corresponding differences between the aircraft-velocity components
 and the GPS-provided measurements, for the same flight as that shown in
 the preceding figure.
 For the two horizontal components of ground speed, the mean difference
 between KF and GPS results is negligible (
\begin_inset Formula $<0.00001$
\end_inset


\begin_inset space ~
\end_inset

m/s) and the standard deviation of this difference is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdvns, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s, mostly arising in turns and likely the result of small timing differences
 between INS-provided and GPS-provided measurements.
 There does not appear to be a problem with resolution for the INS variables
 (VEW and VNS) as there was for position, so no further smoothing of these
 results is needed.
 Indeed, plots of the KF and GPS variables for short time periods indicate
 that there is more noise in the GPS-provided variables (GGVEW and GGVNS)
 than in the KF variables, so using these variables in the calculation of
 horizontal wind may lead to better high-frequency spectral characteristics
 than those obtained using the GPS-provided variables.
 This will be explored further in Sect.
\begin_inset space ~
\end_inset

XXX [later section discussing the impact of the KF on wind measurements).
\end_layout

\begin_layout Standard
The difference between the KF and GPS variables for rate-of-climb of the
 aircraft, shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-velocity}
\end_layout

\end_inset

, is more significant and needs further discussion.
 This calculation was first done using the INS-provided variable VSPD as
 the vertical-motion component of the state variable.
 While the mean values were similar, the standard deviation in this difference
 was about 0.28
\begin_inset space ~
\end_inset

m/s, which is larger than expected or desirable.
 The difficulty likely arises from the INS variable VSPD, which is processed
 internally in the INS before being provided to the GV data system for recording.
 Studies of this variable indicate that it has been filtered and shifted
 in time, and the INS processing includes a baro-loop that updates to the
 pressure altitude.
 This memo (Recommendation161107f.pdf) argues that VSPD is a poor variable
 to use when calculating the vertical wind and that an alternative variable
 (ROC) would provide a better representation of the rate of climb of the
 aircraft.
 That new variable has been used in the present calculation instead of VSPD
 because it gives a better representation of the rate of climb while still
 being independent of the GPS measurements.
 The Kalman filter then updates that variable to the GPS measurement (GGVSPD),
 to produce the new variable ROCKF that is shown in this plot.
 The mean difference between the GPS value and the Kalman filter was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanvz,3)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s, with standard deviation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdvz, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s.
 Section
\begin_inset space ~
\end_inset

XXX explores the characteristics of the new variable (ROCKF) as it would
 influence calculation of the vertical wind.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-velocity, include=TRUE, echo=FALSE, fig.cap="Comparison of
 the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE
 flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines (red line in the
 bottom panel) show the corrections applied to the original INS values by
 the Kalman filter.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DROC, CROC)), ylim=c(-2,2),
\end_layout

\begin_layout Plain Layout

         lwd=c(1,2), col=c('blue', 'red'))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Attitude angles
\end_layout

\begin_layout Subsubsection
Roll and pitch
\end_layout

\begin_layout Standard
The primary value of the Kalman-filter solution is that it can improving
 the measurements of attitude angles.
 Measurements of position and velocity with good quality are already available
 from the GPS, so the results in this sub-section are the primary reason
 for considering use of this Kalman filter to improve the measurements of
 wind.
 As discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Smoothing-the-errors"

\end_inset

, it is expected that the errors in pitch and roll will vary more smoothly
 in the l-frame than in the a-frame because each turn changes how any platform
 misalignment is resolved into pitch and roll errors.
 It is therefore useful to transform the pitch and roll errors to the l-frame
 for smoothing by averaging or filtering.
 The transformation is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{eqnarray}
\delta\theta^{(l)} & = & \cos\psi\thinspace\delta\theta^{(a)}+\sin\psi\thinspace\delta\phi^{(a)}\label{eq:lpitch}
\end{eqnarray}

\end_inset


\begin_inset Formula 
\begin{eqnarray}
\delta\phi^{(l)} & = & -\sin\psi\thinspace\delta\theta^{(a)}+\cos\psi\thinspace\delta\phi^{(a)}\label{eq:lroll}
\end{eqnarray}

\end_inset

where 
\begin_inset Formula $\theta$
\end_inset

 is pitch, 
\begin_inset Formula $\phi$
\end_inset

 is roll, 
\begin_inset Formula $\psi$
\end_inset

 is heading, and the superscripts indicate the reference frame.
 After this transformation is applied to the error-state vector produced
 by the Kalman filter, the pitch and roll errors in the l-frame are as shown
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-angles1}
\end_layout

\end_inset

.
 The Schuler oscillation is evident in both, with some departures that are
 mostly associated with turns.
 Also shown in this plot is the result of applying a low-pass third-order
 Butterworth filter with 900
\begin_inset space ~
\end_inset

s cutoff period to the errors.
 The result is a smoothly varying error signal dominated by the Schuler
 oscillation that eliminates much of the apparent noise introduced by the
 Kalman filter.
 Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-angles2}
\end_layout

\end_inset

 shows the result of transforming the smoothed error signal back to the
 a-frame.
 These estimated errors are then subtracted from the original measurements
 to obtain the results from the Kalman filter.
\end_layout

\begin_layout Standard
The variances associated with l-frame pitch and roll can be found by appropriate
 derivation from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lpitch"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lroll"

\end_inset

).
 The resulting variances correspond to a standard deviation of typically
 about 0.2
\begin_inset Formula $^{\circ}$
\end_inset

, but that then is reduced by an appropriate factor representing the reduction
 in standard deviation from averaging many points, as was done with the
 low-pass filter with 900
\begin_inset space ~
\end_inset

s cutoff.
 Averaging 900 points would reduce the expected standard deviation by a
 factor of 1/30, so this seems an appropriate factor to use when representing
 the smoothed-correction uncertainty.
 Orange vertical lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-angles1}
\end_layout

\end_inset

 show the resulting standard uncertainty in pitch and roll in the l-frame,
 and this then leads to the standard uncertainty in the a-frame for the
 smoothed error estimates, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-angles2}
\end_layout

\end_inset

.
 The mean standard deviation obtained in this way is 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 for both pitch and roll in either the a-frame or l-frame, so this is reasonable
 estimate of the uncertainty after correction using the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-angles, include=TRUE, echo=FALSE, fig.cap=c("Errors in pitch
 and roll after transformation to the l-frame (blue lines).
 The red lines result from the application of a centered low-pass third-order
 Butterworth filter to the errors, where the filter cutoff frequency corresponds
 to a period of 900 s.
 Short black lines plotted each 2 min show the estimated standard uncertainty.",
 "The result of transforming the filtered result shown in the previous figure
 back to the a-frame, for pitch and roll errors.
 Also shown as red lines are the results from the Ranadu routine CorrectPitch().
 The short black lines plotted each 2 min show the estimated standard uncertaint
y.")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

Data$CPL <- (cos(.hdg)*Cor[,7]+sin(.hdg)*Cor[,8]) / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CRL <- (-sin(.hdg)*Cor[,7]+cos(.hdg)*Cor[,8]) / Cradeg
\end_layout

\begin_layout Plain Layout

Data$SDCPL <- sqrt(cos(.hdg)^2*VCor[,7]+sin(.hdg)^2*VCor[,8]) / (Cradeg *
 30)
\end_layout

\begin_layout Plain Layout

Data$SDCRL <- sqrt(sin(.hdg)^2*VCor[,7]+cos(.hdg)^2*VCor[,8]) / (Cradeg *
 30)
\end_layout

\begin_layout Plain Layout

Data$SDCPA <- sqrt(cos(.hdg)^2*Data$SDCPL^2 + sin(.hdg)^2*Data$SDCRL^2)
\end_layout

\begin_layout Plain Layout

Data$SDCRA <- sqrt(sin(.hdg)^2*Data$SDCPL^2 + cos(.hdg)^2*Data$SDCRL^2)
\end_layout

\begin_layout Plain Layout

Data$CPLF <- signal::filtfilt (signal::butter (3, 1/900), Data$CPL)
\end_layout

\begin_layout Plain Layout

Data$CRLF <- signal::filtfilt (signal::butter (3, 1/900), Data$CRL)
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout

with(Data[r, ], plotWAC(data.frame(Time, CPL, CPLF), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout

                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame pitch
 error'))
\end_layout

\begin_layout Plain Layout

for (k in seq(1, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        c(Data$CPLF[r[k]]+Data$SDCPL[r[k]], Data$CPLF[r[k]]-Data$SDCPL[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(Data[r, ], plotWAC(data.frame(Time, CRL, CRLF), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout

                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame roll
 error'))
\end_layout

\begin_layout Plain Layout

for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        c(Data$CRLF[r[k]]+Data$SDCRL[r[k]], Data$CRLF[r[k]]-Data$SDCRL[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout

Data$CPAF <- cos(.hdg)*Data$CPLF - sin(.hdg)*Data$CRLF
\end_layout

\begin_layout Plain Layout

Data$CRAF <- sin(.hdg)*Data$CPLF + cos(.hdg)*Data$CRLF
\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch(Data, .span=901)
\end_layout

\begin_layout Plain Layout

Data$PC <- PC[, 1]
\end_layout

\begin_layout Plain Layout

Data$RC <- PC[, 2]
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(Data[r, ], plotWAC(data.frame(Time, CPAF, PC), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout

                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame
 pitch error'))
\end_layout

\begin_layout Plain Layout

for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        c(Data$CPAF[r[k]]+Data$SDCPA[r[k]], Data$CPAF[r[k]]-Data$SDCPA[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(Data[r, ], plotWAC(data.frame(Time, CRAF, RC), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout

                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame
 roll error'))
\end_layout

\begin_layout Plain Layout

for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        c(Data$CRAF[r[k]]+Data$SDCRA[r[k]], Data$CRAF[r[k]]-Data$SDCRA[r[k]]),
 
\end_layout

\begin_layout Plain Layout

        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

## save corrected values, obtained by subtracting the smoothed a-frame correctio
ns:
\end_layout

\begin_layout Plain Layout

Data$PITCHKF <- Data$PITCH - Data$CPAF
\end_layout

\begin_layout Plain Layout

Data$ROLLKF <- Data$ROLL - Data$CRAF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# VC7 <- (cos(.hdg)^2*VCor[, 7] + sin (.hdg)^2*VCor[,8])
\end_layout

\begin_layout Plain Layout

# VC7[VC7 < 0.000006] <- 0.000006
\end_layout

\begin_layout Plain Layout

# SP <- smooth.spline(Data$Time[r], Data$CPL[r], w=1/VC7[r], spar=0.7)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## translate pitch/roll corrections to the a-frame:
\end_layout

\begin_layout Plain Layout

.hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

C7 <- SmoothInterp (Cor[, 7], .Length=181)
\end_layout

\begin_layout Plain Layout

C8 <- SmoothInterp (Cor[, 8], .Length=181)
\end_layout

\begin_layout Plain Layout

# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# Data$CPITCH <- CPITCH / Cradeg
\end_layout

\begin_layout Plain Layout

# Data$CROLL <- CROLL / Cradeg
\end_layout

\begin_layout Plain Layout

# Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
\end_layout

\begin_layout Plain Layout

# Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- SmoothInterp (Data$CTHDG, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$HC <- -CorrectHeading (Data, .plotfile='./HCPlot.pdf')
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH
 CORRECTION',' [',degree,']')), 
\end_layout

\begin_layout Plain Layout

#         ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position=
'topright')
\end_layout

\begin_layout Plain Layout

# CCPITCH <- Data$CPITCH
\end_layout

\begin_layout Plain Layout

# PCC <- Data$PC
\end_layout

\begin_layout Plain Layout

# ival <- abs(Data$ROLL) > 4
\end_layout

\begin_layout Plain Layout

# CCPITCH[ival] <- NA
\end_layout

\begin_layout Plain Layout

# PCC[ival] <- NA
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], CCPITCH[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], PCC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

# abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# with(Data[r,], plotWAC(data.frame(Time, CPL)))
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], predict(SP, as.numeric(Data$Time))$y[r], col='red')
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], sqrt(VC7[r])+predict(SP, as.numeric(Data$Time))$y[r],
 col='darkgreen')
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], -sqrt(VC7[r])+predict(SP, as.numeric(Data$Time))$y[r],
 col='darkgreen')
\end_layout

\begin_layout Plain Layout

# Y <- predict(SP, as.numeric(Data$Time))$y[r]
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(Data$Time[r], Y, Y+sqrt(VC7[r]), Y-sqrt(VC7[r]), Data$CPL[r]
), 
\end_layout

\begin_layout Plain Layout

#         col=c('blue', 'darkgreen', 'darkgreen', 'red'), lty=c(1,2,2,1))
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), 
\end_layout

\begin_layout Plain Layout

#       ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
\end_layout

\begin_layout Plain Layout

#       ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='to
pright')
\end_layout

\begin_layout Plain Layout

# Data$CROLL[ival] <- NA
\end_layout

\begin_layout Plain Layout

# Data$RC[ival] <- NA
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

# abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

Data$dP <- Data$deltaPsi/Cradeg
\end_layout

\begin_layout Plain Layout

HA <- with(Data, sqrt(LACCX^2+LACCY^2))
\end_layout

\begin_layout Plain Layout

Data$dP[HA < 1] <- NA
\end_layout

\begin_layout Plain Layout

sddP <- sd(Data$dP[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Heading
\end_layout

\begin_layout Standard
The heading angle is more difficult to handle because, for most flight condition
s, the heading is poorly constrained and some unrealistic errors with large
 uncertainty are produced by the Kalman filter.
 The flight pattern for the particular flight used for this example included
 frequent changes in flight direction, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading1}
\end_layout

\end_inset

, so those turns result in accelerations that can constrain the heading
 periodically during the flight.
 In Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:heading-error"

\end_inset

, it was argued that (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) provides an estimate of the error in heading.
 However, for the full flight (excluding initial climb and final descent)
 the mean value provided by this formula was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(Data$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 but the standard deviation of the correction provided by this equation
 was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(Data$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so using this correction throughout the flight will likely introduce correctio
ns with large uncertainty.
 To avoid the noise and uncertainty this would introduce, it is useful to
 limit the correction to those times when horizontal accelerations are large.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading2}
\end_layout

\end_inset

 shows the values from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) for those times when the horizontal acceleration was more than 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 The mean value of 
\begin_inset Formula $\delta\psi$
\end_inset

 for these periods was smaller than 0.001
\begin_inset Formula $^{\circ}$
\end_inset

 and the standard deviation of the 4295 values was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sddP, 2)}
\end_layout

\end_inset

.
 This indicates that the uncertainty in the average error in heading is
 smaller than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 when the average is calculated for the entire flight.
 
\end_layout

\begin_layout Standard
The result for the heading error from the Kalman filter is shown as the
 blue line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading3}
\end_layout

\end_inset

.
 The varying correction often has large uncertainty.
 The thicker blue lines indicate those regions where the Kalman-filter estimate
 of the covariance corresponds to a standard deviation smaller than about
 0.2
\begin_inset Formula $^{\circ}$
\end_inset

.
 As in the preceding plot, these regions are confined to the turns where
 horizontal accelerations are significant.
 A smoothing spline
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

smooth.spline()
\begin_inset Quotes erd
\end_inset

 function provided by the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package in R was used, in parameter 
\begin_inset Quotes eld
\end_inset

spar=1.1
\begin_inset Quotes erd
\end_inset

 to give strong smoothing.
\end_layout

\end_inset

 that uses weight factors inversely proportional to the covariance leads
 to the red line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading3}
\end_layout

\end_inset

, for which the mean error is 
\begin_inset Formula $<0.002^{\circ}$
\end_inset

 and the standard deviation for individual measurements is about 0.02
\begin_inset Formula $^{\circ}$
\end_inset

.
 Another check on the heading error is provided by the correction algorithm
 
\begin_inset Quotes eld
\end_inset

Ranadu::CorrectHeading()
\begin_inset Quotes erd
\end_inset

, which leads to the green line in the figure.
 which has mean and standard deviation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(Data$HC[r], na.rm=TRUE),3)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(Data$HC[r], na.rm=TRUE),3)}
\end_layout

\end_inset

.
 Perhaps the best interpretation for this flight is that, within about 0.02
\begin_inset Formula $^{\circ}$
\end_inset

 uncertainty, there is no heading error.
 However, in general the spline fit represented by the red line may be the
 preferable result to use as a correction to the heading.
\end_layout

\begin_layout Standard
When applying the Kalman filter to the measurements from the INS, it is
 important to recognize that the results reported by the INS are those that
 have been used during its internal mechanization to find, for example,
 the ground-speed vector and the l-frame accelerations.
 In processed data sets, it has been common to introduce adjustments to
 the heading or, less often, the pitch to improve the performance of wind
 measurements during calibration maneuvers.
 It is particularly common to find an offset in heading that was introduced
 to give better agreement for winds during reverse-course maneuvers.
 However, it is difficult to separate an offset in sideslip from an offset
 in heading, as discussed in the NCAR Technical Note on uncertainty in wind
 measurements.
 It now appears that the offset often introduced to heading should have
 instead been an offset in sideslip.
 Because these offsets are introduced after the INS has performed its internal
 calculations, the Kalman filter has no mechanism for detecting that an
 offset has been introduced and will still produce estimates of heading
 error applicable to the original measurements.
 It is therefore important to remove any special adjustments that have been
 introduced to heading or other INS-provided variables before processing
 via the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-heading, include=TRUE, echo=FALSE, fig.cap=c("The flight track
 for DEEPWAVE flight 16, 4 July 2012.
 The dashed-line topography shows the South Island of New Zealand.", "Heading
 error estimated from (2), for only those periods of DEEPWAVE flight 16
 where the horizontal acceleration is larger than 1
\backslash

\backslash
 m
\backslash

\backslash
,s$^{-2}$.", "Heading Correction from the Kalman filter (CTHDG) and from
 Ranadu::CorrectHeading (HC, green line)")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- getNetCDF(fname)
\end_layout

\begin_layout Plain Layout

plotTrack(DT)
\end_layout

\begin_layout Plain Layout

Data$dP <- Data$deltaPsi/Cradeg
\end_layout

\begin_layout Plain Layout

HA <- with(Data, sqrt(LACCX^2+LACCY^2))
\end_layout

\begin_layout Plain Layout

Data$dP[HA < 1] <- NA
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, dP)))
\end_layout

\begin_layout Plain Layout

sddP <- sd(Data$dP[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylim=c(-0.4,0.4), lwd=0.7,
 legend.position='topright')
\end_layout

\begin_layout Plain Layout

HE <- VCor[,9]
\end_layout

\begin_layout Plain Layout

HE[HE < 0.00001] <- 0.00001
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

iv <- HE > 0.0012    # 0.0025
\end_layout

\begin_layout Plain Layout

CCTHDG <- Data$CTHDG
\end_layout

\begin_layout Plain Layout

CCTHDG[iv] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r], spar=1.1)
\end_layout

\begin_layout Plain Layout

Data$HCS <- predict(SS, as.numeric(Data$Time))$y
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$HCS[r], col='red')
\end_layout

\begin_layout Plain Layout

Data$THDGKF <- Data$THDG - Data$HCS    ## save the corrected heading
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Section
New netCDF variables
\end_layout

\begin_layout Standard
The result of the Kalman filter is that new corrected variables {LATKF,
 LONKF, ALTKF, VEWKF, VNSKF, ROCKF, PITCHKF, ROLLKF, and THDGKF} are available.
 The code in this section adds those variables to an existing newCDF file,
 renaming the result with names like xxxrf01KF.nc if the original file was
 xxxrf01.nc.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<create-new-netcdf>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fnew <- sub ('.nc', 'KF.nc', fname)
\end_layout

\begin_layout Plain Layout

## beware: overwrites without warning!!
\end_layout

\begin_layout Plain Layout

Z <- file.copy (fname, fnew, overwrite=TRUE)  ## BEWARE: overwrites without
 warning!!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# function to copy attributes from old variable (e.g., PITCH) to new one (e.g.,
 PITCHKF)
\end_layout

\begin_layout Plain Layout

copy_attributes <- function (atv, v, nfile) {
\end_layout

\begin_layout Plain Layout

  for (i in 1:length(atv)) {
\end_layout

\begin_layout Plain Layout

    aname <- names(atv[i])
\end_layout

\begin_layout Plain Layout

    if (grepl ('name', aname)) {next}  # skips long and standard names
\end_layout

\begin_layout Plain Layout

    if (grepl ('units', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('Dependencies', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('actual_range', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (is.numeric (atv[[i]])) {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.numeric(atv[[i]]))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.character (atv[[i]]))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<modify-new-netcdf, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables needed for attributes and new wind calculation:
\end_layout

\begin_layout Plain Layout

VarList <- c('TASX', 'ATTACK', 'SSLIP', 'GGVEW', 'GGVNS', 'GGVSPD', 'VEW',
 'VNS', 'THDG', 'ROLL', 'PITCH',
\end_layout

\begin_layout Plain Layout

             'LAT', 'LON', 'VSPD')
\end_layout

\begin_layout Plain Layout

VarListRef <- VarList
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo (fname)
\end_layout

\begin_layout Plain Layout

VarList <- VarListRef
\end_layout

\begin_layout Plain Layout

if ('GGVSPD' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

} else if ('GGVSPDB' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

  VarList [which (VarList == 'GGVSPD')] <- 'GGVSPDB'
\end_layout

\begin_layout Plain Layout

} else if ('VSPD_A' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

  VarList [which (VarList == 'GGVSPD')] <- 'VSPD_A'
\end_layout

\begin_layout Plain Layout

} else if ('VSPD_G' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

  VarList [which (VarList == 'GGVSPD')] <- 'VSPD_G'
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  print ('ERROR: no VSPD variable found')
\end_layout

\begin_layout Plain Layout

  exit()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (Var in VarList) {
\end_layout

\begin_layout Plain Layout

  if (!(Var %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

    print (sprintf (' required variable %s not found in file %s; skipping...',
 Var, fname))
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

D <- getNetCDF (fname, VarList)
\end_layout

\begin_layout Plain Layout

netCDFfile <- nc_open (fnew, write=TRUE) 
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

Dimensions <- attr (D, "Dimensions")
\end_layout

\begin_layout Plain Layout

Dim <- Dimensions[["Time"]]
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps25"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if ("sps50" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 50
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps50"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DATT <- D  ## save to ensure that attributes are preserved
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables to add to the netCDF file:
\end_layout

\begin_layout Plain Layout

VarNew <- c('LATKF', 'LONKF', 'ALTKF', 'VEWKF', 'VNSKF', 'ROCKF', 'PITCHKF',
 'ROLLKF', 'THDGKF',
\end_layout

\begin_layout Plain Layout

            'WDKF', 'WSKF', 'WIKF')
\end_layout

\begin_layout Plain Layout

VarOld <- c('LAT', 'LON', 'ALT', 'VEW', 'VNS', 'VSPD', 'PITCH', 'ROLL',
 'THDG', 'WD', 'WS', 'WI')
\end_layout

\begin_layout Plain Layout

VarUnits <- c('degrees', 'degrees', 'm', 'm/s', 'm/s', 'm/s', 'degrees',
 'degrees', 'degrees',
\end_layout

\begin_layout Plain Layout

              'degrees', 'm/s', 'm/s')
\end_layout

\begin_layout Plain Layout

VarLongName <- c('latitude, KF', 'longitude, KF', 'altitude MSL, KF',
\end_layout

\begin_layout Plain Layout

                 'eastward groundspeed, KF', 'northward groundspeed, KF',
 'rate of climb, KF',
\end_layout

\begin_layout Plain Layout

                 'pitch, KF', 'roll, KF', 'heading, KF',
\end_layout

\begin_layout Plain Layout

                 'wind direction, KF', 'wind speed, KF', 'vertical wind,
 KF')
\end_layout

\begin_layout Plain Layout

VarStdName <- c('INS latitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS longitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS altitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS eastward ground speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS northward ground speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS rate of climb, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS aircraft pitch angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS aircraft roll angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'INS aircraft true heading angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'horizontal wind direction, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'horizontal wind speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

				'vertical wind speed, Kalman-filter-corrected')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## get the wind variables:
\end_layout

\begin_layout Plain Layout

DataW <- D
\end_layout

\begin_layout Plain Layout

DataW$PITCH <- Data$PITCHKF
\end_layout

\begin_layout Plain Layout

DataW$ROLL <- Data$ROLLKF
\end_layout

\begin_layout Plain Layout

DataW$THDG <- Data$THDGKF
\end_layout

\begin_layout Plain Layout

DataW$VEW <- Data$VEWKF
\end_layout

\begin_layout Plain Layout

DataW$VNS <- Data$VNSKF
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- Data$ROCKF
\end_layout

\begin_layout Plain Layout

DataW <- WindProcessor(DataW)
\end_layout

\begin_layout Plain Layout

Data$WDKF <- DataW$WDN
\end_layout

\begin_layout Plain Layout

Data$WSKF <- DataW$WSN
\end_layout

\begin_layout Plain Layout

Data$WIKF <- DataW$WIN
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## create the new variables
\end_layout

\begin_layout Plain Layout

nv <- length (VarNew)
\end_layout

\begin_layout Plain Layout

varCDF <- list ()
\end_layout

\begin_layout Plain Layout

for (i in 1:nv) {
\end_layout

\begin_layout Plain Layout

  varCDF[[i]] <- ncvar_def (VarNew[i],  
\end_layout

\begin_layout Plain Layout

                    units=VarUnits[i], 
\end_layout

\begin_layout Plain Layout

                    dim=Dim, 
\end_layout

\begin_layout Plain Layout

                    missval=as.single(-32767.), prec='float', 
\end_layout

\begin_layout Plain Layout

                    longname=VarLongName[i])
\end_layout

\begin_layout Plain Layout

  if (i == 1) {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (newfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ATV <- ncatt_get (netCDFfile, VarOld[i])
\end_layout

\begin_layout Plain Layout

  copy_attributes (ATV, VarNew[i], newfile)
\end_layout

\begin_layout Plain Layout

  ncatt_put (newfile, VarNew[i], attname="standard_name", 
\end_layout

\begin_layout Plain Layout

             attval=VarStdName[i])
\end_layout

\begin_layout Plain Layout

  if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]])
\end_layout

\begin_layout Plain Layout

  } else if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]], count=c(25, nrow(Data)/2
5))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nc_close (newfile)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
â€“ End of Memo â€“
\end_layout

\begin_layout Standard
Reproducibility:
\begin_inset Note Note
status open

\begin_layout Plain Layout
include enough info to re-run.
 in zip, include program, pdf if not too big, and subset data, not entire
 file.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.zip
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.Rnw
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

/scr/raf
\backslash
_data/
\backslash
Sexpr{Project}/
\backslash
Sexpr{Flight}.nc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.pdf
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/
\backslash
Sexpr{thisFileName}.git
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_body
\end_document
