#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={Wind Uncertainty TN file}  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A Kalman filter to apply corrections to the wind measurements
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilter"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/theme_WAC.R')
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/Ranadu/KalmanFilter')
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     			 # XXX change this
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Introduction and scope
\end_layout

\begin_layout Standard
The intent of this study is to evaluate the errors present in the measurements
 of attitude angles from the IRU on the NSF/NCAR
\begin_inset space ~
\end_inset

GV by means of a Kalman filter applied to the difference between measurements
 from a GPS and corresponding measurements from the IRU.
 The redundant measurements are those of position and velocity,
\begin_inset Foot
status open

\begin_layout Plain Layout
Because GPS measurements of velocity have low uncertainty, those measurements
 could be differentiated and, after transformation to the aircraft reference
 frame, used as error measurements for the measured accelerations.
 This has not been explored as yet, and it is not clear that this would
 provide information beyond that arising from the Kalman-filter updates
 using only velocity.
\end_layout

\end_inset

 for which the GPS measurements are clearly superior especially at low rate,
 so a necessary result will be that the corrected measurements should be
 quite close to those from the GPS.
 The advantage of this analysis, though, is that the coupling between errors
 in the attitude angles and those in velocity makes it possible to evaluate
 the errors in the attitude angles also.
\end_layout

\begin_layout Standard
Before describing the implementation of the filter, it is useful to explain
 the basic concept underlying a Kalman filter.
 A Kalman filter provides a means of updating a sequence of state vectors
 (consisting, in the present case, of INS measurements of position, velocity,
 and attitude angles) by comparison to an independent set of measurements
 (e.g., GPS-derived measurements of position and velocity).
 The updated state vector obtained by this process consists of an appropriately
 weighted combination of the state vector projected forward using normal
 INS 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 (i.e., determining the next step by using the measured acceleration and rotation
 from the IRU) and the independent measurements from GPS.
 Because errors in the state vector are coupled, the update procedure can
 estimate errors in the attitude angles as well as the components of the
 state vector that are measured directly by the GPS.
 This is the primary reason for using a Kalman filter to improve the wind
 measurements: Although the measurements of position and velocity that result
 should differ little from those provided by the GPS, the corrections to
 the attitude angles (pitch, roll, and heading) can be estimated even though
 there is no direct measurement of these except from the INS.
\end_layout

\begin_layout Standard
The weighting of the projected-forward state and new measurements from GPS
 depends on obtaining estimates of the covariance matrix describing the
 state vector as well as estimates of the noise sources contaminating the
 measurements from both the GPS and the IRU-provided accelerations and rotations.
 With proper weighting, the result should combine the good high-frequency
 response of the INS with the good long-term stability of the GPS.
 The covariance matrix characterizing the state vector is updated as the
 filter is applied, but appropriate weighting depends on reasonable estimation
 of the other error terms.
\end_layout

\begin_layout Standard
The operation of the filter depends on sequential use of a set of matrices,
 so it is useful to define those as follows, where the variable names following
 the symbols are the R variable names used in the following code:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{x}_{k}$
\end_inset


\begin_inset space ~
\end_inset

[SVE] The error-state vector at time index 
\begin_inset Formula $k$
\end_inset

.
 In the present case, this consists of these 15 components: estimated errors
 in position, aircraft velocity, aircraft attitude, IRU-measured rotation
 rate, and IRU-measured accelerations.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{T}_{k|k-1}$
\end_inset


\begin_inset space ~
\end_inset

[dcm] The 15x15 state transformation matrix describing INS mechanism for
 the change from time 
\begin_inset Formula $k-1$
\end_inset

 to time 
\begin_inset Formula $k$
\end_inset

.
 Then 
\begin_inset Formula $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
\end_inset

 where 
\begin_inset Formula $\mathbf{T}$
\end_inset

 combines the unit diagonal matrix with the time step multiplied by the
 derivative matrix describing the state transformation.
 As applied to the state vector, this state transformation matrix would
 involve the derivatives used for normal INS mechanization to get how the
 state vector advances, and so would duplicate the action of the internal
 INS data processing.
 As interpreted for an error-state Kalman filter, the matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is obtained by calculating the Jacobian of that state-transition function
 as a function of the error-state components.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{V}$
\end_inset


\begin_inset space ~
\end_inset

[CV] The covariance matrix that applies to the state vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

, a 15x15 matrix
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}$
\end_inset


\begin_inset space ~
\end_inset

[K] The Kalman-gain matrix representing how the error-state vector is updated
 using the current error state and the new GPS measurements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{z}$
\end_inset


\begin_inset space ~
\end_inset

[DZ] The 9-component measured differences between the INS and GPS measurements
 of position, velocity and acceleration.
 The latter three components are obtained by differentiating the GPS-provided
 velocity components.
 This differs from most conventional approaches but proves useful for contrainin
g the measurement of heading.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{H}$
\end_inset


\begin_inset space ~
\end_inset

[H] The 15x9-component matrix representing how the measured differences
 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 correspond to the state vector.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{Q},\,\mathbf{R}$
\end_inset


\begin_inset space ~
\end_inset

[Q,
\begin_inset space ~
\end_inset

R] Matrices representing respectively the anticipated noise contributions
 affecting the error-state vector (15x15) and the measurements from the
 GPS (9x9).
\end_layout

\begin_layout Standard
The approach taken here will be to filter the error-state vector that represents
 the difference between the best-estimate measurements and those originally
 provided by the INS.
 The INS integration does not need to be duplicated here to obtain the reference
 solution because that is already available.
 However, the Kalman filter does need the 
\begin_inset Quotes eld
\end_inset

state transition matrix
\begin_inset Quotes erd
\end_inset

 that represents the forward integration, so the first step in this analysis
 is to obtain such a matrix and validate results using it against the available
 INS solution.
 The Jacobian of that state-transition function then provides the matrix
 
\begin_inset Formula $\mathbf{T}$
\end_inset

 used in this filter.
\end_layout

\begin_layout Section*
Some component functions
\end_layout

\begin_layout Standard
Some of the operations involved in that 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 are contained in the following functions, with code as in the associated
 R 
\begin_inset Quotes eld
\end_inset

chunks.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate

\emph on
\bar under
XfLArV()
\emph default
\bar default
, a function of the current state vector, provides a 3x3 matrix that transforms
 a vector from the a-frame (the aircraft reference frame) to the l-frame,
 the local-level frame (with {x,y,z} coordinates toward the East, North,
 and upward directions).
 
\end_layout

\begin_layout Enumerate

\emph on
\bar under
RotationCorrection()
\emph default
\bar default
 calculates the correction to accelerations needed to account for the rotation
 of the Earth and of the l-frame relative to an inertial frame.
 This function provides corrections to subtract from transformed accelerations
 before using them in the l-frame.
\end_layout

\begin_layout Enumerate

\emph on
\bar under
STMFV()
\emph default
\bar default
 calculates the 15-component derivative of the state vector given the state
 vector and the measurements from the INU.
 This function is then used in the R function numDeriv::jacobian to find
 the Jacobian needed for the state transformation matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XfLArV <- function (data) {   ## XfLA but using input in radians and single
 row
\end_layout

\begin_layout Plain Layout

  # data must contain PITCH, ROLL, HEADING as components [7:9]
\end_layout

\begin_layout Plain Layout

  cosphi <- cos (data[8])
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (data[8])
\end_layout

\begin_layout Plain Layout

  costheta <- cos (data[7])
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (data[7])
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (data[9])
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (data[9])
\end_layout

\begin_layout Plain Layout

  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-
sinpsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinph
i-cospsi*sintheta*cosphi,
\end_layout

\begin_layout Plain Layout

           -sintheta, costheta*sinphi, -costheta*cosphi)
\end_layout

\begin_layout Plain Layout

  RblM <- aperm( array (Rbl, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  return (RblM)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# other-functions ---------------------------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

dt <- 1/25               ## working with 25-Hz file
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

Ree <- 6378137
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

## The next correction calculates the correction needed to account for the
 rotation
\end_layout

\begin_layout Plain Layout

## of the Earth and of the l-frame (ENU frame).
 See Noureldin et al., 2013, 
\end_layout

\begin_layout Plain Layout

## Eqs.
 5.55--5.57.
 Subtract this from the transformed accelerations before using them.
\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  Ree <- 6378137
\end_layout

\begin_layout Plain Layout

  Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
\end_layout

\begin_layout Plain Layout

  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2] / Rm
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Gravity <- function (latitude, altitude=0.) {
\end_layout

\begin_layout Plain Layout

  sl2 <- (sin (latitude * Cradeg))^2
\end_layout

\begin_layout Plain Layout

  g <- 9.780327 * ((1.
 + 0.001931851 * sl2) / 
\end_layout

\begin_layout Plain Layout

                     (1.
 - 0.006694380 * sl2)) - 3.086e-6 * altitude
\end_layout

\begin_layout Plain Layout

  ## Somigliana formula 1980 GRS:
\end_layout

\begin_layout Plain Layout

  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
\end_layout

\begin_layout Plain Layout

  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 *
 altitude^2
\end_layout

\begin_layout Plain Layout

  return(g)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
\end_layout

\begin_layout Plain Layout

Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

# The following is commented because it is already in the Somagliana equation
\end_layout

\begin_layout Plain Layout

# Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
\end_layout

\begin_layout Plain Layout

#   (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)
\end_layout

\begin_layout Plain Layout

STMFV <- function (sv, .aaframe='a') { 
\end_layout

\begin_layout Plain Layout

  stmf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  ## transform back to a-frame if necessary
\end_layout

\begin_layout Plain Layout

  if (.aaframe == 'l') {
\end_layout

\begin_layout Plain Layout

    svs7 <- sv[7]
\end_layout

\begin_layout Plain Layout

    svs8 <- sv[8]
\end_layout

\begin_layout Plain Layout

    sv[7] <- cos (sv[9]) * svs7 + sin (sv[9]) * svs8
\end_layout

\begin_layout Plain Layout

    sv[8] <- -sin (sv[9]) * svs7 + cos (sv[9]) * svs8
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  rlm <- XfLArV(sv)    
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/(Rn),
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
\end_layout

\begin_layout Plain Layout

  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2],
 omega[1], 0), ncol=3)
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  ## find the derivative of the transformation matrix:
\end_layout

\begin_layout Plain Layout

  ## (must recalculate SRM from measured rotation rates)
\end_layout

\begin_layout Plain Layout

  SRR <- c(0, -sv[12], -sv[10],
\end_layout

\begin_layout Plain Layout

           sv[12], 0, sv[11],
\end_layout

\begin_layout Plain Layout

           sv[10], -sv[11], 0)
\end_layout

\begin_layout Plain Layout

  SRM <- aperm( array (SRR, dim=c(3,3)))
\end_layout

\begin_layout Plain Layout

  dRLA <- rlm %*% SRM - Oilb
\end_layout

\begin_layout Plain Layout

  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
\end_layout

\begin_layout Plain Layout

  Grav <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch
 and roll!
\end_layout

\begin_layout Plain Layout

  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-fra
me
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
\end_layout

\begin_layout Plain Layout

  ## now correct for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  VL <- c(sv[4], sv[5], sv[6])
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3)
\end_layout

\begin_layout Plain Layout

  lat <- sv[1]
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
\end_layout

\begin_layout Plain Layout

  M23 <- VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
\end_layout

\begin_layout Plain Layout

  M32 <- -VL[2] / Rm
\end_layout

\begin_layout Plain Layout

  C[1] <- M12 * VL[2] + M13 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[2] <- M21 * VL[1] + M23 * VL[3]
\end_layout

\begin_layout Plain Layout

  C[3] <- M31 * VL[1] + M32 * VL[2]
\end_layout

\begin_layout Plain Layout

  AL <- as.vector (AL - C, mode='numeric')
\end_layout

\begin_layout Plain Layout

  AL[3] <- AL[3] + Grav
\end_layout

\begin_layout Plain Layout

  AL[3] <- -AL[3]
\end_layout

\begin_layout Plain Layout

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
\end_layout

\begin_layout Plain Layout

              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
\end_layout

\begin_layout Plain Layout

            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
\end_layout

\begin_layout Plain Layout

              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
\end_layout

\begin_layout Plain Layout

            0, 0, 0, 0, 0, 0)
\end_layout

\begin_layout Plain Layout

  ## return sv to original if necessary
\end_layout

\begin_layout Plain Layout

  if (.aaframe == 'l') {
\end_layout

\begin_layout Plain Layout

    sv[7] <- svs7
\end_layout

\begin_layout Plain Layout

    sv[8] <- svs8
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (as.vector (stmf, mode='numeric'))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR + 0.0005
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

# SP$BLATA <- SP$BLATA * 1.1
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
The integration steps
\end_layout

\begin_layout Standard
The purpose of this section is to demonstrate that the INS mechanization
 used to find the error-state transformation matrix provides a valid and
 independent means of propagating the measurements of position, velocity,
 and attitude forward in time.
 The procedure used for this test is as follows:
\end_layout

\begin_layout Enumerate
Initialize a state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

 having these components:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the l-frame
\end_layout

\begin_layout Enumerate
east velocity, north velocity, upward velocity in the l-frame
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the a-frame
\end_layout

\begin_layout Enumerate
rotation rates about the pitch, roll, and yaw axes of the aircraft
\end_layout

\begin_layout Enumerate
acceleration in the lateral, longitudinal, and normal direction relative
 to the aircraft reference frame.
\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
store the measured rotations and accelerations in the last 6 components
 of the state vector
\end_layout

\begin_layout Enumerate
via the function STMFV, calculated the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the a-frame to the l-frame and then using
 the definition of components of that matrix to find the derivative of the
 attitude angles.
\end_layout

\begin_layout Enumerate
use that derivative vector to increment the state vector
\end_layout

\begin_layout Enumerate
compensate for possible wrap-around of the heading a 0 and 360 deg so that
 values stay within that range.
\end_layout

\begin_layout Enumerate
save the first 9 components of the state vector in a new data.frame that
 represents an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the INS
 solution.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' ', cache=TRUE>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH,
 ROLL, THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$GGALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

Rn <- SP$Rn[1]
\end_layout

\begin_layout Plain Layout

Rm <- SP$Rm[1]
\end_layout

\begin_layout Plain Layout

Grav <- SP$Grav[1]
\end_layout

\begin_layout Plain Layout

stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

## feedback coefficients for baro loop:
\end_layout

\begin_layout Plain Layout

C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
\end_layout

\begin_layout Plain Layout

wp3F <- 0;
\end_layout

\begin_layout Plain Layout

hxF <- hxxF <- 0
\end_layout

\begin_layout Plain Layout

hi3F <- SP$GGALT[1]
\end_layout

\begin_layout Plain Layout

RK <- TRUE    ## use Runge-Kutta integration if true
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (i in 2:DL) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i]
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i]
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i]
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  if (RK) {
\end_layout

\begin_layout Plain Layout

    stmf1 <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

    sv1 <- sv + stmf1 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf2 <- STMFV (sv1)
\end_layout

\begin_layout Plain Layout

    sv2 <- sv + stmf2 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf3 <- STMFV (sv2)
\end_layout

\begin_layout Plain Layout

    sv3 <- sv + stmf3 * dt
\end_layout

\begin_layout Plain Layout

    stmf4 <- STMFV (sv3)
\end_layout

\begin_layout Plain Layout

    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  ## baro-loop
\end_layout

\begin_layout Plain Layout

  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
\end_layout

\begin_layout Plain Layout

  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
\end_layout

\begin_layout Plain Layout

  hxF <- hi3F - SP$GGALT[i]
\end_layout

\begin_layout Plain Layout

  hxxF <- hxxF + hxF * dt
\end_layout

\begin_layout Plain Layout

  sv[6] <- 0.5 * (sv[6] + wp3F)
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparis
on of INS-provided and integration-derived positions.', 'Comparison of INS-provid
ed and integration-derived components of the aircraft velocity.', 'Comparison
 of INS-provided and integration-derived attitude angles.')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 33000, 35500)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'LON', 'LONX')])
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
\end_layout

\begin_layout Plain Layout

## find attitude angles from RaLM:
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
\end_layout

\begin_layout Plain Layout

lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
\end_layout

\begin_layout Plain Layout

lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

SP <- SPR    ## restore to state before integration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result of that integration is shown in Figs.
\begin_inset space ~
\end_inset

1–3, with comparisons to the INS-produced solutions.
 There are some differences, but they are mostly understandable and could
 be corrected.
 For example, the attitude angles show differences in sine waves during
 the circles flown during this time segment and suggest a timing error that
 causes one signal to be delayed relative to the comparable signal.
 The INS-produced solution for altitude has a baro-loop applied to keep
 the altitude near the pressure altitude, and that is not applied in this
 solution so the vertical wind and position show large drifts.
 Perhaps the one aspect that is troublesome is that in VNS and consequently
 in latitude.
 Also, the data used here are the 25-Hz records, while the INS uses a significan
tly higher data rate for its corresponding integration.
 The remaining differences need further investigation, but the key result
 from this part of the study is that as implemented above the derivatives
 of components of the state vector are approximately correct and integrate
 to reasonable values.
 The function providing those derivatives is therefore a reasonable basis
 for the Kalman filter that follows.
\end_layout

\begin_layout Section*
The Kalman filter
\end_layout

\begin_layout Standard
The preceding steps verify that at least an approximate calculation of the
 derivatives of the state variables is available.
 On that basis, an error-state Kalman filter can be developed.
 an error-state Kalman filter can be developed.
 Before presenting that development, however, it is necessary to discuss
 two aspects of the Kalman filter developed here: 
\end_layout

\begin_layout Enumerate
Errors in the pitch and roll angles represent errors in the calculated level
 position of the IRU.
 For a fixed orientation error, when the aircraft turns, the errors in pitch
 and roll intermix, with for example a pitch error during northbound flight
 becoming a roll error during eastbound flight while the roll error becomes
 a pitch error.
 If a Kalman filter is implemented with error terms for pitch and roll in
 the a-frame, there will be large transient errors arising from course changes
 that must be corrected via the Kalman filter, whereas if the filter is
 implemented with errors in the l-frame the respective north and east components
 of the attitude-angle errors remain approximately constant.
 For this reason, it is preferable to implement the filter using attitude-angle
 errors as they appear in the l-frame.
 The correction terms developed by the Kalman filter must then be transformed
 back to the a-frame before they are applied to the measurements of pitch
 and roll.
 
\end_layout

\begin_layout Enumerate
Conventional implementations of Kalman-filter updating use the measurements
 of position and velocity from the GPS receiver as the external measurements
 to which the INS measurements are compared.
 This works well for all but the heading measurement.
 A heading error results in erroneous resolution of measured accelerations
 into l-frame components and so to errors in velocity, but the feedback
 of these errors to heading is slow and noisy.
 Therefore, a more direct method of coupling GPS-derived measurements to
 heading errors will be used by differentiating the GPS-measured valocities
 to obtain independent measurements of acceleration and then using these
 measured l-frame accelerations as additional measurements to be compared
 to the INS solution.
 If there is an error in heading, these accelerations will lead to a difference
 between the GPS-derived direction of l-frame acceleration and the INS-derived
 direction, and this can be considered a direct measurement of heading error.
 Except in turns, the measured l-frame acceleration is too small and noisy
 for this to be effective, but turns produce strong signals and consequent
 constraints on the heading error.
\end_layout

\begin_layout Standard
The Kalman filter is then constructed as follows:
\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position, velocity and acceleration.
 Other errors are unknown at the start of the integration and so will be
 initialized as zero.
\end_layout

\begin_layout Enumerate
The covariance matrix characterizing the errors in the error-state-vector
 is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\Phi$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units except those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides at least an approximate
 calculation of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function of the state vector, so the
 state transition matrix is the sum of that Jacobian (multiplied by the
 time step) and the 15-element diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF.
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are known, the covariance matrix can be updated via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X9 diagonal matrix representing how the nine measured differences
 (GPS-INS) correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise-covariance matrix representing the GPS noise,
 a 9x9 matrix having diagonal elements that are the squares of these components:
 {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1, 0.001, 0.001, 0.001}.
 The effect of measured accelerations is more complex.
 The l-frame errors in acceleration, transformed to the a-frame, correspond
 directly to the measured accelerations from the INU (BLATA, BLONGA, BNORMA),
 so appropriate coupling is to include the appropriate direction-cosine
 transformation matrix as the coupling between the GPS measurements and
 the IRU-provided accelerations.
 This requires that 
\begin_inset Formula $\mathbf{H}$
\end_inset

 contain components in the submatrix 
\begin_inset Formula $\mathbf{H}_{7-9,13-15}$
\end_inset

 that are 
\begin_inset Formula $\mathbf{R}_{l}^{a}$
\end_inset

 as defined previously.
 
\end_layout

\begin_layout Enumerate
Define 
\series bold

\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 
\series default
as the set of nine measurements consisting of the differences between GPS
 and INS positions, velocities and accelerations.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate, because it is expected that the errors vary slowly.
 Turns and other maneuvers can introduce spurious effects if time delays
 are not adjusted well.
 For these reasons, a 1-Hz data file will be used for the following example,
 and the measurements of components of the velocity and of the attitude
 angles as well as the rotation rates and accelerations will be smoothed
 before applying the Kalman filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-s smoothing of accelerations and 301-s smoothing of measured velocity
 components and attitude angles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 			
\end_layout

\begin_layout Plain Layout

Project = "DW"     		
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

D1 <- getNetCDF (fname, VarList)
\end_layout

\begin_layout Plain Layout

## remove heading adjustment as added during initial processing
\end_layout

\begin_layout Plain Layout

Z <- data.frame(getAttributes(D1$THDG, .print=FALSE))
\end_layout

\begin_layout Plain Layout

if ('CalibrationCoefficients' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

  THDGoffset <- Z$CalibrationCoefficients[1]
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  THDGoffset <- 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

D1$THDG <- (D1$THDG - THDGoffset) %% 360
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

# D1$BYAWR <- D1$BYAWR - 0.005
\end_layout

\begin_layout Plain Layout

# D1$BROLLR <- D1$BROLLR + 0.0005
\end_layout

\begin_layout Plain Layout

# D1$BPITCHR <- D1$BPITCHR + 0.0005
\end_layout

\begin_layout Plain Layout

# D1$BNORMA <- D1$BNORMA*1.005 - 0.015
\end_layout

\begin_layout Plain Layout

# D1$BLONGA <- D1$BLONGA * 0.96
\end_layout

\begin_layout Plain Layout

# D1$BLATA <- D1$BLATA * 1.1
\end_layout

\begin_layout Plain Layout

s <- -120
\end_layout

\begin_layout Plain Layout

si <- 0
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

SHIFT <- FALSE
\end_layout

\begin_layout Plain Layout

SHIFT <- TRUE
\end_layout

\begin_layout Plain Layout

if (SHIFT) {
\end_layout

\begin_layout Plain Layout

  D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)
\end_layout

\begin_layout Plain Layout

  D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
\end_layout

\begin_layout Plain Layout

  # Data$BLONGA <- ShiftInTime (Data$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BLATA <- ShiftInTime (Data$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

  # Data$BNORMA <- ShiftInTime (Data$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dt <- 1    ## this is a 1-Hz file
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

## the following is commented because the centripetal effect is already
 included in 'Gravity()'
\end_layout

\begin_layout Plain Layout

# Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT *
 Cradeg)^2 + D1$GGALT)
\end_layout

\begin_layout Plain Layout

#interpolate if necessary: otherwise later filters fail
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

D1$GGVNS <- ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGVEW <- ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGVSPD <- ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap,
 na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D1$VNS <- vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm =
 FALSE)
\end_layout

\begin_layout Plain Layout

D1$VEW <- vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm =
 FALSE)
\end_layout

\begin_layout Plain Layout

D1$VSPD <- vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

## smooth the measurements when determining derivatives
\end_layout

\begin_layout Plain Layout

.span <- 11    
\end_layout

\begin_layout Plain Layout

## The following are accelerations determined from derivatives of the GPS
 velocities.
\end_layout

\begin_layout Plain Layout

## These should match the measured accelerations after transformation to
 the l-frame
\end_layout

\begin_layout Plain Layout

## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

D1$vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

D1$vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

D1$vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

G <- D1$Grav
\end_layout

\begin_layout Plain Layout

VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection
 (D1, VL)
\end_layout

\begin_layout Plain Layout

AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

fa3 <- lm(D1$BNORMA ~ AA[, 3])
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

AL <- AL + RotationCorrection (D1, VL)  ##### check this sign and prev call
 above
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

.span <- 301
\end_layout

\begin_layout Plain Layout

SMOOTH <- FALSE
\end_layout

\begin_layout Plain Layout

if (SMOOTH) {
\end_layout

\begin_layout Plain Layout

  vns <- signal::sgolayfilt (vns, 3, .span)
\end_layout

\begin_layout Plain Layout

  vew <- signal::sgolayfilt (vew, 3, .span)
\end_layout

\begin_layout Plain Layout

  vspd <- signal::sgolayfilt (vspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
\end_layout

\begin_layout Plain Layout

  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
\end_layout

\begin_layout Plain Layout

  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
\end_layout

\begin_layout Plain Layout

  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
\end_layout

\begin_layout Plain Layout

  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  D1$VNSF <- vns
\end_layout

\begin_layout Plain Layout

  D1$VEWF <- vew
\end_layout

\begin_layout Plain Layout

  D1$VSPDF <- vspd
\end_layout

\begin_layout Plain Layout

  D1$GGVNSF <- ggvns
\end_layout

\begin_layout Plain Layout

  D1$GGVEWF <- ggvew
\end_layout

\begin_layout Plain Layout

  D1$GGVSPDF <- ggvspd
\end_layout

\begin_layout Plain Layout

  D1$PITCHF <- pitch
\end_layout

\begin_layout Plain Layout

  D1$ROLLF <- roll
\end_layout

\begin_layout Plain Layout

  D1$THDGF <- thdg
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## get the pitch and roll in the l-frame:
\end_layout

\begin_layout Plain Layout

.thdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

D1$PITCHL <- D1$PITCH * cos (.thdg) - D1$ROLL * sin (.thdg)
\end_layout

\begin_layout Plain Layout

D1$ROLLL <-  D1$PITCH * sin (.thdg) + D1$ROLL * cos (.thdg)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fm1 <- lm (D1$vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (D1$vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (D1$vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the a-frame and compared to the measured accelerat
ions from the IRU (with correction for the Earth's rotation and the motion
 of the l-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

., with a residual standard error of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The differentiated measurements of velocity components from the GPS can
 be considered as additional measurements corresponding to the measured
 accelerations.
 This is discussed further in the following sections.
\end_layout

\begin_layout Subsection*
Detecting the error in heading
\end_layout

\begin_layout Standard
Most of the components of the state vector have good feedback from GPS-derived
 measurements, but an exception is the measurement of heading.
 For position and velocity, there is direct correspondence between INS-
 and GPS-derived measurements.
 For pitch and roll, there is strong coupling to errors in the eastward
 and northward components of aircraft velocity.
 However, the coupling of INS-measured heading to GPS observations is not
 a case of strong coupling (to which the Schuler oscillation applies), and
 it is more difficult to update via measurements from the GPS receiver.
 As specified above, the differentiated GPS velocities provide an l-frame
 measurement of acceleration, and these can be transformed back to the a-frame
 to provide measurements that correspond to BLATA, BLONGA, and BNORMA.
 However, a difference in a-frame accelerations from the two sources can
 arise not only from errors in the measured accelerations but also (and
 more likely) from an error in heading, which would cause incorrect translation
 between l-frame and a-frame components.
 The source of coupling between GPS-derived measurements and heading is
 via the aircraft-velocity components, because an error in heading causes
 the IRU-measured accelerations to be resolved into the 
\emph on
l-
\emph default
frame incorrectly and so introduces errors in the aircraft-velocity components
 that can be detected via comparison to GPS-provided velocity components.
 Unfortunately, in most cases the measured accelerations are small, resulting
 in large uncertainties in any correction term except during turns.
 There are three possible approaches, all of which have been tried in this
 study:
\end_layout

\begin_layout Enumerate
The Kalman-filter structure as described above will use the errors in velocity
 to correct the state vector.
 Via the derivative coefficient matrix, the horizontal-velocity errors are
 dependent on errors in horizontal-acceleration as well as on attitude-angle
 errors, esp.
\begin_inset space ~
\end_inset

via strong coupling to the errors in roll and pitch.
 The coupling to heading is typically an order of magnitude weaker.
 Without special attention, the coupling to heading potentially can be obscured
 by the other sensitivities, through which the errors in velocity can be
 attributed to error-state components in horizontal acceleration and in
 roll and pitch.
 In turn, an error in heading is dependent mostly on errors in the gyro
 rotation rates.
 These sensitivities make it difficult to obtain a reliable adjustment of
 heading in the standard approach, although an estimate can be obtained.
\end_layout

\begin_layout Enumerate
The 
\emph on
l-
\emph default
frame accelerations measured by differentiating the GPS-derived horizontal
 velocity components can be used as additional components of the observation
 vector, complementing the position and velocity measurements from GPS.
 These accelerations can then be used as independent measurements of acceleratio
n.
 While this provides some additional adjustable parameters for the filter
 associated with the covariances of the GPS-derived accelerations, the errors
 in acceleration can still be attributed to errors in the measured accelerations.
 This seems to add little to the sensitivity, and indeed in tests this led
 to changes in pitch and roll corrections that appeared to produce degraded
 results.
\end_layout

\begin_layout Enumerate
A more direct approach is to compare the measured horizontal-acceleration
 vector obtained by transforming the measured 
\emph on
a-
\emph default
frame accelerations to the 
\emph on
l-
\emph default
frame and comparing their horizontal direction to the direction of acceleration
 determined by differentiating the GPS-measured components of horizontal
 velocity.
 The difference is a measure of the heading error and can be used as a component
 of the observation vector 
\begin_inset Formula $\mathbf{Z}$
\end_inset

 with which to update the heading.
 That is, the error in heading is measured to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}

\end_inset

where 
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

 and 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

 are the 
\emph on
l-
\emph default
frame accelerations obtained by transforming the IRU-measured accelerations
 from the 
\emph on
a-
\emph default
frame to the 
\emph on
l-
\emph default
frame and 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

 are the eastward and northward components of the acceleration obtained
 from the time-derivatives of the GPS-measured eastward and northward velocity
 components 
\begin_inset Formula $v_{e}$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

.
 The assumption made when using this formula is that the errors in the INS-produ
ced accelerations in the 
\emph on
l-
\emph default
frame arise from the heading error with negligible contribution from the
 errors in the accelerometers.
 If this is the case, it would be possible to base the heading correction
 on this formula alone, but the more general case needs to consider how
 this might be influenced by errors in accelerations, so it is preferable
 to incorporate this into the Kalman filter and allow for the possibility
 that measured accelerations need to be adjusted.
\end_layout

\begin_layout Standard
The third approach leads to noisy estimates of the correction 
\begin_inset Formula $\delta\psi$
\end_inset

 except when accelerations are significant.
 Because significant accelerations occur mostly in turns when both angles
 in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) are changing rapidly, it is very important to have correct relative timing
 between the INS measurement of heading and the GPS measurement of velocity.
\begin_inset Foot
status open

\begin_layout Plain Layout
As an illustration, a 50-ms delay in heading during a 3-min turn causes
 a shift in heading relative to the correct time of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

, so adjustment to at least this uncertainty is desirable.
 
\end_layout

\end_inset

 The GPS measurements are assigned correct times by the GPS receiver and
 represent a standard clock against which to compare other measurements.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that the relative timing between the IRU and the GPS can drift
 enough during some flights to introduce significant errors.
\end_layout

\end_inset

 If the GPS-vs-INS time shift is not removed, a bias will be introduced
 into the heading correction that varies with turn direction.
 Therefore the following procedure is followed to remove this time shift:
\end_layout

\begin_layout Enumerate
Differentiate the GPS-provided measurements to obtain 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Transform the unshifted body accelerations to the 
\emph on
l-
\emph default
frame, with rotation corrections, to obtain the eastward and northward component
s of acceleration (
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

, 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

) in the local-level frame.
 
\end_layout

\begin_layout Enumerate
Find the heading correction for unshifted measurements by calculating 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

).
\end_layout

\begin_layout Enumerate
Calculate the running-standard-deviation of 
\begin_inset Formula $\delta\psi$
\end_inset

 spanning 30 seconds.
 Select the subset of 
\begin_inset Formula $\delta\psi$
\end_inset

 for which that standard deviation is less than 0.2
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fit the subset to find the slope 
\begin_inset Formula $b$
\end_inset

 in the relationship 
\begin_inset Formula $\delta\psi=a+b\thinspace\tan\phi$
\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle.
 The rate of turn 
\begin_inset Formula $R$
\end_inset

 is related to the roll angle 
\begin_inset Formula $\phi$
\end_inset

 according to the relationship 
\begin_inset Formula $R=g\thinspace\tan\phi/V$
\end_inset

 where 
\begin_inset Formula $V$
\end_inset

 is the airspeed, so 
\begin_inset Formula $\tan\phi=RV/g$
\end_inset

 and 
\begin_inset Formula $\delta\psi=a+bRV/g$
\end_inset

.
 A time delay of 
\begin_inset Formula $\delta t$
\end_inset

 produces a heading error of 
\begin_inset Formula $-R\delta t$
\end_inset

, so 
\begin_inset Formula $-R\delta t=a+bRV/g$
\end_inset

 and the time shift can be estimated from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta t=-b\frac{V}{g}\label{eq:deltaT}
\end{equation}

\end_inset

For example, for DEEPWAVE flight 16, 
\begin_inset Formula $b=0.2146^{\circ}$
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 = 0.003745
\begin_inset space \thinspace{}
\end_inset

rad
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and 
\begin_inset Formula $V\simeq240$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, so (with g=9.8
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

) 
\begin_inset Formula $\delta t=$
\end_inset

-0.092
\begin_inset space ~
\end_inset

s.
 The negative sign indicates that the INS-derived measurement of heading
 should be shifted forward in time by 92
\begin_inset space \thinspace{}
\end_inset

ms relative to the GPS-derived measurements of aircraft velocity.
 The standard error from the fit indicates that this shift was determined
 with an uncertainty of about 3
\begin_inset space \thinspace{}
\end_inset

ms, so this is a very sensitive method for determining the time shift.
\end_layout

\begin_layout Enumerate
Apply this time shift to the measurements of heading.
 For a file containing measurements at 1
\begin_inset space ~
\end_inset

Hz, this requires creating an interpolated high-rate vector of measurements,
 shifting that vector, and then extracting a shifted 1-Hz vector from the
 shifted measurements.
 The Ranadu function ShiftInTime() accomplishes this by interpolating to
 a 125-Hz variable.
 The result can be checked by repeating step 5 using the shifted measurements;
 for this case, the deduced shift needed for the shifted time series was
 only 1
\begin_inset space ~
\end_inset

ms.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It may be useful to incorporate in addition a time dependence, either to
 the time shift or to the correction factor.
 Preliminary study of this indicates that a time dependence is significant,
 as represented for example via he~tan(ROLL)+Ts where Ts=as.vector(Data$Time-Data
$Time[1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After an appropriate time shift is introduced, (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is an appropriate measurement of heading to include in the matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, where the appropriate components associated the heading error (component
 9 in the error-state vector) with components 7 and 8 in the measurement
 vector 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

.
 Specifically, column 9 in 
\begin_inset Formula $\mathbf{H}$
\end_inset

 should have contributions from rows 7 and 8.
 Formulated in this way, the dependence is complex and non-linear, so it
 is simpler to add a 10th component to the measurement vector with value
 given by 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) and associate that directly (with coefficient 1 after appropriate conversion
 from radians to degrees) with column 9 of the information matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, which then must have 10 rows and 15 columns.
\end_layout

\begin_layout Standard
Because typical horizontal accelerations in the l-frame are small, this
 estimate of the heading error is too noisy to be useful except in turns
 where the horizontal accelerations are significant, often about 3
\begin_inset space ~
\end_inset

m/s
\begin_inset Formula $^{2}$
\end_inset

.
 In normal straight flight, the standard deviation in the estimate obtained
 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is around 15
\begin_inset Formula $^{\circ}$
\end_inset

, but in turns this standard deviation reduces to typically about 0.03
\begin_inset Formula $^{\circ}$
\end_inset

.
 This has two important consequences.
 First, flights without turns or other sources of horizontal acceleration
 will lack the information for adjusting the heading.
 so in flights where this is important regular turns should be part of the
 flight plans.
 Second, when the GPS-based estimate of the heading error is used, an appropriat
e variance should be assigned to prevent excessive noise from affecting
 the result from the Kalman filter.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, but this will not be part of this initial study because the accelerometers
 appear to have low uncertainty and because the effect of errors in acceleration
 would also appear as errors in velocity and so should be detected by the
 conventional 6-component measurement vector for Kalman filtering.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initial values of the state vector and error-state vector:
\end_layout

\begin_layout Plain Layout

SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

## also need the corresponding noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data
 record
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 30 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 30 / (sp$Rn * cos (sv$LAT))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 150
\end_layout

\begin_layout Plain Layout

  gcf[4:6] <- 0.3    ## 0.3
\end_layout

\begin_layout Plain Layout

  gcf[7:8] <- 0.005*Cradeg  ## 0.005
\end_layout

\begin_layout Plain Layout

  gcf[9] <- 0.015*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[10:11] <- 0.003*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[12] <- 0.003*Cradeg       ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.00002
\end_layout

\begin_layout Plain Layout

  # gcf <- as.vector(gcf) * sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[1, ]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model: calculate the measurements of acceleration from
 the GPS to add to the measurement vector
\end_layout

\begin_layout Plain Layout

GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
\end_layout

\begin_layout Plain Layout

dim(GAEL) <- c(DL, 3)
\end_layout

\begin_layout Plain Layout

## transform to the a-frame
\end_layout

\begin_layout Plain Layout

GAE <- XformLA (D1, GAEL, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS,
 VSPD-GGVSPD))
\end_layout

\begin_layout Plain Layout

# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later
\end_layout

\begin_layout Plain Layout

## The last three components provide direct feedback to measured acceleration
\end_layout

\begin_layout Plain Layout

## in the a-frame but also provide feedback to heading, as developed below
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 9)
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 6)
\end_layout

\begin_layout Plain Layout

# DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

## now add the pseudo-measurement of heading error found from the accelerations:
\end_layout

\begin_layout Plain Layout

D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
\end_layout

\begin_layout Plain Layout

D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the
 std dev
\end_layout

\begin_layout Plain Layout

## add the heading correction to the measurement vector
\end_layout

\begin_layout Plain Layout

DZ <- c(as.vector(DZ), D1$deltaPsi)
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 7)
\end_layout

\begin_layout Plain Layout

DZ[ ,1:2] <- DZ[ ,1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The observation matrix: (the first six and last three components of the
 state error 
\end_layout

\begin_layout Plain Layout

## vector are observable, the latter requiring transformation from l-frame
 to a-frame)
\end_layout

\begin_layout Plain Layout

## components 7-9 are connected to IRU-measured rotation rates via the transform
ation matrix l->a,
\end_layout

\begin_layout Plain Layout

## so matrix H must vary with aircraft attitude angles.
 This is addressed by the GAEL->GAE transform.
\end_layout

\begin_layout Plain Layout

# H <- diag(1, nrow=10, ncol=15)
\end_layout

\begin_layout Plain Layout

# for (k in 7:9) {
\end_layout

\begin_layout Plain Layout

#   H[k,k] <- 0
\end_layout

\begin_layout Plain Layout

#   H[k,k+6] <- 1
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

# H[10,9] <- 1
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=7, ncol=15)
\end_layout

\begin_layout Plain Layout

H[7,7] <- 0
\end_layout

\begin_layout Plain Layout

H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component
 9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,100), ncol=10)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,49), ncol=7)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (10/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (10/(D1$Rn[1]*cos(SV$LAT)))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 100^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 0.3^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 0.3^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 0.3^2
\end_layout

\begin_layout Plain Layout

# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measureme
nt.
\end_layout

\begin_layout Plain Layout

# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an
 error in heading, not
\end_layout

\begin_layout Plain Layout

# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration
 is used for that.
\end_layout

\begin_layout Plain Layout

# RCV[10,10] <- D1$sdPsi[1]^2
\end_layout

\begin_layout Plain Layout

# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
\end_layout

\begin_layout Plain Layout

# # RCV[10, 10] <- 1000  ## suppress effect
\end_layout

\begin_layout Plain Layout

RCV[7,7] <- 1000  ## but update this each time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix with generous variances
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, echo=FALSE, eval=TRUE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- D1
\end_layout

\begin_layout Plain Layout

DL <- nrow (Data)
\end_layout

\begin_layout Plain Layout

  # find PITCHL, ROLLL in the l-frame
\end_layout

\begin_layout Plain Layout

  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal
 to AC
\end_layout

\begin_layout Plain Layout

  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
\end_layout

\begin_layout Plain Layout

  # UVL <- XformLA (Data, UV)
\end_layout

\begin_layout Plain Layout

  # PitchL <- asin (-UVL[,2])
\end_layout

\begin_layout Plain Layout

  # RollL <- asin (UVL[,1])
\end_layout

\begin_layout Plain Layout

  #   .hdg <- Data$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## note: if using l-frame PITCH and ROLL; STMFV must account for this
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

NSTEP <- 5      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

CVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

                    ## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

## pitch and roll errors are going to be those in the l-frame; leave a-frame
 for now
\end_layout

\begin_layout Plain Layout

SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

CVEF[1, ] <- diag (CV)
\end_layout

\begin_layout Plain Layout

# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
\end_layout

\begin_layout Plain Layout

# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
\end_layout

\begin_layout Plain Layout

pctL <- 0
\end_layout

\begin_layout Plain Layout

for (i in seq(2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

  pct <- as.integer(100*i/DL)
\end_layout

\begin_layout Plain Layout

  if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d',
 pct));pctL <- pct}
\end_layout

\begin_layout Plain Layout

  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH,
 ROLL, THDG,
\end_layout

\begin_layout Plain Layout

                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- Data$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- Data$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- Data$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new error-state vector:
\end_layout

\begin_layout Plain Layout

  ## the pitch and roll error derivatives are now those in the a-frame,
 but
\end_layout

\begin_layout Plain Layout

  ##   the pitch/roll error state is in the l-frame.
 Save the l-frame error state:
\end_layout

\begin_layout Plain Layout

#   SVEL <- SVEA <- SVE
\end_layout

\begin_layout Plain Layout

#   ## Transform l-frame pitch/roll error state to a-frame
\end_layout

\begin_layout Plain Layout

#   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

#   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

#   ## apply derivatives to get a-frame change
\end_layout

\begin_layout Plain Layout

#   SVEA <- dcm %*% SVEA
\end_layout

\begin_layout Plain Layout

#   ## transform back to l-frame
\end_layout

\begin_layout Plain Layout

#   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

#   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE    ## take time step in error-state vector
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  if (is.na(Data$sdPsi[i]) || (sqrt(Data$LACCX[i]^2+Data$LACCY[i]^2) < 0.1))
 {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- 0
\end_layout

\begin_layout Plain Layout

    # DZ[i, 7] <- NA
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- 0.0
\end_layout

\begin_layout Plain Layout

    RCV[7, 7] <- Data$sdPsi[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

  CVEF[i/NSTEP, ] <- diag(CV)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

  if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

  x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

  T <- A$y
\end_layout

\begin_layout Plain Layout

  T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

  ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

  n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

  NL = length(T)
\end_layout

\begin_layout Plain Layout

  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

  return (T)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

VCor <- vector ('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (VCor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$ALTKF <- Data$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

Data$VEWKF <- Data$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

Data$VNSKF <- Data$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

Data$VSPDKF <- Data$VSPD - Cor[, 6]
\end_layout

\begin_layout Plain Layout

Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

Data$BLATAKF <- Data$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$DLAT <- Data$LATKF-Data$GGLAT
\end_layout

\begin_layout Plain Layout

Data$CLAT <- -Cor[, 1] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DLON <- Data$LONKF-Data$GGLON
\end_layout

\begin_layout Plain Layout

Data$CLON <- -Cor[, 2] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$DALT <- Data$ALTKF-Data$GGALT
\end_layout

\begin_layout Plain Layout

Data$CALT <- -Cor[, 3]
\end_layout

\begin_layout Plain Layout

Data$DVEW <- Data$VEWKF-Data$GGVEW
\end_layout

\begin_layout Plain Layout

Data$CVEW <- -Cor[, 4]
\end_layout

\begin_layout Plain Layout

Data$DVNS <- Data$VNSKF-Data$GGVNS
\end_layout

\begin_layout Plain Layout

Data$CVNS <- -Cor[, 5]
\end_layout

\begin_layout Plain Layout

Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
\end_layout

\begin_layout Plain Layout

Data$CVSPD <- -Cor[, 6]
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- -Cor[, 7] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CROLL <- -Cor[, 8] / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- -Cor[, 9] / Cradeg
\end_layout

\begin_layout Plain Layout

KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude,
 longitude, and altitude for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                    "Comparison of the KF, GPS, and INS values of aircraft-veloc
ity components for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines show the corrections
 applied to the original INS values by the Kalman filter.",
\end_layout

\begin_layout Plain Layout

                      "Pitch Correction from the Kalman filter (CPITCH,
 blue line) and from Ranadu::CorrectPitch (PC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Roll Correction from the Kalman filter (CROLL) and
 from Ranadu::CorrectPitch (RC, red line)",
\end_layout

\begin_layout Plain Layout

                      "Heading Correction from the Kalman filter (CTHDG)
 and from Ranadu::CorrectHeading (HC, green line)")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Results
\end_layout

\begin_layout Standard
There are several tests that the corrected values should pass:
\end_layout

\begin_layout Enumerate
Because the GPS measurements of position and aircraft velocity have low
 uncertainty, the KF values should match these in long-term average, perhaps
 with some high-frequency components not present in the GPS-provided measurement
s.
\end_layout

\begin_layout Enumerate
The pitch-correction algorithm developed in the Tech Note should give results
 in reasonable agreement with the KF values of pitch and roll.
\end_layout

\begin_layout Enumerate
The heading-correction algorithm should also produce results consistent
 with the KF results.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=c("Comparison of the KF,
 GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight
 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.",
 "Comparison of the KF, GPS, and INS values of aircraft-velocity components
 for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines show the corrections
 applied to the original INS values by the Kalman filter.", "Pitch Correction
 from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch
 (PC, red line)", "Roll Correction from the Kalman filter (CROLL) and from
 Ranadu::CorrectPitch (RC, red line)", "Heading Correction from the Kalman
 filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)), ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch(Data, .span=601)
\end_layout

\begin_layout Plain Layout

Data$PC <- -PC[, 1]
\end_layout

\begin_layout Plain Layout

Data$RC <- -PC[, 2]
\end_layout

\begin_layout Plain Layout

## translate pitch/roll corrections to the a-frame:
\end_layout

\begin_layout Plain Layout

.hdg <- Data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

C7 <- SmoothInterp (Cor[, 7], .Length=181)
\end_layout

\begin_layout Plain Layout

C8 <- SmoothInterp (Cor[, 8], .Length=181)
\end_layout

\begin_layout Plain Layout

# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# Data$CPITCH <- CPITCH / Cradeg
\end_layout

\begin_layout Plain Layout

# Data$CROLL <- CROLL / Cradeg
\end_layout

\begin_layout Plain Layout

Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$CTHDG <- SmoothInterp (Data$CTHDG, .Length=181)
\end_layout

\begin_layout Plain Layout

Data$HC <- -CorrectHeading (Data, .plotfile='./HCPlot.pdf')
\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 70000, 123000)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH
 CORRECTION',' [',degree,']')), 
\end_layout

\begin_layout Plain Layout

        ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='t
opright')
\end_layout

\begin_layout Plain Layout

ival <- abs(Data$ROLL) > 4
\end_layout

\begin_layout Plain Layout

Data$CPITCH[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$PC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), 
\end_layout

\begin_layout Plain Layout

      ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
\end_layout

\begin_layout Plain Layout

      ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topr
ight')
\end_layout

\begin_layout Plain Layout

Data$CROLL[ival] <- NA
\end_layout

\begin_layout Plain Layout

Data$RC[ival] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylim=c(-0.4,0.4), lwd=0.7,
 legend.position='topright')
\end_layout

\begin_layout Plain Layout

HE <- VCor[,9]
\end_layout

\begin_layout Plain Layout

HE[HE < 0.0025] <- 0.0025
\end_layout

\begin_layout Plain Layout

HE <- sqrt(HE)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

iv <- HE > 0.051
\end_layout

\begin_layout Plain Layout

CCTHDG <- Data$CTHDG
\end_layout

\begin_layout Plain Layout

CCTHDG[iv] <- NA
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r]^2, spar=1.25)
\end_layout

\begin_layout Plain Layout

Data$HCS <- predict(SS, as.numeric(Data$Time))$y
\end_layout

\begin_layout Plain Layout

lineWAC(Data$Time[r], Data$HCS[r], col='red')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
– End of Memo –
\end_layout

\begin_layout Standard
Reproducibility:
\begin_inset Note Note
status open

\begin_layout Plain Layout
include enough info to re-run.
 in zip, include program, pdf if not too big, and subset data, not entire
 file.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.zip
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.Rnw
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

/scr/raf
\backslash
_data/
\backslash
Sexpr{Project}/
\backslash
Sexpr{Flight}.nc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{thisFileName}.pdf
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/
\backslash
Sexpr{thisFileName}.git
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
