%% LyX 2.1.4 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\usepackage{babel}
\begin{document}
\EOLmemo 

\global\addressee={Wind Uncertainty TN file}  

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & A Kalman filter to apply corrections to the wind measurements\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
thisFileName <- "KalmanFilter"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)
library (TTR)
setwd ('~/RStudio/Ranadu/KalmanFilter')
## temporary until Ranadu updated:
source ('~/RStudio/Ranadu/R/HeadingCorrection.R')
source ('~/RStudio/Ranadu/R/PitchCorrection.R')
Directory <- DataDirectory ()
Flight <- "rf15HR" 				# XXX change this
Project = "DWIRU"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
# ReloadData <- TRUE
SaveRData <- sprintf("%s.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  save (Data, file=SaveRData)
} else {
  load (file=SaveRData)
}

@


\section*{Introduction and scope}

The intent of this study is to evaluate the errors present in the
measurements of attitude angles from the IRU on the NSF/NCAR~GV by
means of a Kalman filter applied to the difference between measurements
from a GPS and corresponding measurements from the IRU. The redundant
measurements are those of position and velocity,\footnote{Because GPS measurements of velocity have low uncertainty, those measurements
could be differentiated and, after transformation to the aircraft
reference frame, used as error measurements for the measured accelerations.
This has not been explored as yet, and it is not clear that this would
provide information beyond that arising from the Kalman-filter updates
using only velocity.} for which the GPS measurements are clearly superior especially at
low rate, so a necessary result will be that the corrected measurements
should be quite close to those from the GPS. The advantage of this
analysis, though, is that the coupling between errors in the attitude
angles and those in velocity makes it possible to evaluate the errors
in the attitude angles also.

Before describing the implementation of the filter, it is useful to
explain the basic concept underlying a Kalman filter. A Kalman filter
provides a means of updating a sequence of state vectors (consisting,
in the present case, of INS measurements of position, velocity, and
attitude angles) by comparison to an independent set of measurements
(e.g., GPS-derived measurements of position and velocity). The updated
state vector obtained by this process consists of an appropriately
weighted combination of the state vector projected forward using normal
INS ``mechanization'' (i.e., determining the next step by using
the measured acceleration and rotation from the IRU) and the independent
measurements from GPS. Because errors in the state vector are coupled,
the update procedure can estimate errors in the attitude angles as
well as the components of the state vector that are measured directly
by the GPS. This is the primary reason for using a Kalman filter to
improve the wind measurements: Although the measurements of position
and velocity that result should differ little from those provided
by the GPS, the corrections to the attitude angles (pitch, roll, and
heading) can be estimated even though there is no direct measurement
of these except from the INS.

The weighting of the projected-forward state and new measurements
from GPS depends on obtaining estimates of the covariance matrix describing
the state vector as well as estimates of the noise sources contaminating
the measurements from both the GPS and the IRU-provided accelerations
and rotations. With proper weighting, the result should combine the
good high-frequency response of the INS with the good long-term stability
of the GPS. The covariance matrix characterizing the state vector
is updated as the filter is applied, but appropriate weighting depends
on reasonable estimation of the other error terms.

The operation of the filter depends on sequential use of a set of
matrices, so it is useful to define those as follows, where the variable
names following the symbols are the R variable names used in the following
code:
\begin{lyxlist}{00.00.0000}
\item [{$\delta\mathbf{x}_{k}$~{[}SVE{]}}] The error-state vector at
time interval $k$. In the present case, this consists of the 15 components
estimated errors in position, aircraft velocity, aircraft attitude,
IRU-measured rotation rate, and IRU-measured accelerations.
\item [{$\mathbf{T}_{k|k-1}$~{[}dcm{]}}] The 15x15 state transformation
matrix describing INS mechanism for the change from time $k-1$ to
time $k$. Then $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
where $\mathbf{T}$ combines the unit diagonal matrix with the time
step multiplied by the derivative matrix describing the state transformation.
As applied to the state vector, this state transformation matrix would
involve the derivatives used for normal INS mechanization to get how
the state vector advances, and so would duplicate the action of the
internal INS data processing. As interpreted for an error-state Kalman
filter, the matrix $\mathbf{T}$ is obtained by calculating the Jacobian
of that state-transition function as a function of the error-state
components. 
\item [{$\mathbf{V}$~{[}CV{]}}] The covariance matrix that applies to
the state vector $\delta\mathbf{x}$, a 15x15 matrix
\item [{$\mathbf{K}$~{[}K{]}}] The Kalman-gain matrix representing how
the error-state vector is updated using the current error state and
the new GPS measurements.
\item [{$\delta\mathbf{z}$~{[}DZ{]}}] The 6-component measured differences
between the INS and GPS measurements of position and velocity.
\item [{$\mathbf{H}$~{[}H{]}}] The 15x6-component matrix representing
how the measured differences $\delta\mathbf{z}$ correspond to the
state vector. 
\item [{$\mathbf{Q},\,\mathbf{R}$~{[}Q,~R{]}}] Matrics representing
respectively the anticipated noise contributions affecting the error-state
vector (15x15) and the measurements from the GPS (6x6).
\end{lyxlist}
The approach taken here will be to filter the error-state vector that
represents the difference between the best-estimate measurements and
those originally provided by the INS. The INS integration does not
need to be duplicated here to obtain the reference solution because
that is already available. However, the Kalman filter does need the
``state transition matrix'' that represents the forward integration,
so the first step in this analysis is to obtain such a matrix and
validate results using it against the available INS solution. The
Jacobian of that state-transition function then provides the matrix
$\mathbf{T}$ used in this filter.


\section*{Some component functions}

Some of the operations involved in that ``mechanization'' are contained
in the following functions, with code as in the associated R ``chunks.''
\begin{enumerate}
\item \emph{\uline{XfLArV()}}, a function of the current state vector,
provides a 3x3 matrix that transforms a vector from the a-frame (the
aircraft reference frame) to the l-frame, the local-level frame (with
\{x,y,z\} coordinates toward the East, North, and upward directions). 
\item \emph{\uline{RotationCorrection()}} calculates the correction to
accelerations needed to account for the rotation of the Earth and
of the l-frame relative to an inertial frame. This function provides
corrections to subtract from transformed accelerations before using
them in the l-frame.
\item \emph{\uline{STMFV()}} calculates the 15-component derivative of
the state vector given the state vector and the measurements from
the INU. This function is then used in the R function numDeriv::jacobian
to find the Jacobian needed for the state transformation matrix.
\end{enumerate}
<<utility-functions, include=TRUE, echo=FALSE>>=

XfLArV <- function (data) {   ## XfLA but using input in radians and single row
  # data must contain PITCH, ROLL, HEADING as components [7:9]
  cosphi <- cos (data[8])
  sinphi <- sin (data[8])
  costheta <- cos (data[7])
  sintheta <- sin (data[7])
  cospsi <- cos (data[9])
  sinpsi <- sin (data[9])
  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-sinpsi*sintheta*cosphi,
           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinphi-cospsi*sintheta*cosphi,
           -sintheta, costheta*sinphi, -costheta*cosphi)
  RblM <- aperm( array (Rbl, dim=c(3,3)))
  return (RblM)
}

XPitch <- function (pitch, roll, heading, .inverse=FALSE) {  # a-frame to l-frame
  ## note: all in units of radians
  if (!.inverse) {
    pitchL <- -asin(-cos (heading) * sin (pitch) * cos (roll) - sin (heading) * sin (roll))
    rollL  <-  asin(-sin (heading) * sin (pitch) * cos (roll) + cos (heading) * sin (roll))
    A <- c(pitchL, rollL)
    dim(A) <- c(length(pitch),2)
    return (A)
  } else {
    lx <- sin (roll)
    ly <- -sin (pitch)
    lz <- -sqrt (1 - lx^2 - ly^2)
    pitchA <- atan2 (lx * sin (heading) + ly * cos (heading), lz)
    pitchA[pitchA < -pi/2] <- pitchA[pitchA < -pi/2] + pi
    pitchA[pitchA >  pi/2] <- pitchA[pitchA >  pi/2] - pi
    # rollA <- acos (lz / cos (pitchA))
    rollA <- atan ((-cos(heading)*lx+sin(heading)*ly) /
                    (sin(heading) * sin(pitchA)*lx+cos(heading)*sin(pitchA)*ly+cos(pitchA)*lz))
    # rollA[rollA > pi/2] <- pi - rollA[rollA > pi/2] 
    A <- c(pitchA, rollA)
    dim(A) <- c(length(pitch), 2)
    return (A)
  }
}

# other-functions ---------------------------------------------------------

Cradeg <- pi/180
dt <- 1/25               ## working with 25-Hz file
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')
Ree <- 6378137
Ecc <- 0.08181919
## The next correction calculates the correction needed to account for the rotation
## of the Earth and of the l-frame (ENU frame). See Noureldin et al., 2013, 
## Eqs. 5.55--5.57. Subtract this from the transformed accelerations before using them.
RotationCorrection <- function (.data, .V) {
  Cradeg <- pi/180
  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
  DL <- nrow (.data)
  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
  lat <- .data$LAT * Cradeg
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  Ree <- 6378137
  Ecc <- 0.08181919
  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
  M23 <- .V[,2] / Rm
  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
  M32 <- -.V[,2] / Rm
  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
  return (C)
}

Gravity <- function (latitude, altitude=0.) {
  sl2 <- (sin (latitude * Cradeg))^2
  g <- 9.780327 * ((1. + 0.001931851 * sl2) / 
                     (1. - 0.006694380 * sl2)) - 3.086e-6 * altitude
  ## Somigliana formula 1980 GRS:
  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 * altitude^2
  return(g)
}

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
Re <- StandardConstant ('Re')
Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
  (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)


LFrame <- TRUE
# LFrame <- FALSE
STMFV <- function (sv, dbg=FALSE) { 
  stmf <- vector('numeric', length=15)
  ## transform pitch and roll back to a-frame 
  if (LFrame) {
    x <- XPitch (sv[7], sv[8], sv[9], .inverse=TRUE)
    sv[7] <- x[1]
    sv[8] <- x[2]
  }
  rlm <- XfLArV(sv)   
  if (dbg) {
    print (sprintf ('sv[7-9]=%f %f %f', sv[7],sv[8],sv[9]))
    print (rlm)
  }
  omega <- as.vector (c(-sv[5] / Rm, 
                        OmegaE*cos(sv[1])+sv[4]/(Rn),
                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2], omega[1], 0), ncol=3)
  Oilb <- Oill %*% rlm
  ## find the derivative of the transformation matrix:
  ## (must recalculate SRM from measured rotation rates)
  SRR <- c(0, -sv[12], -sv[10],
           sv[12], 0, sv[11],
           sv[10], -sv[11], 0)
  SRM <- aperm( array (SRR, dim=c(3,3)))
  dRLA <- rlm %*% SRM - Oilb
  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-frame
  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
  ## now correct for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  VL <- c(sv[4], sv[5], sv[6])
  C <- vector ('numeric', 3)
  lat <- sv[1]
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
  M23 <- VL[2] / Rm
  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
  M32 <- -VL[2] / Rm
  C[1] <- M12 * VL[2] + M13 * VL[3]
  C[2] <- M21 * VL[1] + M23 * VL[3]
  C[3] <- M31 * VL[1] + M32 * VL[2]
  AL <- as.vector (AL - C, mode='numeric')
  AL[3] <- AL[3] + Grav
  AL[3] <- -AL[3]
  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
            0, 0, 0, 0, 0, 0)
  ## transform angle derivatives back to l-frame
  if (LFrame) {
    x <- XPitch (sv[7]+stmf[7], sv[8]+stmf[8], sv[9]+stmf[9]) -
         XPitch (sv[7], sv[8], sv[9])
    stmf[7] <- x[1]
    stmf[8] <- x[2]
    # x <- rlm %*% as.matrix (c(stmf[8], -stmf[7], 0))
    # stmf7 <- stmf[7]
    # stmf8 <- stmf[8]
    # stmf[7] <- cos(sv[9])*cos(sv[7])*cos(sv[8]) * stmf7 + 
    #   (-cos(sv[9])*sin(sv[7])*sin(sv[8]) + cos(sv[9])*cos(sv[8])) *  stmf8
    # stmf[8] <- (cos(sv[9])*cos(sv[7]) - sin(sv[9])*cos(sv[7])*cos(sv[8])) * stmf7 +
    #   sin(sv[9])*sin(sv[7])*sin(sv[8]) * stmf8
  }
  return (as.vector (stmf, mode='numeric'))
}

@

<<INS-data, include=TRUE, echo=FALSE>>=

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
                              PITCH, ROLL, THDG, GGALT, GGVSPD, BLATA, BLONGA, BNORMA, 
                              BPITCHR, BROLLR, BYAWR,
                              GGVEW, GGVNS, Grav))
## adjustments:
SP$BYAWR <- SP$BYAWR - 0.005
SP$BROLLR <- SP$BROLLR + 0.0005
SP$BPITCHR <- SP$BPITCHR + 0.0005
# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
# SP$BLONGA <- SP$BLONGA * 0.96
# SP$BLATA <- SP$BLATA * 1.1
SP$BPITCHR <- SP$BPITCHR * Cradeg
SP$BROLLR <- SP$BROLLR * Cradeg
SP$BYAWR <- SP$BYAWR * Cradeg

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
SPR <- SP   ## save what INS produced, as reference

@


\section*{The integration steps}

The purpose of this section is to demonstrate that the INS mechanization
used to find the error-state transformation matrix provides a valid
and independent means of propagating the measurements of position,
velocity, and attitude forward in time. The procedure used for this
test is as follows:
\begin{enumerate}
\item Initialize a state vector $\mathbf{x}$ having these components:

\begin{enumerate}
\item latitude, longitude, altitude in the l-frame
\item east velocity, north velocity, upward velocity in the l-frame
\item pitch, roll, heading in the a-frame
\item rotation rates about the pitch, roll, and yaw axes of the aircraft
\item acceleration in the lateral, longitudinal, and normal direction relative
to the aircraft reference frame.
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item store the measured rotations and accelerations in the last 6 components
of the state vector
\item via the function STMFV, calculated the time derivative of the state
vector. In the case of the attitude angles, this is done by calculating
the derivative of the transformation matrix from the a-frame to the
l-frame and then using the definition of components of that matrix
to find the derivative of the attitude angles.
\item use that derivative vector to increment the state vector
\item compensate for possible wrap-around of the heading a 0 and 360 deg
so that values stay within that range.
\item save the first 9 components of the state vector in a new data.frame
that represents an independent ``mechanization'' of the INU measurements.
These measurements should then be in reasonable agreement with the
INS solution.
\end{enumerate}
\end{enumerate}
<<mechanization, include=TRUE, echo=TRUE, fig.lp='fig:', fig.cap=' '>>=

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
SP$LAT[1] <- SV$LAT/Cradeg
SP$LON[1] <- SV$LON/Cradeg
SP$ALT[1] <- SV$GGALT
SP$VEW[1] <- SV$VEW
SP$VNS[1] <- SV$VNS
SP$VSPD[1] <- SV$VSPD
## convert pitch/roll of SV to l-frame components:
if (LFrame) {  ## initialize state vector in l-frame 
  x <- XPitch (SV$PITCH, SV$ROLL, SV$THDG)
  SV$PITCH <- x[1]
  SV$ROLL  <- x[2]
}
SP$PITCH[1] <- SV$PITCH
SP$ROLL[1] <- SV$ROLL
SP$THDG[1] <- SV$THDG
twoPi <- 2*pi

sv <- as.vector (SV, mode='numeric')
Rn <- SP$Rn[1]
Rm <- SP$Rm[1]
Grav <- SP$Grav[1]
stmf <- STMFV (sv)  # returns attitude-angle errors in l-frame if LFrame is TRUE
## feedback coefficients for baro loop:
C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
wp3F <- 0;
hxF <- hxxF <- 0
hi3F <- SP$GGALT[1]
RK <- TRUE    ## use Runge-Kutta integration if true
# RK <- FALSE

for (i in 2:DL) {
  Rn <- SP$Rn[i]
  Rm <- SP$Rm[i]
  Grav <- SP$Grav[i]
  sv[10] <- SP$BPITCHR[i]
  sv[11] <- SP$BROLLR[i]
  sv[12] <- SP$BYAWR[i]
  sv[13] <- SP$BLATA[i]
  sv[14] <- SP$BLONGA[i]
  sv[15] <- SP$BNORMA[i]
  if (RK) {
    stmf1 <- STMFV (sv)
    sv1 <- sv + stmf1 * dt/2
    stmf2 <- STMFV (sv1)
    sv2 <- sv + stmf2 * dt/2
    stmf3 <- STMFV (sv2)
    sv3 <- sv + stmf3 * dt
    stmf4 <- STMFV (sv3)
    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
  } else {
    if (i == 12001) {
      dbg <- TRUE
      print (sv)
    } else {
      dbg <- FALSE
    }
    stmf <- STMFV (sv, dbg)
  }
  sv <- sv + stmf * dt
  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
  if (sv[9] > twoPi) {sv[9] <- sv[9] - twoPi}
  ## baro-loop
  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
  hxF <- hi3F - SP$GGALT[i]
  hxxF <- hxxF + hxF * dt
  sv[6] <- 0.5 * (sv[6] + wp3F)
  SP$LAT[i] <- sv[1]
  SP$LON[i] <- sv[2] 
  SP$ALT[i] <- sv[3]
  SP$VEW[i] <- sv[4]
  SP$VNS[i] <- sv[5]
  SP$VSPD[i] <- sv[6]
  SP$PITCH[i] <- sv[7]
  SP$ROLL[i] <- sv[8]
  SP$THDG[i] <- sv[9]
}
SP$LAT <- SP$LAT / Cradeg
SP$LON <- SP$LON / Cradeg
## convert pitch/roll to a-frame components:
if (LFrame) {
  x <- XPitch (SP$PITCH, SP$ROLL, SP$THDG, .inverse=TRUE)
  SP$PITCH <- x[,1]
  SP$ROLL <- x[,2]
}
SP$PITCH <- SP$PITCH / Cradeg
SP$ROLL <- SP$ROLL / Cradeg
SP$THDG <- SP$THDG / Cradeg

@

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparison of INS-provided and integration-derived positions.', 'Comparison of INS-provided and integration-derived components of the aircraft velocity.', 'Comparison of INS-provided and integration-derived attitude angles.')>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
Data$LATX <- SP$LAT
Data$LONX <- SP$LON
Data$ALTX <- SP$ALT
r <- setRange (Data, 33000, 35500)
plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
plotWAC (Data[r, c('Time', 'LON', 'LONX')])
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
Data$VEWX <- SP$VEW
Data$VNSX <- SP$VNS
Data$VSPDX <- SP$VSPD
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
## find attitude angles from RaLM:
Data$PITCHX <- SP$PITCH
Data$ROLLX <- SP$ROLL
Data$THDGX <- SP$THDG
Data$DPITCH <- Data$PITCHX-Data$PITCH
Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
SP <- SPR    ## restore to state before integration

@

The result of that integration is shown in Figs.~1--3, with comparisons
to the INS-produced solutions. There are some differences, but they
are mostly understandable and could be corrected. For example, the
attitude angles show differences in sine waves during the circles
flown during this time segment and suggest a timing error that causes
one signal to be delayed relative to the comparable signal. The INS-produced
solution for altitude has a baro-loop applied to keep the altitude
near the pressure altitude, and that is not applied in this solution
so the vertical wind and position show large drifts. Perhaps the one
aspect that is troublesome is that in VNS and consequently in latitude.
Also, the data used here are the 25-Hz records, while the INS uses
a significantly higher data rate for its corresponding integration.
The remaining differences need further investigation, but the key
result from this part of the study is that as implemented above the
derivatives of components of the state vector are approximately correct
and integrate to reasonable values. The function providing those derivatives
is therefore a reasonable basis for the Kalman filter that follows.


\section*{The Kalman filter}

The preceding steps verify that at least an approximate calculation
of the derivatives of the state variables is available. On that basis,
an error-state Kalman filter can be developed, as follows:
\begin{enumerate}
\item The first step is to initialize an error-state-vector $\delta\mathbf{x}$
from initial measurements of the differences between the INS and GPS
values of position and velocity. Other errors are unknown at the start
of the integration and so will be initialized as zero.
\item The covariance matrix characterizing the errors in the error-state-vector
is also needed. This is here initialized to have rather large components
because it is expected that the GPS measurements will have much lower
unceertainty than these INS-provided components. $\mathbf{V}$ is
initialized as a 15x15 diagonal matrix where the diagonal elements
are the squares of these values: \{2000/$R_{m}$, 2000/($R_{n}$cos$\Phi$),
500, 2, 2, 2, 0.3$^{\circ}$, 0.3$^{\circ}$, 1$^{\circ}$, 0.005$^{\circ}s^{-1}$,
0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.0005, 0.0005, 0.0005\}.
All entries are in SI units escelt those labeled as $^{\circ}$, in
which case the values are converted to radians before use. The variables
$R_{m}$ and $R_{n}$ are appropriate radii of the Earth. (See the
code) 
\item The function STMFV() was verified above and so provides at least an
approximate calculation of the derivatives of the state vector. For
an error-state Kalman filter, the propagation of the error state can
be found from the Jacobian of that function of the state vector, so
the state transition matrix is the sum of that Jacobian (multiplied
by the time step) and the 15-element diagonal matrix:\\
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\item The noise-covariance matrix $\mathbf{Q}$ represents the noise in
the solution. This is initialized as indicated in the code, via function
GCF.
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are known, the covariance matrix
can be updated via\\
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\item The Kalman gain is then given by\\
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]
where $\mathbf{H}$ is a 15X6 diagonal matrix representing how the
6 measured differences (GPS-INS) correspond to the error-state vector.
$\mathbf{R}$ is the measurement-noise-covariance matrix representing
the GPS noise, a 6x6 matrix having diagonal elements that are the
squares of these components: \{50/$R_{m}$, 50/($R_{n}\cos\Phi$,
100, 0.1, 0.1, 0.1\}.
\item Define \textbf{$\delta\mathbf{z}$ }as the set of six measurements
consisting of the differences between GPS and INS positions and velocities.
The error-state vector is then further updated as follows:\\
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\item Finally, the covariance matrix is updated further according to\\
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end{enumerate}
To apply these equations, it is not necessary to use a high-rate file
and update at high rate, because it is expected that the errors vary
slowly. Turns and other maneuvers can introduce spurious effects if
time delays are not adjusted well. For these reasons, a 1-Hz data
file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles as well as
the rotation rates and accelerations will be smoothed before applying
the Kalman filter. DEEPWAVE flight 16 was selected, and the measurements
were filtered with 11-s smoothing of accelerations and 301-s smoothing
of measured velocity components and attitude angles.

<<new-data, include=TRUE, echo=FALSE>>=

Flight <- "16" 			
Project = "DW"     	
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
D1 <- getNetCDF (fname, c(VarList, 'TASX'))
DL <- nrow(D1)
s <- -120
si <- 0
s <- 92
si <- 0
SHIFT <- FALSE
SHIFT <- TRUE
Rate <- 1
if (SHIFT) {
  # D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)    ## this is needed for pitch and heading corrections
  # D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
  D1$THDG <- ShiftInTime (D1$THDG, Rate, s)
  D1$PITCH <- ShiftInTime (D1$PITCH, Rate, s)
  D1$ROLL <- ShiftInTime (D1$ROLL, Rate, s)
  D1$VEW <- ShiftInTime (D1$VEW, Rate, s)
  D1$VNS <- ShiftInTime (D1$VNS, Rate, s)
  D1$VSPD <- ShiftInTime (D1$VSPD, Rate, s)
  D1$BLONGA <- ShiftInTime (D1$BLONGA, Rate, si)
  D1$BLATA <- ShiftInTime (D1$BLATA, Rate, si)
  D1$BNORMA <- ShiftInTime (D1$BNORMA, Rate, si)
}
## remove the cal-coefficient offset: (+0.08)
# D1$THDG <- D1$THDG + 0.08
dt <- 1
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
Re <- StandardConstant ('Re')
D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2 + D1$GGALT)
  #interpolate if necessary:
  MaxGap <- 1000
  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
  ## smooth the measurements
  .span <- 11    
  ## The following are accelerations determined from derivatives of the GPS velocities.
  ## These should match the measured accelerations after transformation to the l-frame
  ## and application of the rotation correction:
  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
  ## transform to the a-frame for comparison to the IRU:
  G <- D1$Grav
  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection (D1, VL)
  AA <- XformLA (D1, LA, .inverse=TRUE)
  AA[,3] <- AA[,3] - G
  fa1 <- lm(D1$BLONGA ~ AA[, 1])
  fa2 <- lm(D1$BLATA ~ AA[, 2])
  fa3 <- lm(D1$BNORMA ~ AA[, 3])
  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame 
  AL <- XformLA (D1, AB)                                    #l-frame
  ## now corrected for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  AL <- AL - RotationCorrection (D1, VL)
  
  ## the resulting l-frame accelerations
  D1$LACCX <- AL[, 1]
  D1$LACCY <- AL[, 2]
  D1$LACCZ <- AL[, 3] + G
  D1$LACCZ <- -D1$LACCZ
  
  ## smooth to match GPS-velocity derivatives
  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
  .span <- 301
  SMOOTH <- FALSE
  if (SMOOTH) {
    vns <- signal::sgolayfilt (vns, 3, .span)
    vew <- signal::sgolayfilt (vew, 3, .span)
    vspd <- signal::sgolayfilt (vspd, 3, .span)
    ggvns <- signal::sgolayfilt (ggvns, 3, .span)
    ggvew <- signal::sgolayfilt (ggvew, 3, .span)
    ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
    pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
    roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
    thdg <- signal::sgolayfilt (D1$THDG, 3, .span)
    ## these smoothed values are not being used.
    D1$VNSF <- vns
    D1$VEWF <- vew
    D1$VSPDF <- vspd
    D1$GGVNSF <- ggvns
    D1$GGVEWF <- ggvew
    D1$GGVSPDF <- ggvspd
    D1$PITCHF <- pitch
    D1$ROLLF <- roll
    D1$THDGF <- thdg
  }

## get the pitch and roll in the l-frame:
.pitch <- D1$PITCH * Cradeg
.roll <- D1$ROLL * Cradeg
.thdg <- D1$THDG * Cradeg
x <- XPitch (.pitch, .roll, .thdg)
# pitchL <- x[,1]
# rollL <- x[,2]
  ## note: all in units of radians
  # pitchL <- cos (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg) - sin (.thdg) * sin (D1$ROLL*Cradeg)
  # rollL  <- sin (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg) + cos (.thdg) * sin (D1$ROLL*Cradeg)
D1$PITCHL <- x[, 1] / Cradeg  #pitchL
D1$ROLLL <-  x[, 2] / Cradeg  #rollL

  A2 <- D1$LACCX^2 + D1$LACCY^2
  A <- sqrt(A2)
  D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2)
  D1$herr <- (D1$LACCX*(vedot-D1$LACCX)-D1$LACCY * (vndot-D1$LACCY)) / (2*D1$LACCX*D1$LACCY)
  D1$herr <- (atan2(D1$LACCX, D1$LACCY) - atan2 (vedot, vndot))/Cradeg
  D1$herr[D1$herr > 180] <- D1$herr[D1$herr > 180] - 360
  D1$herr[D1$herr < -180] <- D1$herr[D1$herr < -180] + 360
  D1$varh <- runVar (D1$herr, n=30)
  D1$varh[is.na(D1$varh)] <- 1000
  
  ## a test of the time shift:
  D1$sdh <- sqrt(D1$varh)
  D1$he <- D1$herr
  D1$he[D1$sdh > 0.1] <- NA
  DD1 <- D1[setRange(D1,61000,123000),]
  plotWAC(DD1$ROLL, DD1$he, xlab='Roll', type='p', col='blue')
  fff <- lm(DD1$he ~ I(tan(DD1$ROLL*Cradeg)))
  b <- coef(fff)[2]*Cradeg
  deltaT <- -b * mean (DD1$TASX, na.rm=TRUE) / 9.8
  print (sprintf ('time shift is %f after shift of %f applied', deltaT, s/1000))

fm1 <- lm (vedot ~ D1$LACCX)
fm2 <- lm (vndot ~ D1$LACCY)
fm3 <- lm (vudot ~ D1$LACCZ)

@

As a check on the uncertainty associated with the accelerometers,
the GPS measurements of velocity components were differentiated and
the resulting accelerations transformed to the a-frame and compared
to the measured accelerations from the IRU (with correction for the
Earth's rotation and the motion of the l-frame relative to an inertial
frame). For the longitudinal acceleration (along the aircraft axis),
the linear regression of the measured acceleration vs the GPS-derived
acceleration had offset \Sexpr{round(coef(fa1)[1], 4)} and slope
\Sexpr{round(coef(fa1)[2], 4)}., with a residual standard error of
\Sexpr{round(summary(fa1)$sigma, 4)}\,m\,s$^{-2}$. For the normal
component of acceleration, the corresponding values are respectively
\Sexpr{round(coef(fa3)[1], 4)}, \Sexpr{round(coef(fa3)[2], 4)}.,
and \Sexpr{round(summary(fa3)$sigma, 4)}\,m\,s$^{-2}$. These then
can be considered calibrations for the accelerometers as well as indications
of their uncertainty. \footnote{The lateral accelerations were too noisy for a similar calibration
because lateral accelerations are usually small and short-term except
during periods with significant slip, which were not present on this
flight.}

The differentiated measurements of velocity components from the GPS
might be considered as additional measurements corresponding to the
measured accelerations, but this will not be part of this initial
study because the accelerometers appear to have low uncertainty and
because the effect of errors in acceleration would also appear as
errors in velocity and so should be detected by the conventional 6-component
measurement vector for Kalman filtering.



<<Kalman-setup, include=TRUE, echo=FALSE>>=

## also need the noise vector:
tau <- 60
GCF <- function (sv, sp) {
  gcf <- vector('numeric', length=15)
  gcf[1] <- 30 / sp$Rm
  gcf[2] <- 30 / (sp$Rn * cos (sv[1]))
  gcf[3] <- 150
  gcf[4:5] <- 0.15
  gcf[6] <- 1.5
  gcf[7:8] <- 0.03*Cradeg #0.03*Cradeg  #0.05*Cradeg  ## large error gives better updating
  gcf[9] <- 0.01*Cradeg
  gcf[10:12] <- 0.015*Cradeg*sqrt(2/tau)
  gcf[13:15] <- 0.0005*sqrt(2/tau)
  return (gcf)
}
i <- 1
gcf <- as.numeric (GCF (SV, D1[i, ]))
# Gnoise <- gcf * rnorm(15)
# dsve <- dcm %*% SVE   # + Gnoise
# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step

## The measurement model:
DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS, VSPD-GGVSPD))
DZ <- c(DZ, D1$LACCX-vedot, D1$LACCY-vndot, D1$LACCZ-vudot, D1$herr*Cradeg)
dim(DZ) <- c(DL, 10)
DZ[,1:2] <- DZ[, 1:2] * Cradeg

## the observation matrix: (the first six components of the state error vector are observable)
H <- diag(1, nrow=10, ncol=15)
for (k in 7:9) {
  H[k,k] <- 0
  # H[k,k+6] <- 1
}
H[10,10] <- 0
# H[10,9] <- 1

## at any time step, assume the measurements are contaminated by noise:
RCV <- matrix (rep(0,100), ncol=10)
RCV[1,1] <- (1500/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (1500/(D1$Rn[1]*cos(SV[1])))^2
RCV[3,3] <- 300^2
RCV[4,4] <- 3^2            ## ve
RCV[5,5] <- 3^2
RCV[6,6] <- 3^2
RCV[7,7] <- 1^2
RCV[8,8] <- 1^2
RCV[9,9] <- 1^2
RCV10 <- (0.5*Cradeg)^2  #0.1
RCV[10,10] <- RCV10 / A[i]^4

## initialize covariance matrix
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)


@

<<Kalman-loop, include=TRUE, echo=TRUE, eval=TRUE, fig.cap=' '>>=

Data <- D1
DL <- nrow (Data)
BACKWARD <- FALSE
# BACKWARD <- TRUE  ## if true, calculate from end to start

  # find PITCHL, ROLLL in the l-frame
  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal to AC
  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
  # UVL <- XformLA (Data, UV)
  # PitchL <- asin (-UVL[,2])
  # RollL <- asin (UVL[,1])
  #   .hdg <- Data$THDG*Cradeg
  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg

## note: using l-frame PITCH and ROLL; STMFV must account for this
i <- 1
if (BACKWARD) {i <- DL}
SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
NSTEP <- 5      ## update time
SVEF <- array(dim=c(DL/NSTEP, 15))
CVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[i, 1:6]
SVE[7:8] <- 0  ## might initialize using pitch/roll/heading-correction functions here
SVE[9] <- -0.08 * Cradeg
## start with zero for gyro and accelerometer errors
SVEF[i, ] <- SVE
CVEF[i, ] <- diag (CV)
# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
nStart <- 1+NSTEP
nEnd <- DL
NS <- NSTEP
if (BACKWARD) {
  nStart <- DL-NSTEP
  nEnd <- 1
  NS <- -NSTEP
}
pcntlast <- 0
# for (i in seq(1+NSTEP, DL, by=NSTEP)) {
for (i in seq(nStart, nEnd, by=NS)) {
  pcnt <- as.integer ((i-nStart) / (nEnd-nStart) * 100)
  if ((pcnt %% 10) == 0 && pcnt != pcntlast) {
    print (sprintf ('percent done=%d', pcnt))
    pcntlast <- pcnt
  }
  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL, THDG,
                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- Data$Rn[i]
  Rm <- Data$Rm[i]
  Grav <- Data$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv) * dt * NS + diag(15)
  if (i == 1+NS*500) {dcmSave <- dcm}
  ## modify to include this?
## modify this to include decaying error terms for the measurements:
# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new state vector:
  SVE <- dcm %*% SVE
  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  ## the Kalman gain:
  # RCV[10,10] <- RCV10 / A[i]^2
  RCV[10,10] <- Data$varh[i]
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
  CVEF[i/NSTEP, ] <- diag(CV)
}

## interpolate the results over the full data.frame:
  IntFilter <- function (X, inRate, outRate) {
    if (inRate == outRate) {return (X)}
    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
    x <- 0:(length(X)-1)
    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
    T <- A$y
    T <- signal::filter(signal::sgolay(4,75),T)
    ## now shift to match 25-Hz:
    n <- as.integer (ratio / 2)
    NL = length(T)
    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
    return (T)
  }
  Cor <- vector('numeric', DL*15)
  dim (Cor) <- c(DL, 15)
  VCor <- vector ('numeric', DL*15)
  dim (VCor) <- c(DL, 15)
  X <- SVEF[, 1]
  for (j in 1:15) {
    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
    VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
  }
  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
  Data$ALTKF <- Data$ALT - Cor[, 3]
  Data$VEWKF <- Data$VEW - Cor[, 4]
  Data$VNSKF <- Data$VNS - Cor[, 5]
  Data$VSPDKF <- Data$VSPD - Cor[, 6]
  # Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
  # Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
  # Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
  Data$BLATAKF <- Data$BLATA - Cor[, 13]
  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]
## smooth the pitch, roll, and heading corrections:
  for (k in 7:9) {
    Cor[, k] <- SmoothInterp (Cor[, k], .Length=1801)
  }
  x <- XPitch(Data$PITCHL*Cradeg-Cor[,7], Data$ROLLL*Cradeg-Cor[,8], Data$THDG*Cradeg-Cor[,9], .inverse=TRUE)
  Data$PITCHKF <- x[,1]/Cradeg
  Data$ROLLKF <- x[,2]/Cradeg
  Data$THDGKF <- Data$THDG-Cor[,9]/Cradeg
Data$DLAT <- Data$LATKF-Data$GGLAT
Data$CLAT <- -Cor[,1] / Cradeg
Data$DLON <- Data$LONKF-Data$GGLON
Data$CLON <- -Cor[,2] / Cradeg
Data$DALT <- Data$ALTKF-Data$GGALT
Data$CALT <- -Cor[,3]
Data$DVEW <- Data$VEWKF-Data$GGVEW
Data$CVEW <- -Cor[,4]
Data$DVNS <- Data$VNSKF-Data$GGVNS
Data$CVNS <- -Cor[,5]
Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
Data$CVSPD <- -Cor[,6]
# Data$CPITCH <- Data$PITCHKF-Data$PITCH
# Data$CROLL <- Data$ROLLKF-Data$ROLL
# Data$CTHDG <- Data$THDGKF-Data$THDG
KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.",
                    "Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines show the corrections applied to the original INS values by the Kalman filter.",
                      "Pitch Correction from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch (PC, red line)",
                      "Roll Correction from the Kalman filter (CROLL) and from Ranadu::CorrectPitch (RC, red line)",
                      "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")

@


\section*{Results}

There are several tests that the corrected values should pass:
\begin{enumerate}
\item Because the GPS measurements of position and aircraft velocity have
low uncertainty, the KF values should match these in long-term average,
perhaps with some high-frequency components not present in the GPS-provided
measurements.
\item The pitch-correction algorithm developed in the Tech Note should give
results in reasonable agreement with the KF values of pitch and roll.
\item The heading-correction algorithm should also produce results consistent
with the KF results.
\end{enumerate}
<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=KalmanCaptions>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
PC <- CorrectPitch(Data, .span=601)
Data$PC <- PC[, 1]
Data$RC <- PC[, 2]
## translate pitch/roll corrections to the a-frame:
.hdg <- Data$THDG * Cradeg
# CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
# CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
# Data$CPITCH <- CPITCH / Cradeg
# Data$CROLL <- CROLL / Cradeg
Data$CPITCH <- Data$PITCHKF-Data$PITCH
Data$CROLL <- Data$ROLLKF-Data$ROLL
Data$CTHDG <- Data$THDGKF-Data$THDG
Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
Data$CTHDG <- SmoothInterp (Data$CTHDG, .Length=181)
## data processing introduced a shift of -0.08
Data$HC <- -CorrectHeading (Data, .plotfile='./HCPlot.pdf')
r <- setRange (Data, 70000, 123000)
ival <- abs(Data$ROLL) > 4
Data$PC[ival] <- NA
plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('pitch correction',' [',degree,']')), ylim=c(-0.05, 0.05), lwd=c(0.7,3), col=c('blue', 'red'))
PE <- VCor[,7]
PE[PE < 1.e-10] <- 1.e-10
PE <- PE / 1015
PE <- sqrt(PE)
Data$CPITCH[ival] <- NA
lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
# lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), ylab=expression(paste('roll correction [',degree,']')), ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'))
# Data$CROLL[ival] <- NA
Data$RC[ival] <- NA
lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylab=expression(paste('heading correction [',degree,']')), ylim=c(-0.15,0.15), lwd=0.7)
abline(h=0, col='darkorange', lty=2)
HE <- VCor[,9]
HE[HE < 0.0025] <- 0.0025
HE <- sqrt(HE)
# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
iv <- HE > 0.051
CCTHDG <- Data$CTHDG
CCTHDG[iv] <- NA
lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r]^2, spar=1.25)
Data$HCS <- predict(SS, as.numeric(Data$Time))$y
lineWAC(Data$Time[r], Data$HCS[r], col='red')
# plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)))
Data$pitch_L <- Cor[, 7]/Cradeg
Data$roll_L <- Cor[, 8]/Cradeg
plotWAC (subset(Data[r,],,c(Time, pitch_L, roll_L)), ylim=c(-0.05,0.05), ylab=expression (paste ('correction [',degree,']')), main="l-frame pitch correction")

lineWAC(Data$Time[r], (Cor[r,7]+PE[r])/Cradeg, col='darkorange', lwd=1)
lineWAC(Data$Time[r], (Cor[r,7]-PE[r])/Cradeg, col='darkorange', lwd=1)

@

\clearpage

\begin{center}
\textsf{\textcolor{blue}{-- End of Memo --}}
\par\end{center}

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow:}}} & Workflow\Sexpr{thisFileName}.pdf\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & https://github.com/WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}


\end{document}
