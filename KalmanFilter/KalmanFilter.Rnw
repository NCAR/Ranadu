%% LyX 2.2.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\usepackage{babel}
\usepackage{amsbsy}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true]
 {hyperref}
\usepackage{breakurl}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
%\fancyhead{}
%\fancyfoot[CE,CO]{}
%\newtoks{\addressee} \global\addressee={}
%\newdimen\longindent \longindent=3.5truein
%\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
%\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\begin{document}


\title{Correcting Measured Attitude Angles with a Kalman Filter}

\author{William A. Cooper}

\date{08/07/2016}
\maketitle

\section{Overview and background}

\subsection{Sources of error in measurements of wind}

An \href{http://dx.doi.org/10.5065/D60G3HJ8}{NCAR Technical Note}
documents the uncertainties associated with measurements of wind from
the NSF/NCAR Gulfstream V (hence, GV) research aircraft. That report
highlights that the most important contributions to that uncertainty
arise from three errors:
\begin{enumerate}
\item For vertical wind, \emph{\uline{error in pitch}} is the dominant
remaining error.
\item For horizontal wind, \emph{\uline{error in heading}} is the dominant
remaining error.
\item For both, pressure-line resonance limits high-frequency response and
compromises measurements of variance spectra.
\end{enumerate}
This document describes methods for improving the measurements of
wind by addressing the first two of these errors. The third requires
hardware changes, but the first two can be addressed solely by changes
in the processing algorithms. It will be shown here that such processing
can reduce the uncertainty in pitch and heading so that they make
only minor contributions to the overall uncertainty in wind, so that
further improvement is not beneficial. Two parallel approaches are
possible: (1) implementation of a Kalman filter to correct the measurements
from the inertial navigation system (INS) on the GV, which does not
have such a Kalman filter as an integral part of processing; and (2)
development of simpler algorithms that can obtain comparable correction
terms without the full mechanism of the Kalman filter. The latter
is the topic of separate documentstion. Here the focus is on the Kalman
filter.

The primary wind-sensing system on the GV consists of these components:\footnote{See the referenced NCAR Technical Note for a full description.}
\begin{enumerate}
\item An inertial reference unit (IRU) that makes the basic measurements
of acceleration and rotation in the reference frame of the aircraft,
or \emph{a-}frame.
\item The associated inertial navigation system (INS) that integrates these
measurements to determine the location, Earth-relative motion, and
attitude angles of the aircraft. The latter include the pitch, roll,
and heading.
\item A Global Positioning System (GPS) receiver that provides independent
measurements of the location and Earth-relative motion.
\item A radome-based gust system, consisting of pressure measurements at
ports on the surface of the radome and associated measurements of
dynamic and ambient pressure, that measures the ``relative wind''
or the air-velocity vector relative to the aircraft and in its reference
frame.
\end{enumerate}
These are processed to obtain two ``state vectors'', an aircraft-state
vector with nine components that specify the position, Earth-relative
motion, and attitude angles of the aircraft and a relative-wind vector
with three components that represent the motion of air with respect
to the aircraft reference frame. The Earth-relative motion of the
aircraft is then combined with the relative wind to obtain the Earth-relative
wind. That combination involves a coordinate transformation from the
reference frame of the aircraft (``\emph{a-}frame'') to the Earth-relative
local frame (``ENU'' or \emph{``l-}frame'') and so depends on
the attitude angles of the aircraft. Those angles are important sources
of uncertainty because the solution is very sensitive to them and
their measurement relies upon proper initialization of the INS at
the start of the flight and proper integrations of all changes during
the flight, with no updating available in standard processing.

In the case of position and ground-speed of the aircraft, the GPS
provides a low-uncertainty measurement that can be used to correct
the measurements from the INS, and this is done in standard processing
via a complementary filter that combines the high-frequency response
from the INS with the low-frequency response from the GPS, as described
in the referenced Technical Note. This correction of the INS-provided
measurements can also be made using the Kalman filter described below,
but there is little advantage because the result is very close to
the result obtained using the complementary filter. However, the GPS
does not provide an alternate measurement of the attitude angles,
so reduction in their uncertainties requires a different approach.
The significant benefit achieved by the Kalman filter described in
this report is reduction of the uncertainty in the measurements of
attitude angles.

\subsection{The purpose of the Kalman filter\label{subsec:The-Kalman-filter}}

\bigskip

<<initialization,echo=FALSE,include=TRUE>>=

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:", cache=TRUE)
opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
thisFileName <- "KalmanFilter"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)
Directory <- DataDirectory ()
Flight <- "rf15HR" 			
Project = "DWIRU" 
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
#ReloadData <- TRUE
SaveRData1 <- sprintf("%s1.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  save (Data, file=SaveRData1)
} else {
  load (file=SaveRData1)
}

@

A Kalman filter provides a means of updating a sequence of aircraft-state
vectors by comparison to an independent set of measurements, e.g.,
from GPS-derived measurements of position and velocity). The updated
state vector obtained by this process consists of an appropriately
weighted combination of the aircraft-state vector projected forward
using normal INS ``mechanization'' (i.e., determining the next step
by using the measured acceleration and rotation from the IRU) and
the independent measurements from GPS. Because errors in the state
vector are coupled, the update procedure can estimate errors in the
attitude angles as well as the components of the state vector that
are measured directly by the GPS. As described below, corrections
to the attitude angles (pitch, roll, and heading) can be estimated
even though there is no direct measurement of these except from the
INS. The reason is that the attitude-angle errors have consequences
that \emph{are }observable. For example, an error in pitch or roll
leads to errors when the acceleration of gravity is resolved into
the aircraft reference frame, and that leads to errors in the measured
accelerations of the aircraft that cause errors in Earth-relative
velocity or location. Those are observable by comparison to the corresponding
measurements from the GPS receiver, so the Kalman filter is able to
introduce corrections that reduce those errors. In similar fashion,
an error in heading leads to an error in the measured acceleration
when transformed from the \emph{a-}frame to the \emph{l-}frame and
so to errors in Earth-relative velocity and position that are observable
by comparison to the GPS-provided measurements.

The weighting of the projected-forward aircraft-state vector and new
measurements from GPS depends on obtaining estimates of the covariance
matrix describing uncertainty in the state vector as well as estimates
of the noise sources contaminating the measurements from both the
GPS- and the IRU-provided accelerations and rotations. With proper
weighting, the result should combine the good high-frequency response
of the INS with the good long-term stability of the GPS. The covariance
matrix characterizing the aircraft-state vector is updated as the
filter is applied, but appropriate weighting depends on reasonable
estimation of the other error terms that are not updated.

\subsection{An error-state Kalman filter\label{subsec:An-error-state-Kalman}}

As outlined above, the Kalman filter operates during ``mechanization''
of the INS as a solution is produced. However, in the GV case, mechanization
is internal to the INS and is beyond the reach of an alternate software
solution. Because the processing in the INS has access to data at
higher rate than is present in the archive files and uses undisclosed
processing algorithms likely superior to ones we might construct,
a preferable approach is instead to use an error-state Kalman filter
where the aircraft-state vector provided by the INS is taken as a
reference state and the Kalman filter instead propagates an error-state
vector that represents corrections to the reference state. A central
need is still to determine the derivative matrix representing the
change in the aircraft-state vector, because the transformation matrix
for the error-state vector is the jacobian of that derivative matrix..
Therefore, an essential step toward development of the error-state
Kalman filter is to develop the aircraft-state transformation matrix
based on that derivative matrix and verify that it provides, at least
approximately, the reference solution. That verification is therefore
an important step that is described in detail below. The resulting
transformation matrix will then provide the core for the error-state
Kalman filter.

<<initialization-pitch,echo=FALSE,include=FALSE>>=

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(ggplot2)
require(grid)
library(knitr)
require(ggthemes)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
opts_chunk$set(fig.width=6, fig.height=5, fig.loc="center", digits=4)
Directory <- DataDirectory ()
Flight <- "ff02" 				# XXX change this
Project = "DEEPWAVE"			 # XXX change this
fname = sprintf("%s%s/%s%s.nc", Directory,Project,Project,Flight)
VarNames <- c("BLATA", "BLONGA", "BNORMA", "VNS", "VEW", "VSPD", "GGVNS", "GGVEW", 
              "GGVSPD", "LAT", "LON", "ALT", "THDG", "PITCH", "ROLL") 
SaveRData2 <- sprintf("%s2.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, standardVariables(VarNames))		
  save(Data, file=SaveRData2)
} else {
  load (file=SaveRData2)
}
Cradeg <- pi / 180
source ("~/RStudio/Ranadu/R/ShiftInTime.R")
source("~/RStudio/Ranadu/R/XformLA.R")
source ("~/RStudio/Ranadu/R/PitchCorrection.R")

@

<<utility-functions, include=TRUE, echo=FALSE>>=

## returns transformation matrix, a-frame to l-frame
XfLArV <- function (data) {   ## XfLA but using input in radians and single row
  # data must contain PITCH, ROLL, HEADING as components [7:9]
  cosphi <- cos (data[8])
  sinphi <- sin (data[8])
  costheta <- cos (data[7])
  sintheta <- sin (data[7])
  cospsi <- cos (data[9])
  sinpsi <- sin (data[9])
  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-sinpsi*sintheta*cosphi,
           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinphi-cospsi*sintheta*cosphi,
           -sintheta, costheta*sinphi, -costheta*cosphi)
  RblM <- aperm( array (Rbl, dim=c(3,3)))
  return (RblM)
}

XPitch <- function (pitch, roll, heading, .inverse=FALSE) {  # a-frame to l-frame
  ## note: all in units of radians
  if (!.inverse) {
    pitchL <- -asin(-cos (heading) * sin (pitch) * cos (roll) - sin (heading) * sin (roll))
    rollL  <-  asin(-sin (heading) * sin (pitch) * cos (roll) + cos (heading) * sin (roll))
    A <- c(pitchL, rollL)
    dim(A) <- c(length(pitch),2)
    return (A)
  } else {
    lx <- sin (roll)
    ly <- -sin (pitch)
    lz <- -sqrt (1 - lx^2 - ly^2)
    pitchA <- atan2 (lx * sin (heading) + ly * cos (heading), lz)
    pitchA[pitchA < -pi/2] <- pitchA[pitchA < -pi/2] + pi
    pitchA[pitchA >  pi/2] <- pitchA[pitchA >  pi/2] - pi
    # rollA <- acos (lz / cos (pitchA))
    rollA <- atan ((-cos(heading)*lx+sin(heading)*ly) /
                    (sin(heading) * sin(pitchA)*lx+cos(heading)*sin(pitchA)*ly+cos(pitchA)*lz))
    # rollA[rollA > pi/2] <- pi - rollA[rollA > pi/2] 
    A <- c(pitchA, rollA)
    dim(A) <- c(length(pitch), 2)
    return (A)
  }
}

# other-functions ---------------------------------------------------------

Cradeg <- pi/180
dt <- 1/25               ## working with 25-Hz file
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')
Ree <- 6378137
Ecc <- 0.08181919
## The next correction calculates the correction needed to account for the rotation
## of the Earth and of the l-frame (ENU frame). See Noureldin et al., 2013, 
## Eqs. 5.55--5.57. Subtract this from the transformed accelerations before using them.
RotationCorrection <- function (.data, .V) {
  Cradeg <- pi/180
  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
  DL <- nrow (.data)
  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
  lat <- .data$LAT * Cradeg
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  Ree <- 6378137
  Ecc <- 0.08181919
  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
  M23 <- .V[,2] / Rm
  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
  M32 <- -.V[,2] / Rm
  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
  return (C)
}

Gravity <- function (latitude, altitude=0.) {
  sl2 <- (sin (latitude * pi / 180))^2
  g <- 9.780327 * ((1. + 0.001931851 * sl2) / 
                     (1. - 0.006694380 * sl2)) - 3.086e-6 * altitude
  ## Somigliana formula 1980 GRS:
  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 * altitude^2
  return(g)
}

SummarizeFit <- function(ft) {
  print (summary(ft)$call)
  print ("Coefficients:")
  print (summary(ft)$coefficients)
  print (sprintf ("Residual standard deviation: %.3f, dof=%d", summary(ft)$sigma, summary(ft)$df[2]))
  print (sprintf ("R-squared %.3f", summary(ft)$r.squared))
}
LFrame <- TRUE
STMFV <- function (sv, dbg=FALSE) { 
  stmf <- vector('numeric', length=15)
  ## transform pitch and roll back to a-frame
  if (LFrame) {
    x <- XPitch (sv[7], sv[8], sv[9], .inverse=TRUE)
    sv[7] <- x[1]
    sv[8] <- x[2]
  }
  rlm <- XfLArV(sv)     ## rotation matrix, a-frame to l-frame 
  if (dbg) {
    print (sprintf ('sv[7-9]=%f %f %f', sv[7],sv[8],sv[9]))
    print (rlm)
  } 
  omega <- as.vector (c(-sv[5] / Rm, 
                        OmegaE*cos(sv[1])+sv[4]/Rn,
                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2], omega[1], 0), ncol=3)
  Oilb <- Oill %*% rlm
  ## find the derivative of the transformation matrix:
  ## (must recalculate SRM from measured rotation rates)
  SRR <- c(0, -sv[12], -sv[10],
           sv[12], 0, sv[11],
           sv[10], -sv[11], 0)
  SRM <- aperm( array (SRR, dim=c(3,3)))
  dRLA <- rlm %*% SRM - Oilb
  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
  # G <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    
  Grav <- Gravity (sv[1]/Cradeg, sv[3])
  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-frame
  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
  ## now correct for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  VL <- c(sv[4], sv[5], sv[6])
  C <- vector ('numeric', 3)
  lat <- sv[1]
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
  M23 <- VL[2] / Rm
  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
  M32 <- -VL[2] / Rm
  C[1] <- M12 * VL[2] + M13 * VL[3]
  C[2] <- M21 * VL[1] + M23 * VL[3]
  C[3] <- M31 * VL[1] + M32 * VL[2]
  AL <- as.vector (AL - C, mode='numeric')
  AL[3] <- AL[3] + Grav
  AL[3] <- -AL[3]
  ## note re derivatives of attitude angles:
  ##   in terms of transformation matrix, sin(pitch)=-rlm[3,1],
  ##   tan(roll)=-rlm[3,2]/rlm[3,3], tan(thdg)=rlm[1,1]/rlm[1,2]
  ##   get derivatives from d(arcsin(x))/dx=1/sqrt(1-x^2), d(arctan(x))/dx=1/(1+x^2)

  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
            0, 0, 0, 0, 0, 0)
  ## transform angle derivatives back to l-frame
  if (LFrame) {
    x <- XPitch (sv[7]+stmf[7], sv[8]+stmf[8], sv[9]+stmf[9]) -
         XPitch (sv[7], sv[8], sv[9])
    stmf[7] <- x[1]
    stmf[8] <- x[2]
    # x <- rlm %*% as.matrix (c(stmf[8], -stmf[7], 0))
    # stmf7 <- stmf[7]
    # stmf8 <- stmf[8]
    # stmf[7] <- cos(sv[9])*cos(sv[7])*cos(sv[8]) * stmf7 + 
    #   (-cos(sv[9])*sin(sv[7])*sin(sv[8]) + cos(sv[9])*cos(sv[8])) *  stmf8
    # stmf[8] <- (cos(sv[9])*cos(sv[7]) - sin(sv[9])*cos(sv[7])*cos(sv[8])) * stmf7 +
    #   sin(sv[9])*sin(sv[7])*sin(sv[8]) * stmf8
  }
  return (as.vector (stmf, mode='numeric'))
}

@

<<INS-data, include=TRUE, echo=FALSE>>=

Directory <- DataDirectory ()
Flight <- "rf15HR" 				# XXX change this
Project = "DWIRU"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT', 'PALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG', 'PS_A')
SaveRData3 <- sprintf("%s3.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  ## replace PALT by corresponding value from FS_A, to match INS baro loop
  Data$PALT <- PressureAltitude (Data$PS_A)
  Data$Grav <- Gravity (Data$LAT, Data$PALT)
  Data$BLATA <- zoo::na.approx (Data$BLATA)
  Data$BLONGA <- zoo::na.approx (Data$BLONGA)
  Data$BNORMA <- zoo::na.approx (Data$BNORMA)
  Data$BPITCHR <- zoo::na.approx (Data$BPITCHR)
  Data$BROLLR <- zoo::na.approx (Data$BROLLR)
  Data$BYAWR <- zoo::na.approx (Data$BYAWR)
  ## remove the time lags
  Data$PITCH <- ShiftInTime (Data$PITCH, .rate=25, .shift=60)
  Data$ROLL <- ShiftInTime (Data$ROLL, .rate=25, .shift=60)
  Data$THDG <- ShiftInTime (Data$THDG, .rate=25, .shift=35)
  Data$VEW <- ShiftInTime (Data$VEW, .rate=25, .shift=80)
  Data$VNS <- ShiftInTime (Data$VNS, .rate=25, .shift=80)
  Data$VSPD <- ShiftInTime (Data$VSPD, .rate=25, .shift=60)
  ## better without shifts in gyro rates
  # Data$BYAWR <- ShiftInTime (Data$BYAWR, .rate=25, .shift=-30)
  ## guard against bad values at wrap-around points, caused by ShiftInTime:
  for (i in 2:(nrow(Data)-1)) {
    if ((Data$THDG[i]-Data$THDG[i-1] > 30) && (Data$THDG[i+1]-Data$THDG[i] > 30)) {
      # print (sprintf ("case 1, i=%d", i))
      Data$THDG[i] <- Data$THDG[i+1]+Data$THDG[i-1]+360
      if (Data$THDG[i] > 360) {Data$THDG[i] <- Data$THDG[i]-360}
    }
    if ((Data$THDG[i]-Data$THDG[i-1] < -30) && (Data$THDG[i+1]-Data$THDG[i] < -30)) {
      # print (sprintf ("case 2, i=%d", i))
      Data$THDG[i] <- Data$THDG[i+1]+Data$THDG[i-1]-360
      if (Data$THDG[i] < 0) {Data$THDG[i] <- Data$THDG[i]+360}
    }
  }

  save (Data, file=SaveRData3)
} else {
  load (file=SaveRData3)
}
SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
                              ROLL, PITCH, THDG, PALT, GGVSPD, BLATA, BLONGA, BNORMA, 
                              BPITCHR, BROLLR, BYAWR,
                              GGVEW, GGVNS, Grav))

## adjustments:
SP$BYAWR <- SP$BYAWR - 0.005  ## these adjustments avoid accumulation of offset in circles
SP$BROLLR <- SP$BROLLR + 0.0005
SP$BPITCHR <- SP$BPITCHR + 0.0002
# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
# SP$BLONGA <- SP$BLONGA * 0.96
SP$BNORMA <- SP$BNORMA*0.9873 + 0.0104  ## see below for calibrations
SP$BLONGA <- SP$BLONGA * 0.9810 + 0.0047
# SP$BLATA <- SP$BLATA * 0.82099 - 0.005538  ## poorly costrained; omit
SP$BPITCHR <- SP$BPITCHR * Cradeg
SP$BROLLR <- SP$BROLLR * Cradeg
SP$BYAWR <- SP$BYAWR * Cradeg

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 
SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) 
SPR <- SP   ## save what INS produced, as reference

@

\section{Mechanization}

\subsection{General description}

Although the implemented filter described in the next section will
be an error-state Kalman filter, a necessary first step is to develop
and verify a mechanization that duplicates the function of the INS
by providing the history of the nine variables describing the position,
velocity, and attitude angles of the aircraft. From an initial state,
this mechanization uses only the IRU-provided measurements of acceleration
and rotation rate in the reference frame of the aircraft. {[}See the
code ``chunk'' labeled ``mechanization'' for details.{]} The nine
variables are specified by an aircraft-state vector $\boldsymbol{x}$
that includes the aircraft variables in the local-level reference
frame, also referred to as the ``ENU'' (for east, north, up) or\emph{
l-}frame. That aircraft-state vector is propagated forward step-wise
in time from time-step $k-1$ to step $k$ by a transformation matrix
$\boldsymbol{T}_{k|k-1}$ consisting of the sum of the identity matrix
and the product of a derivative matrix and a time step. The derivative
matrix specifies the (linearized) change in each component of $\boldsymbol{x}$
as a function of each other component of $\boldsymbol{x}$ and the
measurements of vector acceleration and vector rotation rate provided
by the IRU. Repeated application of this transformation matrix then
provides the history of the aircraft-state vector. The purpose of
this section is to document this mechanization and demonstrate that
it replicates, at least within reasonable error limites, the mechanization
provided by the INS. This is a necessary step toward implementation
of a Kalman filter, which would use the transformation matrix, or
an error-state Kalman filter, for which the corresponding transformation
matrix for the error state is the Jacobian of $\boldsymbol{T}_{k|k-1}$.

The data file used for this demonstration is a special data file resulting
from processing DEEPWAVE flight 15 at high rate (25~Hz) and saving
the resulting netCDF file as DWIRUrf15HR.nc. This file is archived
along with the other files used to generate this document, as described
in a table appended to the end of this report. To reproduce this document,
that special data file will be needed, but the goal of this report
is to ensure reproducibility by preserving the specific data file
and program used to generate the report, as described in that appendix.

The procedure used for this test of the mechanization equations is
as follows:
\begin{enumerate}
\item Initialize a special state vector $\mathbf{x}$, used only for these
tests, having these components:

\begin{enumerate}
\item latitude, longitude, altitude in the \emph{l-}frame;
\item east velocity, north velocity, upward velocity in the \emph{l-}frame;
\item pitch, roll, heading in the \emph{a}-frame;
\item rotation rates about the pitch, roll, and yaw axes of the aircraft;
\item acceleration in the lateral, longitudinal, and normal direction relative
to the a-frame.
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item Store the measured rotations and accelerations in the last 6 components
of the state vector.
\item Via the function STMFV, calculate the time derivative of the state
vector. In the case of the attitude angles, this is done by calculating
the derivative of the transformation matrix from the \emph{a}-frame
to the \emph{l-}frame and then using the definition of components
of that matrix to find the derivative of the attitude angles.
\item Use that derivative vector to increment the state vector.
\item Compensate for possible wrap-around of the heading at 0 and 360$^{\circ}$
so that values stay within that range.
\item Save the first 9 components of the state vector in a new R data.frame
that represents an independent ``mechanization'' of the INU measurements.
These measurements should then be in reasonable agreement with the
solution provided by the standard INS.
\end{enumerate}
\end{enumerate}
A ``workflow'' document, referenced and made available as described
in the appendix, provides some additional details, and the R code
is included in the primary reference document ``KalmanFilter.Rnw.''

\subsection{Tests of the mechanization}

<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=

SV <- with(Data[1, ], data.frame(LAT, LON, PALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
SP$LAT[1] <- SV$LAT
SP$LON[1] <- SV$LON
SP$ALT[1] <- SV$PALT
SP$VEW[1] <- SV$VEW
SP$VNS[1] <- SV$VNS
SP$VSPD[1] <- SV$VSPD
## convert pitch/roll of SV to l-frame components:
if (LFrame) {  ## initialize state vector in l-frame 
  x <- XPitch (SV$PITCH, SV$ROLL, SV$THDG)
  SV$PITCH <- x[1]
  SV$ROLL  <- x[2]
}
SP$PITCH[1] <- SV$PITCH
SP$ROLL[1] <- SV$ROLL
SP$THDG[1] <- SV$THDG
twoPi <- 2*pi

sv <- as.vector (SV, mode='numeric')
Rn <- SP$Rn[1] + sv[3]
Rm <- SP$Rm[1] + sv[3]
Grav <- SP$Grav[1]
stmf <- STMFV (sv)
## feedback coefficients for baro loop:
lambda <- 0.075
C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
C0 <- 3*lambda; C1 <- 4*lambda^2; C2 <- 2*lambda^3
wp3F <- 0;
hxF <- hxxF <- 0
hi3F <- SP$PALT[1]
RK <- TRUE    ## use Runge-Kutta integration if true
RK <- FALSE

for (i in 2:nrow(SP)) {
  Rn <- SP$Rn[i] + sv[3]
  Rm <- SP$Rm[i] + sv[3]
  Grav <- SP$Grav[i]
  sv[10] <- SP$BPITCHR[i]
  sv[11] <- SP$BROLLR[i]
  sv[12] <- SP$BYAWR[i]
  sv[13] <- SP$BLATA[i]
  sv[14] <- SP$BLONGA[i]
  sv[15] <- SP$BNORMA[i]
  if (RK) {
    stmf1 <- STMFV (sv)
    sv1 <- sv + stmf1 * dt/2
    stmf2 <- STMFV (sv1)
    sv2 <- sv + stmf2 * dt/2
    stmf3 <- STMFV (sv2)
    sv3 <- sv + stmf3 * dt
    stmf4 <- STMFV (sv3)
    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
  } else {
    stmf <- STMFV (sv)
  }
  sv <- sv + stmf * dt
  if (!is.na(sv[9])) {
    if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
    if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
  }
  ## baro-loop
  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
  hxF <- hi3F - SP$PALT[i]
  hxxF <- hxxF + hxF * dt
  sv[6] <- 0.5 * (sv[6] + wp3F)
  sv[3] <- hi3F
  SP$LAT[i] <- sv[1]
  SP$LON[i] <- sv[2] 
  SP$ALT[i] <- sv[3]
  SP$VEW[i] <- sv[4]
  SP$VNS[i] <- sv[5]
  SP$VSPD[i] <- sv[6]
  SP$PITCH[i] <- sv[7] 
  SP$ROLL[i] <- sv[8] 
  SP$THDG[i] <- sv[9]
}
SP$LAT <- SP$LAT / Cradeg
SP$LON <- SP$LON / Cradeg
## convert pitch/roll to a-frame components:
if (LFrame) {
  x <- XPitch (SP$PITCH, SP$ROLL, SP$THDG, .inverse=TRUE)
  SP$PITCH <- x[,1]
  SP$ROLL <- x[,2]
}
SP$PITCH <- SP$PITCH / Cradeg
SP$ROLL <- SP$ROLL / Cradeg
SP$THDG <- SP$THDG / Cradeg

@


<<plot-mech, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap='Comparison of INS-provided attitude angles (PITCH, ROLL and THDG shown as dashed blue lines) and integration-derived attitude angles (PITCHX, ROLLX and THDGX shown as solid dark-green lines).'>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
Data$LATX <- SP$LAT
Data$LONX <- SP$LON
Data$ALTX <- SP$ALT
Data$VEWX <- SP$VEW
Data$VNSX <- SP$VNS
Data$VSPDX <- SP$VSPD
Data$PITCHX <- SP$PITCH
Data$ROLLX <- SP$ROLL
Data$THDGX <- SP$THDG
Data$DPITCH <- Data$PITCHX-Data$PITCH
Data$DROLL <- Data$ROLLX-Data$ROLL
Data$DTHDG <- (Data$THDGX-Data$THDG)
Data$DTHDG[Data$DTHDG > 180] <- Data$DTHDG[Data$DTHDG > 180] - 360
Data$DTHDG[Data$DTHDG < -180] <- Data$DTHDG[Data$DTHDG < -180] + 360
r <- setRange (Data, 33000, 35500)
DL <- r[length(r)]
Data <- Data[r, ]
plotWAC (Data[, c('Time', 'PITCH', 'PITCHX')], lty=c(2,1),
         ylab=expression (paste ('PITCH [',degree,']')), legend.position='topright')
sdPitch <- sd (Data$DPITCH, na.rm=TRUE)
# lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
plotWAC(Data[, c('Time', 'ROLL', 'ROLLX')], lty=c(2,1),
        ylab=expression (paste ('ROLL [',degree,']')), legend.position='bottomright')
sdRoll <- sd(Data$DROLL, na.rm=TRUE)
# lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC(Data[, c('Time', 'THDG', 'THDGX')],
        ylab=expression (paste ('HEADING [',degree,']')), ylim=c(0,360),
        lty=c(2,1), legend.position='topright')
sdThdg <- sd (Data$DTHDG, na.rm=TRUE)
# lines(c(Data$Time[r[1]], Data$Time[DL]), c(180,180), col='green')

@

<<plot-mech1a, include=TRUE, fig.height=3, fig.cap='The difference between THDG and THDGX (as plotted individually in the preceding figure) on a magnified scale.'>>=

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
plotWAC(Data$Time, Data$DTHDG, ylab=expression(paste(Delta,"heading [",degree,"]")))

@

\subsubsection{Attitude angles}

The result of that integration for the attitude angles is compared
to the INS-produced solution in Fig.~\ref{fig:plot-mech}. Throughout
this flight segment, which included some perturbations in pitch and
yaw and some complete-circle maneuvers, the attitude angles produced
by this integration show the same variations as those from the INS,
with only small exceptions. The standard deviations between the new
values for pitch or roll and the corresponding values from the INS
are $<0.1^{\circ}$, but the comparison for heading shows a larger
standard deviation, about $2.5^{\circ}$. The general agreement for
the attitude angles verifies that the angle transformations are correct,
but the larger deviations for heading were unexpected. Figure~\ref{fig:plot-mech1a}
shows that the difference between the INS-provided heading and the
value recalculated from the recorded rotation rates exhibits a systematic
variation in the two 360$^{\circ}$ turns between 3:40 and 3:55, which
is suggestive of some problem even though the larger-scale variation
shown in Fig.~\ref{fig:plot-mech} is mostly correct. 

<<byawr-check, include=TRUE, fig.cap='Rate of change of heading obtained by differentiating the INS-produced measurements of heading, plotted against the corresponding IRU-provided measurement of the rotation rate about the yaw axis. The dashed orange line is a 1:1 line provided for reference.'>>=

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
Data$YAWR <- c(diff(Data$THDG),0) * 25 * cos (Data$ROLL*pi/180)
plotWAC(data.frame(Data$BYAWR, Data$YAWR), xlab='BYAWR', ylab='d(THDG)/dt', type='p', 
        pch=20, col='blue', xlim=c(-2,2), ylim=c(-2,2))
lines(c(-2,2), c(-2,2), col='darkorange', lwd=3, lty=2)
Data$YAWR[abs(Data$YAWR) > 2] <- NA
fm <- with(Data, lm(YAWR ~ BYAWR+I(BYAWR^2)+I(BYAWR^3)+I(BYAWR^4)))
cfhdg <- coef(fm)
X <- -200:200
X <- X / 100
Y <- cfhdg[1]+X*(cfhdg[2]+X*(cfhdg[3]+X*(cfhdg[4]+X*cfhdg[5])))
# lines(X,Y, col='darkorange', lwd=3, lty=2)

@

To investigate the origin of this variation, the measurement of heading
provided by the INS was differentiated and the result was compared
to the IRU-provided measurement of the rate of change in yaw angle.\footnote{For this comparison, the derivative of the heading must be multiplied
by the cosine of the roll angle to represent the heading in the a-frame.} Figure~\ref{fig:byawr-check} shows a comparison of the differentiated
heading and the measured yaw-rotation rate. The two measurements are
in good agreement, and an attempt to improve the calibration of the
IRU-measured rotation rate about the yaw axis by fitting a fourth-order
polynomial to the points in this figure did not give significant improvement
is the standard deviation of the difference between THDG and THDGX.
The small differences shown in Fig.~\ref{fig:plot-mech1a} are a
troubling unexplained difference, but for the purposes of the error-state
Kalman filter the important result is that the derivatives of all
the attitude angles are reasonable and should be suitable for use
in that filter.

<<plot-mech-2, include=TRUE, fig.cap='Comparison of INS-provided and integration-derived components of the aircraft velocity. The INS-provided values are VEW, VNS and VSPD and are shown as dashed blue lines. The new-mechanization values are VEWX, VNSX and VSPDX and are shown as solid dark-green lines.'>>=


op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[, c('Time', 'VEW', 'VEWX')], lty=c(2,1),
         ylab="VEW [m/s]", legend.position='topright')
plotWAC (Data[, c('Time', 'VNS', 'VNSX')], lty=c(2,1),
         ylab="VNS [m/s]", legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[, c('Time', 'VSPD', 'VSPDX')], lty=c(2,1),
         ylab="VSPD [m/s]", legend.position='topright')

op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (Data[, c('Time', 'LAT', 'LATX')], lty=c(2,1),
          ylab=expression (paste ('Latitude [',degree,']')), legend.position='topright')
plotWAC (Data[, c('Time', 'LON', 'LONX')], lty=c(2,1),
          ylab=expression (paste ('Longitude [',degree,']')), legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
Data$PALT <- SmoothInterp (Data$PALT, .Length=121)
plotWAC (Data[, c('Time', 'ALT', 'ALTX', 'PALT')], lwd=c(2,3,2),
          ylab="Altitude [m]", lty=c(2,1,3), legend.position='topright')

@

\subsubsection{Velocity components}

Figure \ref{fig:plot-mech-21} shows a comparison of velocity measurements
obtained by the test mechanization scheme in comparison to the measurements
provided by the INS. To construct comparable vertical-motion measurements,
a baro-loop updated to the pressure altitude was introduced in order
to obtain results comparable to those provided by the INS, which also
uses this method to control instability in the variable representing
vertical motion of the aircraft. The resulting variable VSPDX is in
good agreement with the INS-provided measurement, with similar fluctuations
during some short-period maneuvers around 3:34:00 UTC. Some of the
difference in peak amplitude in this region likely originates from
intrinsic filtering (of undisclosed character) applied by the INS
but not included in the new mechanization.

<<acceleration-check, include=TRUE, fig.cap=' '>>=

load (file=SaveRData3)
MaxGap <- 1000
ggvns <- zoo::na.approx (as.vector(Data$GGVNS), maxgap=MaxGap, na.rm = FALSE)
ggvew <- zoo::na.approx (as.vector(Data$GGVEW), maxgap=MaxGap, na.rm = FALSE)
ggvspd <- zoo::na.approx (as.vector(Data$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
Data$BLONGA <- zoo::na.approx (as.vector (Data$BLONGA), maxgap=MaxGap, na.rm=FALSE)
Data$BLATA <- zoo::na.approx (as.vector (Data$BLATA), maxgap=MaxGap, na.rm=FALSE)
Data$BNORMA <- zoo::na.approx (as.vector (Data$BNORMA), maxgap=MaxGap, na.rm=FALSE)
## The following are accelerations determined from derivatives of the GPS velocities.
## These should match the measured accelerations after transformation to the l-frame
## and application of the rotation correction:
.span <- 11
vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1) * 25  # m=1 for first deriv.
vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1) * 25
vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1) * 25
## transform to the a-frame for comparison to the IRU:
G <- Data$Grav
VL <- matrix(c(Data$GGVEW, Data$GGVNS, Data$GGVSPD), ncol=3) 
LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection (Data, VL)
AA <- XformLA (Data, LA, .inverse=TRUE)
AA[,3] <- AA[,3] - G
## smooth to match values from differentiation
# AA[,1] <- signal::sgolayfilt (AA[,1], 3, .span, m=0)
# AA[,2] <- signal::sgolayfilt (AA[,2], 3, .span, m=0)
# AA[,3] <- signal::sgolayfilt (AA[,3], 3, .span, m=0)
fa1 <- lm(Data$BLONGA ~ AA[, 1])
fa2 <- lm(Data$BLATA ~ AA[, 2])
fa3 <- lm(Data$BNORMA ~ AA[, 3])
cfa1 <- coef(fa1)
cfa2 <- coef(fa2)
cfa3 <- coef(fa3)
AB <- matrix(c(Data$BLONGA, Data$BLATA, Data$BNORMA+G), ncol=3) #aircraft-frame 
AL <- XformLA (Data, AB)                                    #l-frame
## now corrected for angular effects
## See Noureldin et al, 2013, Eq. (5.55)
AL <- AL - RotationCorrection (Data, VL)
  
## the resulting l-frame accelerations
Data$LACCX <- AL[, 1]
Data$LACCY <- AL[, 2]
Data$LACCZ <- AL[, 3] + G
Data$LACCZ <- -Data$LACCZ
  
## smooth to match GPS-velocity derivatives
Data$LACCX <- signal::sgolayfilt (Data$LACCX, 3, .span, m=0)
Data$LACCY <- signal::sgolayfilt (Data$LACCY, 3, .span, m=0)
Data$LACCZ <- signal::sgolayfilt (Data$LACCZ, 3, .span, m=0)

@

Because small offsets appear in the measurements of velocity, the
IRU-provided measurements of acceleration were checked by differentiating
the GPS measurements of velocity components and comparing the results,
after correction for motion of the \emph{l-}frame relative to an inertial
frame and for the Earth's rotation, to the corresponding IRU-provided
measurements. The resulting regression-fit coefficients (constant
offset and slope) for the normal and longitudinal components of the
acceleration (BNORMA and BLONGA) were respectively \{\Sexpr{round(cfa3[1], 4)},
\Sexpr{round(cfa3[2], 4)}\} and \{\Sexpr{round(cfa1[1], 4)}, \Sexpr{round(cfa1[2], 4)}\},
so the deduced calibrations are very close to those that provide BNORMA
and BLONGA. For the lateral component (BLATA), accelerations were
usually too small to give a good calibration; although the same procedure
applied to this component gives regression coefficients of \{\Sexpr{round(cfa2[1], 4)},
\Sexpr{round(cfa2[2], 4)}\}, this result appeared too unreliable
to use to adjust the calibration in use. The calibrations for BNORMA
and BLONGA, however, have been used in the preceding methanization,
where they made only very small changes in results.

\subsubsection{Position}

Figure \ref{fig:plot-mech-22} compares the results obtained for position.
There are only small offsets in the horizontal positions that result
from the small differences in horizontal velocity componenets, and
the vertical position also agrees well with the INS-provided value
except for a small offset that apparently originates in different
reference pressures used internally by the INS vs that used in this
new mechanization. The remaining differences between the values provided
by this new mechanization and the result provided by the INS call
for further investigation, but the key result from this part of the
study is that as implemented above the derivatives of components of
the state vector are approximately correct and integrate to reasonable
values. This is a good check on the angle transformations, coordinate
systems, and signs used in the equations giving the mechanization,.
The function providing the required derivatives is therefore a reasonable
basis for the Kalman filter that follows.

\section{Detailed description of the error-state Kalman filter}

\subsection{Definitions of vectors and matrices}

 There are many descriptions of the Kalman filter that provide detailed
algorithms, among them \cite{noureldin2013fundamentals} and \cite{groves2013PrinciplesGNSS},
The implementation here mostly follows the notation of \cite{noureldin2013fundamentals}.The
error-state Kalman filter developed here is based on the assumption
that the INS-provided solution is likely close enough to the true
solution that errors can be represented as linear departures from
that solution where the linear coefficients are given by the Jacobian
of the derivative function that provides the reference solution. That
is, if $\dot{\boldsymbol{x}}=\boldsymbol{D}(\boldsymbol{x})$ where
$\boldsymbol{x}$ is the aircraft-state vector and $\boldsymbol{D}(\boldsymbol{x})$
is the derivative vector provided by the function STMFV(sv) where
sv is the R vector containing the aircraft-state vector and STMFV()
is the R function that generates the derivative vector represented
by $\boldsymbol{D}(\boldsymbol{x})$, the normal mechanization discussed
in the preceding section advances $\boldsymbol{x}$ in time by taking
time steps using the derivative vector $\boldsymbol{D}(\boldsymbol{x})$
to determine the required change in each component of $\boldsymbol{x}$.
If instead an error-state vector $\delta\boldsymbol{x}$ is propagated
forward, the linear estimate of the change in the error-state at each
time step will be given by\\
\begin{equation}
\delta\dot{\boldsymbol{x}}=\frac{\partial\boldsymbol{D}(\boldsymbol{x})}{\partial\boldsymbol{x}}\delta\boldsymbol{x}=\mathcal{\boldsymbol{J}}(x)\delta\boldsymbol{x}\,\,\,\,.\label{eq:jacobian}
\end{equation}
where \emph{$\boldsymbol{\mathcal{J}}$} is the Jacobian matrix of
the derivative vector $\boldsymbol{D}$, defined by this equation.\footnote{Cf.~ \cite{noureldin2013fundamentals}, Eq.~6.2.}
Sources like this footnoted one provide detailed equations for the
Jacobian matrix. However, a different approach has been taken here
because of doubt that deriving, coding, and verifying all the components
of that 15$\times$15 matrix (where the 15 components are three position-errors,
three velocity-errors, three attitude-errors, three rotation-rate
errors, and three accelerometer errors) could be done without a difficult
amount of work. Instead, once the derivative function is determined
and verified as in the preceding section, a numerical Jacobian function
(here, the R routine\footnote{numDeriv::jacobian())} provides the
required matrix $\boldsymbol{\mathcal{J}}$ without further specification.
Furthermore, the common approximations involved in analytical solutions,
where terms expected to be small are dropped, are not necessary with
this approach. 

The error-state Kalman filter sequentially uses a set of matrices,
so it is useful to define those as follows. (Variable names following
the symbols are the R variable names used in the associated code.)
\begin{lyxlist}{00.00.0000}
\item [{$\delta\mathbf{x}_{k}$~{[}SVE{]}}] The error-state vector at
sequential time interval $k$, where values are separated in time
by $\Delta t$. In the present case, the error-state vector consists
of 15 components, the estimated errors in position coordinates, aircraft
velocity vector, aircraft attitude angles, IRU-measured rotation rates,
and IRU-measured accelerations.
\item [{$\mathbf{T}_{k|k-1}$~{[}dcm{]}}] The 15x15 state transformation
matrix describing the forward propagation of the error state from
time $k-1$ to time $k$. $\mathbf{T}$ is the sum of the identity
(diagonal) matrix $\boldsymbol{I}$ and the time step multiplied by
the Jacobian matrix $\boldsymbol{\mathcal{J}}$ defined in (\ref{eq:jacobian}).
Then $\delta\boldsymbol{x}_{k}=\boldsymbol{T}_{k,k-1}\delta\boldsymbol{x}_{k-1}=(\boldsymbol{I}+\boldsymbol{\mathcal{J}}(\boldsymbol{x}_{k-1})\Delta t)\delta\boldsymbol{x}_{k-1}$(or,
alternately, the equivalent fourth-order Runge-Kutta step) propagates
the error state forward in time.
\item [{$\mathbf{V}$~{[}CV{]}}] The covariance matrix that applies to
the state vector $\delta\mathbf{x}$, a 15x15 matrix.
\item [{$\mathbf{K}$~{[}K{]}}] The Kalman-gain matrix representing how
the error-state vector is updated using the current error state and
the new GPS measurements.
\item [{$\delta\mathbf{z}$~{[}DZ{]}}] The 6-component measured differences
between the INS and GPS measurements of position and velocity.
\item [{$\mathbf{H}$~{[}H{]}}] The 15x6-component matrix representing
how the measured differences $\delta\mathbf{z}$ correspond to the
error-state vector. 
\item [{$\mathbf{Q},\,\mathbf{R}$~{[}Q,~R{]}}] Matrices representing
respectively the anticipated noise contributions affecting the error-state
vector (15x15) and the measurements from the GPS (6x6).
\end{lyxlist}
The approach taken here will be to filter the error-state vector that
represents the difference between the best-estimate measurements and
those originally provided by the INS. 

\subsection{Some component functions}

Some of the operations involved in that ``mechanization'' are contained
in the following functions, with code as in the associated R ``chunks''
that are embedded in the ``KalmanFilter.Rnw'' file that produces
this document and also controls the associated calculations. The code
for the functions is not listed here but is available in that file
which is archived with the text document
\begin{enumerate}
\item \emph{\uline{XfLArV()}}, a function of the current state vector,
provides a 3x3 matrix that transforms a vector from the \emph{a-}frame
(the aircraft reference frame) to the \emph{l-}frame, the local-level
frame (with \{x,y,z\} coordinates toward the East, North, and upward
directions). 
\item \emph{\uline{RotationCorrection()}} calculates the correction to
accelerations needed to account for the rotation of the Earth and
of the \emph{l-}frame relative to an inertial frame. This function
provides corrections to subtract from transformed accelerations before
using them in the \emph{l-}frame.
\item \emph{\uline{STMFV()}} calculates the 15-component derivative of
the state vector given the state vector and the measurements from
the IRU. This function is then used in the R function numDeriv::jacobian
to find the Jacobian needed for the state transformation matrix.
\end{enumerate}

\clearpage

\subsection{Sequential steps in the error-state Kalman filter}

The preceding steps verify that reasonable derivatives of the state
variables are available. On that basis, an error-state Kalman filter
can be developed as follows:
\begin{enumerate}
\item The first step is to initialize an error-state-vector $\delta\mathbf{x}$
from initial measurements of the differences between the INS and GPS
values of position and velocity. Other errors are unknown at the start
of the integration and so will be initialized as zero.
\item The covariance matrix $\mathbf{V}$ characterizing the errors in the
error-state-vector is also needed. This is here initialized to have
rather large components because it is expected that the GPS measurements
will have much lower unceertainty than these INS-provided components.
$\mathbf{V}$ is initialized as a 15x15 diagonal matrix where the
diagonal elements are the squares of these values: \{2000/$R_{m}$,
2000/($R_{n}$cos$\Phi$), 500, 2, 2, 2, 0.3$^{\circ}$, 0.3$^{\circ}$,
1$^{\circ}$, 0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$,
0.0005, 0.0005, 0.0005\}. All entries are in SI units escelt those
labeled as $^{\circ}$, in which case the values are converted to
radians before use. The variables $R_{m}$ and $R_{n}$ are appropriate
radii of the Earth. (See the code) 
\item The function STMFV() was verified above and so provides a reasonable
representation of the derivatives of the state vector. For an error-state
Kalman filter, the propagation of the error state can be found from
the Jacobian of that function, so the state transition matrix is the
sum of that Jacobian (multiplied by the time step) and the 15-element
diagonal matrix:\\
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}
\item The noise-covariance matrix $\mathbf{Q}$ represents the noise in
the solution. This is initialized as indicated in the code, via function
GCF().
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are specified, the covariance
matrix can be updated via\\
\[
\mathbf{V}\leftarrow\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]
\item The Kalman gain is then given by\\
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]
where $\mathbf{H}$ is a 15X6 diagonal matrix representing how the
6 measured differences (GPS-INS) correspond to the error-state vector.
$\mathbf{R}$ is the measurement-noise covariance matrix representing
the GPS noise, a 6x6 matrix having diagonal elements that are taken
to be the squares of these components: \{50/$R_{m}$, 50/($R_{n}\cos\Phi$,
100, 0.1, 0.1, 0.1\}.
\item Define \textbf{$\delta\mathbf{z}$ }as the set of six measurements
consisting of the differences between GPS and INS positions and velocities.
The error-state vector is then further updated as follows:\\
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]
\item Finally, the covariance matrix is updated further according to\\
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]
\end{enumerate}
To apply these equations, it is not necessary to use a high-rate file
and update at high rate because it is expected that the errors vary
slowly. However, turns and other maneuvers can introduce spurious
effects if there are time delays among the measurements, so adjustment
for these sub-second delays will be made before the filter is applied.
A 1-Hz data file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles as well as
the rotation rates and accelerations will be smoothed before applying
the Kalman filter. DEEPWAVE flight 16 was selected, and the measurements
were filtered with 11-point third-order Savitzky-Golay smoothing of
accelerations and 301-point smoothing of measured velocity components
and attitude angles. The effective cutoff frequencies for these filters
are about 0.3~Hz and 0.008~Hz, respectively. 

<<new-data, include=TRUE, echo=FALSE>>=

Flight <- "16" 				
Project = "DW"     			 
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
SaveRData4 <- sprintf("%s4.Rdata", thisFileName)
ReloadData <- TRUE
if (ReloadData) {
  D1 <- getNetCDF (fname, VarList)		
  save(D1, file=SaveRData4)
} else {
  load (file=SaveRData4)
}
DL <- nrow(D1)
dt <- 1
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
Re <- StandardConstant ('Re')
D1$THDG <- ShiftInTime (D1$THDG, 1, 80)  
# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2 + D1$GGALT)
  #interpolate if necessary:
  MaxGap <- 1000
  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
  D1$LON <- zoo::na.approx (as.vector (D1$LON), maxgap=MaxGap, na.rm=FALSE)
  D1$ALT <- zoo::na.approx (as.vector (D1$ALT), maxgap=MaxGap, na.rm=FALSE)
  ## smooth the measurements
  .span <- 11    
  ## The following are accelerations determined from derivatives of the GPS velocities.
  ## These should match the measured accelerations after transformation to the l-frame
  ## and application of the rotation correction:
  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
  ## transform to the a-frame for comparison to the IRU:
  G <- D1$Grav
  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection (D1, VL)
  AA <- XformLA (D1, LA, .inverse=TRUE)
  AA[,3] <- AA[,3] - G
  fa1 <- lm(D1$BLONGA ~ AA[, 1])
  fa2 <- lm(D1$BLATA ~ AA[, 2])
  fa3 <- lm(D1$BNORMA ~ AA[, 3])
  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame 
  AL <- XformLA (D1, AB)                                    #l-frame
  ## now corrected for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  AL <- AL - RotationCorrection (D1, VL)
  
  ## the resulting l-frame accelerations
  D1$LACCX <- AL[, 1]
  D1$LACCY <- AL[, 2]
  D1$LACCZ <- AL[, 3] + G
  D1$LACCZ <- -D1$LACCZ
  
  ## smooth to match GPS-velocity derivatives
  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
  .span <- 301
  SMOOTH <- FALSE
  if (SMOOTH) {
    vns <- signal::sgolayfilt (vns, 3, .span)
    vew <- signal::sgolayfilt (vew, 3, .span)
    vspd <- signal::sgolayfilt (vspd, 3, .span)
    ggvns <- signal::sgolayfilt (ggvns, 3, .span)
    ggvew <- signal::sgolayfilt (ggvew, 3, .span)
    ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
    pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
    roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
    thdg <- signal::sgolayfilt (D1$THDG, 3, .span)

    D1$VNSF <- vns
    D1$VEWF <- vew
    D1$VSPDF <- vspd
    D1$GGVNSF <- ggvns
    D1$GGVEWF <- ggvew
    D1$GGVSPDF <- ggvspd
    D1$PITCHF <- pitch
    D1$ROLLF <- roll
    D1$THDGF <- thdg
  }
## get the pitch and roll in the l-frame:
.pitch <- D1$PITCH * Cradeg
.roll <- D1$ROLL * Cradeg
.thdg <- D1$THDG * Cradeg
x <- XPitch (.pitch, .roll, .thdg)
# pitchL <- x[,1]
# rollL <- x[,2]
  ## note: all in units of radians
  # pitchL <- cos (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg) - sin (.thdg) * sin (D1$ROLL*Cradeg)
  # rollL  <- sin (.thdg) * sin (D1$PITCH*Cradeg) * cos (D1$ROLL*Cradeg) + cos (.thdg) * sin (D1$ROLL*Cradeg)
D1$PITCHL <- x[, 1] / Cradeg  #pitchL
D1$ROLLL <-  x[, 2] / Cradeg  #rollL

fm1 <- lm (vedot ~ D1$LACCX)
fm2 <- lm (vndot ~ D1$LACCY)
fm3 <- lm (vudot ~ D1$LACCZ)

@

As a check on the uncertainty associated with the accelerometers,
the GPS measurements of velocity components were differentiated and
the resulting accelerations transformed to the \emph{a}-frame and
compared to the measured accelerations from the IRU (with correction
for the Earth's rotation and the motion of the \emph{l}-frame relative
to an inertial frame). For the longitudinal acceleration (along the
aircraft axis), the linear regression of the measured acceleration
vs the GPS-derived acceleration had offset \Sexpr{round(coef(fa1)[1], 4)}
and slope \Sexpr{round(coef(fa1)[2], 4)}, with residual standard
deviation of \Sexpr{round(summary(fa1)$sigma, 4)}\,m\,s$^{-2}$.
For the normal component of acceleration, the corresponding values
are respectively \Sexpr{round(coef(fa3)[1], 4)}, \Sexpr{round(coef(fa3)[2], 4)}.,
and \Sexpr{round(summary(fa3)$sigma, 4)}\,m\,s$^{-2}$. These then
can be considered calibrations for the accelerometers as well as indications
of their uncertainty. \footnote{The lateral accelerations were too noisy for a similar calibration
because lateral accelerations are usually small and short-term except
during periods with significant slip, which were not present on this
flight.}

The differentiated measurements of velocity components from the GPS
might be considered as additional measurements corresponding to the
measured accelerations that could be incorporated into the Kalman
filter. This is discussed later in this report.

\subsection{Detecting the error in heading}

Most of the components of the state vector have good feedback from
GPS-derived measurements, but an exception is the measurement of heading.
For position and velocity, there is direct correspondence between
INS- and GPS-derived measurements. For pitch and roll, there is strong
coupling to errors in the eastward and northward components of aircraft
velocity. However, the coupling of INS-measured heading to GPS observations
is not a case of strong coupling (to which the Schuler oscillation
applies), and it is more difficult to update via measurements from
the GPS receiver. The source of coupling between GPS-derived measurements
and heading is via the aircraft-velocity components, because an error
in heading causes the IRU-measured accelerations to be resolved into
the \emph{l-}frame incorrectly and so introduces errors in the aircraft-velocity
components that can be detected via comparison to GPS-provided velocity
components. Unfortunately, in most cases the measured accelerations
are small, resulting in large uncertainties in the correction term
except during turns, and there are alternative adjustments to the
accelerations or rotation rates that can account for the same errors.
Therefore, heading will receive special treatment here.

Three approaches were tried:
\begin{enumerate}
\item The Kalman-filter structure as described above will use the errors
in velocity to correct the error-state vector. The coupling to heading
is typically an order of magnitude weaker than that to pitch or roll.
Without special attention, the coupling to heading potentially can
be obscured by the other sensitivities, through which the errors in
velocity can be attributed to error-state components in horizontal
acceleration and in roll and pitch. In turn, an error in heading is
dependent mostly on errors in the gyro rotation rates. These sensitivities
make it difficult to obtain a reliable adjustment of heading in the
standard approach, and the results from this approach were generally
disappointing.
\item The \emph{l-}frame accelerations measured by differentiating the GPS-derived
horizontal velocity components can be used as additional components
of the observation vector, complementing the position and velocity
measurements from GPS. These accelerations can then be used as independent
measurements of acceleration. While this provides some additional
adjustable parameters for the filter associated with the covariances
of the GPS-derived accelerations, the errors in acceleration can still
be attributed to errors in the measured accelerations. In tests, this
seemed to add little to the sensitivity of the Kalman filter to errors
in heading.
\item The most successful approach was to compare the measured horizontal-acceleration
vector, obtained by transforming the measured \emph{a-}frame accelerations
to the \emph{l-}frame, to the acceleration determined by differentiating
the GPS-measured components of horizontal velocity. The angle between
these two vectors is a measure of the heading error and can be used
as a component of the observation vector $\mathbf{Z}$ with which
to update the heading. Specifically, the error in heading ($\delta\psi)$
is measured to be\\
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}
where $a_{e}^{(l)}$ and $a_{n}^{(l)}$ are the \emph{l-}frame accelerations
obtained by transforming the IRU-measured accelerations from the \emph{a-}frame
to the \emph{l-}frame and $\dot{v}_{e}$ and $\dot{v}_{n}$ are the
eastward and northward components of the acceleration obtained from
the time-derivatives of the GPS-measured eastward and northward velocity
components $v_{e}$ and $v_{n}$. The assumption made when using this
formula is that the errors in the INS-produced accelerations in the
\emph{l-}frame arise from the heading error, with negligible contribution
from the errors in the accelerometers. If this is the case, it would
be possible to base the heading correction on this formula alone,
but the more general case needs to consider how this might be influenced
by errors in accelerations, so it is preferable to incorporate this
into the Kalman filter and allow for the possibility that measured
accelerations need to be adjusted.
\end{enumerate}
The third approach leads to noisy estimates of the correction $\delta\psi$
under most conditions, but will give reliable results when horizontal
accelerations are significant (e.g., $>1$~m/s$^{2}$). Because such
accelerations often occur in turns when both angles in (\ref{eq:Hcorr})
are changing rapidly, it is very important to have correct relative
timing between the INS measurement of heading and the GPS measurement
of velocity.\footnote{As an illustration, a 50-ms delay in heading during a 3-min turn causes
a shift in heading relative to the correct time of 0.1$^{\circ}$,
so adjustment to at least this uncertainty is desirable. } The GPS measurements are assigned correct times by the GPS receiver
and represent a standard clock against which to compare other measurements.\footnote{It appears that the relative timing between the IRU and the GPS can
drift enough during some flights to introduce significant errors.} If the GPS-vs-INS time shift is not removed, a bias will be introduced
into the heading correction that varies with turn direction. Therefore
the following procedure is followed to remove this time shift:
\begin{enumerate}
\item Differentiate the GPS-provided measurements to obtain $\dot{v}_{e}$
and $\dot{v}_{n}$, the eastward and northward accelerations in the
\emph{l-}frame.
\item Transform the unshifted body accelerations to the \emph{l-}frame,
with rotation corrections, to obtain the eastward and northward components
of the IRU-measured acceleration ($a_{e}^{(l)}$, $a_{n}^{(l)}$)
in the local-level frame. 
\item Find the heading correction for unshifted measurements by calculating
$\delta\psi$ from (\ref{eq:Hcorr}).
\item Calculate the running-standard-deviation of $\delta\psi$ spanning
30 seconds. Select the subset of $\delta\psi$ for which that standard
deviation is less than 0.2$^{\circ}$.
\item Fit the subset to find the slope $b$ in the relationship $\delta\psi=a+b\thinspace\tan\phi$
where $\phi$ is the roll angle. The rate of turn $R$ is related
to the roll angle $\phi$ according to the relationship $R=g\thinspace\tan\phi/V$
where $V$ is the airspeed, so $\tan\phi=RV/g$ and $\delta\psi=a+bRV/g$.
A time delay of $\delta t$ produces a heading error of $-R\delta t$,
so $-R\delta t=a+bRV/g$ and the time shift can be estimated from\\
\begin{equation}
\delta t=-b\frac{V}{g}\label{eq:deltaT}
\end{equation}
For example, for DEEPWAVE flight 16, $b=0.2146^{\circ}$s$^{-1}$
= 0.003745\,rad\,s$^{-1}$ and $V\simeq240$\,m\,s$^{-1}$, so
(with g=9.8\,m\,s$^{-2}$) $\delta t=$-0.092~s. The negative sign
indicates that the INS-derived measurement of heading should be shifted
forward in time by 92\,ms relative to the GPS-derived measurements
of aircraft velocity. The standard error from the fit indicates that
this shift was determined with an uncertainty of about 3\,ms, so
this is a very sensitive method for determining the time shift.
\item Apply this time shift to the measurements of heading. For a file containing
measurements at 1~Hz, this requires creating an interpolated high-rate
vector of measurements, shifting that vector, and then extracting
a shifted 1-Hz-averaged vector from the shifted measurements. The
Ranadu function ShiftInTime() accomplishes this by interpolating to
a 125-Hz variable. The result can be checked by repeating step 5 using
the shifted measurements; for this case, the deduced shift needed
for the shifted time series was only 1~ms. 
\end{enumerate}

<<Kalman-setup, include=TRUE, echo=FALSE, cache=FALSE>>=

## also need the noise vector:
tau <- 60
GCF <- function (sv, sp) {
  gcf <- vector('numeric', length=15)
  gcf[1] <- 30 / sp$Rm
  gcf[2] <- 30 / (sp$Rn * cos (sv[1]))
  gcf[3] <- 150
  gcf[4:5] <- 0.15
  gcf[6] <- 1.5
  gcf[7:8] <- 0.03*Cradeg # 0.001 * 10  ##TEST
  gcf[9] <- 0.01*Cradeg
  gcf[10:12] <- 0.05*Cradeg*sqrt(2/tau)
  gcf[13:15] <- 0.0005*sqrt(2/tau)
  return (gcf)
}
i <- 1
gcf <- as.numeric (GCF (SV, D1[i, ]))
# Gnoise <- gcf * rnorm(15)
# dsve <- dcm %*% SVE   # + Gnoise
# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step

## The measurement model:
DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS, VSPD-GGVSPD))
DZ <- c(DZ, D1$LACCX-vedot, D1$LACCY-vndot, D1$LACCZ-vudot, D1$herr*Cradeg)
dim(DZ) <- c(DL, 10)
DZ[,1:2] <- DZ[, 1:2] * Cradeg

## the observation matrix: (the first six components of the state error vector are observable)
H <- diag(1, nrow=10, ncol=15)
for (k in 7:9) {
  H[k,k] <- 0
  # H[k,k+6] <- 1
}
H[10,10] <- 0

## at any time step, assume the measurements are contaminated by noise:
## GPS measurement noise
# RN <- c(50/D1$Rm[1], 50/(D1$Rn[1]*cos(SV[1])), 10, 0.1, 0.1, 0.1)
RCV <- matrix (rep(0,36), ncol=6)
RCV[1,1] <- (1500/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (1500/(D1$Rn[1]*cos(SV[1])))^2
RCV[3,3] <- 300^2
RCV[4,4] <- 3^2            ## ve
RCV[5,5] <- 3^2
RCV[6,6] <- 3^2
RCV[7,7] <- 1^2
RCV[8,8] <- 1^2
RCV[9,9] <- 1^2
RCV10 <- (0.5*Cradeg)^2  #0.1
RCV[10,10] <- RCV10 / A[i]^4

## initialize covariance matrix
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)


@

<<Kalman-loop, include=TRUE, echo=TRUE, eval=TRUE, fig.cap=' ', cache=FALSE>>=

Data <- D1
DL <- nrow (Data)
BACKWARD <- FALSE
s <- -120
si <- 0
SHIFT <- FALSE
if (SHIFT) {
  Data$GGVEW <- ShiftInTime (Data$GGVEW, Rate, s)    ## this is needed for pitch correction
  Data$GGVNS <- ShiftInTime (Data$GGVNS, Rate, s)
  # Data$BLONGA <- ShiftInTime (Data$BLONGA, Rate, s-80)
  # Data$BLATA <- ShiftInTime (Data$BLATA, Rate, s-80)
  # Data$BNORMA <- ShiftInTime (Data$BNORMA, Rate, s-80)
}
  # find PITCHL, ROLLL in the l-frame
  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal to AC
  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
  # UVL <- XformLA (Data, UV)
  # PitchL <- asin (-UVL[,2])
  # RollL <- asin (UVL[,1])
  #   .hdg <- Data$THDG*Cradeg
  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg

## note: using l-frame PITCH and ROLL; STMFV must account for this
i <- 1
if (BACKWARD) {i <- DL}
SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
NSTEP <- 5      ## update time
SVEF <- array(dim=c(DL/NSTEP, 15))
CVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[1, 1:6]
SVE[7:8] <- 0  ## might initialize using pitch/roll/heading-correction functions here
SVE[9] <- -0.08 * Cradeg
## start with zero for gyro and accelerometer errors
SVEF[1, ] <- SVE
CVEF[1, ] <- diag (CV)
# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
nStart <- 1+NSTEP
nEnd <- DL
NS <- NSTEP
if (BACKWARD) {
  nStart <- DL-NSTEP
  nEnd <- 1
  NS <- -NSTEP
}
pcntlast <- 0
# for (i in seq(2*NSTEP, DL, by=NSTEP)) {
for (i in seq (nStart, nEnd, by=NS)) {
  pcnt <- as.integer ((i-nStart) / (nEnd-nStart) * 100)
  if ((pcnt %% 10) == 0 && pcnt != pcntlast) {
    print (sprintf ('percent done=%d', pcnt))
    pcntlast <- pcnt
  }
  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCHL, ROLLL, THDG,
                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- Data$Rn[i]
  Rm <- Data$Rm[i]
  Grav <- Data$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
  if (i == 1+NS*500) {dcmSave <- dcm}
  ## modify to include this?
## modify this to include decaying error terms for the measurements:
# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new state vector:
  SVE <- dcm %*% SVE
  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  ## the Kalman gain:
  RCV[10,10] <- Data$varh[i]
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
  CVEF[i/NSTEP, ] <- diag(CV)
}

## interpolate the results over the full data.frame:
  IntFilter <- function (X, inRate, outRate) {
    if (inRate == outRate) {return (X)}
    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
    x <- 0:(length(X)-1)
    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
    T <- A$y
    T <- signal::filter(signal::sgolay(4,75),T)
    ## now shift to match 25-Hz:
    n <- as.integer (ratio / 2)
    NL = length(T)
    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
    return (T)
  }
  Cor <- vector('numeric', DL*15)
  dim (Cor) <- c(DL, 15)
  VCor <- vector ('numeric', DL*15)
  dim (VCor) <- c(DL, 15)
  X <- SVEF[, 1]
  for (j in 1:15) {
    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
    VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
  }
  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
  Data$ALTKF <- Data$ALT - Cor[, 3]
  Data$VEWKF <- Data$VEW - Cor[, 4]
  Data$VNSKF <- Data$VNS - Cor[, 5]
  Data$VSPDKF <- Data$VSPD - Cor[, 6]
  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
  Data$BLATAKF <- Data$BLATA - Cor[, 13]
  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]

## smooth the pitch, roll, and heading corrections:
  for (k in 7:9) {
    Cor[, k] <- SmoothInterp (Cor[, k], .Length=1801)
  }
  x <- XPitch(Data$PITCHL*Cradeg-Cor[,7], Data$ROLLL*Cradeg-Cor[,8], Data$THDG*Cradeg-Cor[,9], .inverse=TRUE)
  Data$PITCHKF <- x[,1]/Cradeg
  Data$ROLLKF <- x[,2]/Cradeg
  Data$THDGKF <- Data$THDG-Cor[,9]/Cradeg

Data$DLAT <- Data$LATKF-Data$GGLAT
Data$CLAT <- -Cor[,1] / Cradeg
Data$DLON <- Data$LONKF-Data$GGLON
Data$CLON <- -Cor[,2] / Cradeg
Data$DALT <- Data$ALTKF-Data$GGALT
Data$CALT <- -Cor[,3]
Data$DVEW <- Data$VEWKF-Data$GGVEW
Data$CVEW <- -Cor[,4]
Data$DVNS <- Data$VNSKF-Data$GGVNS
Data$CVNS <- -Cor[,5]
Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
Data$CVSPD <- -Cor[,6]
Data$CPITCH <- Data$PITCHKF-Data$PITCH
Data$CROLL <- Data$ROLLKF-Data$ROLL
Data$CTHDG <- Data$THDGKF-Data$THDG
KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.",
                    "Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines show the corrections applied to the original INS values by the Kalman filter.",
                      "Pitch Correction from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch (PC, red line)",
                      "Roll Correction from the Kalman filter (CROLL) and from Ranadu::CorrectPitch (RC, red line)",
                      "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")

@

\section{Results}

There are several tests that the corrected values should pass:
\begin{enumerate}
\item Because the GPS measurements of position and aircraft velocity have
low uncertainty, the results from the Kalman filter should match the
GPS-provided values for these variables in long-term average, perhaps
with some high-frequency components not present in the GPS-provided
measurements.
\item The pitch-correction algorithm developed in the Technical Note on
Wind Uncertainty should give results in reasonable agreement with
the values of pitch and roll resulting from the Kalman filter.
\item The heading-correction algorithm developed previously should also
produce results consistent with the results from the Kalman filter.
\end{enumerate}
<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=KalmanCaptions, cache=FALSE>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
PC <- CorrectPitch(Data, .span=601)
Data$PC <- -PC[, 1]
Data$RC <- -PC[, 2]
## translate pitch/roll corrections to the a-frame:
.hdg <- Data$THDG * Cradeg
CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
Data$CPITCH <- CPITCH / Cradeg
Data$CROLL <- CROLL / Cradeg
Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
Data$HC <- CorrectHeading (Data, .plotfile='./HCPlot.pdf')
r <- setRange (Data, 70000, 123000)
plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH CORRECTION',' [',degree,']')), ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'))
ival <- abs(Data$ROLL) > 4
Data$CPITCH[ival] <- NA
Data$PC[ival] <- NA
lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), ylab=expression(paste('ROLL CORRECTION [',degree,']')), ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'))
Data$CROLL[ival] <- NA
Data$RC[ival] <- NA
lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)))

@

\bibliographystyle{copernicus}
\bibliography{WAC}

\clearpage

\begin{center}
\textsf{\textcolor{blue}{\textendash{} End of Memo \textendash{}}}
\par\end{center}

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow:}}} & Workflow\Sexpr{thisFileName}.pdf\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & https://github.com/WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}


\end{document}
