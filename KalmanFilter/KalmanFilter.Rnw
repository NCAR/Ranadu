%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\usepackage{babel}
\begin{document}
\EOLmemo 

\global\addressee={Wind Uncertainty TN file}  

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & A Kalman filter to apply corrections to the wind measurements\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
# note that fig.pos="center" gave errors, changed to fig.align
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
thisFileName <- "KalmanFilter"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)
source ('~/RStudio/Ranadu/R/theme_WAC.R')
setwd ('~/RStudio/Ranadu/KalmanFilter')
Directory <- DataDirectory ()
Flight <- "rf15HR" 				# XXX change this
Project = "DWIRU"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
# ReloadData <- TRUE
SaveRData <- sprintf("%s.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  save (Data, file=SaveRData)
} else {
  load (file=SaveRData)
}

@

\section*{Introduction and scope}

The intent of this study is to evaluate the errors present in the
measurements of attitude angles from the IRU on the NSF/NCAR~GV by
means of a Kalman filter applied to the difference between measurements
from a GPS and corresponding measurements from the IRU. The redundant
measurements are those of position and velocity,\footnote{Because GPS measurements of velocity have low uncertainty, those measurements
could be differentiated and, after transformation to the aircraft
reference frame, used as error measurements for the measured accelerations.
This has not been explored as yet, and it is not clear that this would
provide information beyond that arising from the Kalman-filter updates
using only velocity.} for which the GPS measurements are clearly superior especially at
low rate, so a necessary result will be that the corrected measurements
should be quite close to those from the GPS. The advantage of this
analysis, though, is that the coupling between errors in the attitude
angles and those in velocity makes it possible to evaluate the errors
in the attitude angles also.

Before describing the implementation of the filter, it is useful to
explain the basic concept underlying a Kalman filter. A Kalman filter
provides a means of updating a sequence of state vectors (consisting,
in the present case, of INS measurements of position, velocity, and
attitude angles) by comparison to an independent set of measurements
(e.g., GPS-derived measurements of position and velocity). The updated
state vector obtained by this process consists of an appropriately
weighted combination of the state vector projected forward using normal
INS ``mechanization'' (i.e., determining the next step by using
the measured acceleration and rotation from the IRU) and the independent
measurements from GPS. Because errors in the state vector are coupled,
the update procedure can estimate errors in the attitude angles as
well as the components of the state vector that are measured directly
by the GPS. This is the primary reason for using a Kalman filter to
improve the wind measurements: Although the measurements of position
and velocity that result should differ little from those provided
by the GPS, the corrections to the attitude angles (pitch, roll, and
heading) can be estimated even though there is no direct measurement
of these except from the INS.

The weighting of the projected-forward state and new measurements
from GPS depends on obtaining estimates of the covariance matrix describing
the state vector as well as estimates of the noise sources contaminating
the measurements from both the GPS and the IRU-provided accelerations
and rotations. With proper weighting, the result should combine the
good high-frequency response of the INS with the good long-term stability
of the GPS. The covariance matrix characterizing the state vector
is updated as the filter is applied, but appropriate weighting depends
on reasonable estimation of the other error terms.

The operation of the filter depends on sequential use of a set of
matrices, so it is useful to define those as follows, where the variable
names following the symbols are the R variable names used in the following
code:
\begin{lyxlist}{00.00.0000}
\item [{$\delta\mathbf{x}_{k}$~{[}SVE{]}}] The error-state vector at
time index $k$. In the present case, this consists of these 15 components:
estimated errors in position, aircraft velocity, aircraft attitude,
IRU-measured rotation rate, and IRU-measured accelerations.
\item [{$\mathbf{T}_{k|k-1}$~{[}dcm{]}}] The 15x15 state transformation
matrix describing INS mechanism for the change from time $k-1$ to
time $k$. Then $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
where $\mathbf{T}$ combines the unit diagonal matrix with the time
step multiplied by the derivative matrix describing the state transformation.
As applied to the state vector, this state transformation matrix would
involve the derivatives used for normal INS mechanization to get how
the state vector advances, and so would duplicate the action of the
internal INS data processing. As interpreted for an error-state Kalman
filter, the matrix $\mathbf{T}$ is obtained by calculating the Jacobian
of that state-transition function as a function of the error-state
components. 
\item [{$\mathbf{V}$~{[}CV{]}}] The covariance matrix that applies to
the state vector $\delta\mathbf{x}$, a 15x15 matrix
\item [{$\mathbf{K}$~{[}K{]}}] The Kalman-gain matrix representing how
the error-state vector is updated using the current error state and
the new GPS measurements.
\item [{$\delta\mathbf{z}$~{[}DZ{]}}] The 9-component measured differences
between the INS and GPS measurements of position, velocity and acceleration.
The latter three components are obtained by differentiating the GPS-provided
velocity components. This differs from most conventional approaches
but proves useful for contraining the measurement of heading.
\item [{$\mathbf{H}$~{[}H{]}}] The 15x9-component matrix representing
how the measured differences $\delta\mathbf{z}$ correspond to the
state vector. 
\item [{$\mathbf{Q},\,\mathbf{R}$~{[}Q,~R{]}}] Matrices representing
respectively the anticipated noise contributions affecting the error-state
vector (15x15) and the measurements from the GPS (9x9).
\end{lyxlist}
The approach taken here will be to filter the error-state vector that
represents the difference between the best-estimate measurements and
those originally provided by the INS. The INS integration does not
need to be duplicated here to obtain the reference solution because
that is already available. However, the Kalman filter does need the
``state transition matrix'' that represents the forward integration,
so the first step in this analysis is to obtain such a matrix and
validate results using it against the available INS solution. The
Jacobian of that state-transition function then provides the matrix
$\mathbf{T}$ used in this filter.

\section*{Some component functions}

Some of the operations involved in that ``mechanization'' are contained
in the following functions, with code as in the associated R ``chunks.''
\begin{enumerate}
\item \emph{\uline{XfLArV()}}, a function of the current state vector,
provides a 3x3 matrix that transforms a vector from the a-frame (the
aircraft reference frame) to the l-frame, the local-level frame (with
\{x,y,z\} coordinates toward the East, North, and upward directions). 
\item \emph{\uline{RotationCorrection()}} calculates the correction to
accelerations needed to account for the rotation of the Earth and
of the l-frame relative to an inertial frame. This function provides
corrections to subtract from transformed accelerations before using
them in the l-frame.
\item \emph{\uline{STMFV()}} calculates the 15-component derivative of
the state vector given the state vector and the measurements from
the INU. This function is then used in the R function numDeriv::jacobian
to find the Jacobian needed for the state transformation matrix.
\end{enumerate}
<<utility-functions, include=TRUE, echo=FALSE>>=

XfLArV <- function (data) {   ## XfLA but using input in radians and single row
  # data must contain PITCH, ROLL, HEADING as components [7:9]
  cosphi <- cos (data[8])
  sinphi <- sin (data[8])
  costheta <- cos (data[7])
  sintheta <- sin (data[7])
  cospsi <- cos (data[9])
  sinpsi <- sin (data[9])
  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-sinpsi*sintheta*cosphi,
           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinphi-cospsi*sintheta*cosphi,
           -sintheta, costheta*sinphi, -costheta*cosphi)
  RblM <- aperm( array (Rbl, dim=c(3,3)))
  return (RblM)
}

# other-functions ---------------------------------------------------------

Cradeg <- pi/180
dt <- 1/25               ## working with 25-Hz file
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')
Ree <- 6378137
Ecc <- 0.08181919
## The next correction calculates the correction needed to account for the rotation
## of the Earth and of the l-frame (ENU frame). See Noureldin et al., 2013, 
## Eqs. 5.55--5.57. Subtract this from the transformed accelerations before using them.
RotationCorrection <- function (.data, .V) {
  Cradeg <- pi/180
  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
  DL <- nrow (.data)
  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
  lat <- .data$LAT * Cradeg
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  Ree <- 6378137
  Ecc <- 0.08181919
  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
  M23 <- .V[,2] / Rm
  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
  M32 <- -.V[,2] / Rm
  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
  return (C)
}

Gravity <- function (latitude, altitude=0.) {
  sl2 <- (sin (latitude * Cradeg))^2
  g <- 9.780327 * ((1. + 0.001931851 * sl2) / 
                     (1. - 0.006694380 * sl2)) - 3.086e-6 * altitude
  ## Somigliana formula 1980 GRS:
  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 * altitude^2
  return(g)
}

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
Re <- StandardConstant ('Re')
# The following is commented because it is already in the Somagliana equation
# Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
#   (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)
STMFV <- function (sv, .aaframe='a') { 
  stmf <- vector('numeric', length=15)
  ## transform back to a-frame if necessary
  if (.aaframe == 'l') {
    svs7 <- sv[7]
    svs8 <- sv[8]
    sv[7] <- cos (sv[9]) * svs7 + sin (sv[9]) * svs8
    sv[8] <- -sin (sv[9]) * svs7 + cos (sv[9]) * svs8
  }
  rlm <- XfLArV(sv)    
  omega <- as.vector (c(-sv[5] / Rm, 
                        OmegaE*cos(sv[1])+sv[4]/(Rn),
                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2], omega[1], 0), ncol=3)
  Oilb <- Oill %*% rlm
  ## find the derivative of the transformation matrix:
  ## (must recalculate SRM from measured rotation rates)
  SRR <- c(0, -sv[12], -sv[10],
           sv[12], 0, sv[11],
           sv[10], -sv[11], 0)
  SRM <- aperm( array (SRR, dim=c(3,3)))
  dRLA <- rlm %*% SRM - Oilb
  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
  Grav <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch and roll!
  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-frame
  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
  ## now correct for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  VL <- c(sv[4], sv[5], sv[6])
  C <- vector ('numeric', 3)
  lat <- sv[1]
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
  M23 <- VL[2] / Rm
  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
  M32 <- -VL[2] / Rm
  C[1] <- M12 * VL[2] + M13 * VL[3]
  C[2] <- M21 * VL[1] + M23 * VL[3]
  C[3] <- M31 * VL[1] + M32 * VL[2]
  AL <- as.vector (AL - C, mode='numeric')
  AL[3] <- AL[3] + Grav
  AL[3] <- -AL[3]
  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
            0, 0, 0, 0, 0, 0)
  ## return sv to original if necessary
  if (.aaframe == 'l') {
    sv[7] <- svs7
    sv[8] <- svs8
  }
  return (as.vector (stmf, mode='numeric'))
}

@

<<INS-data, include=TRUE, echo=FALSE>>=

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA, BNORMA, 
                              BPITCHR, BROLLR, BYAWR,
                              GGVEW, GGVNS, Grav))

## adjustments:
SP$BYAWR <- SP$BYAWR - 0.005
SP$BROLLR <- SP$BROLLR + 0.0005
SP$BPITCHR <- SP$BPITCHR + 0.0005
# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
# SP$BLONGA <- SP$BLONGA * 0.96
# SP$BLATA <- SP$BLATA * 1.1
SP$BPITCHR <- SP$BPITCHR * Cradeg
SP$BROLLR <- SP$BROLLR * Cradeg
SP$BYAWR <- SP$BYAWR * Cradeg

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
SPR <- SP   ## save what INS produced, as reference

@

\section*{The integration steps}

The purpose of this section is to demonstrate that the INS mechanization
used to find the error-state transformation matrix provides a valid
and independent means of propagating the measurements of position,
velocity, and attitude forward in time. The procedure used for this
test is as follows:
\begin{enumerate}
\item Initialize a state vector $\mathbf{x}$ having these components:

\begin{enumerate}
\item latitude, longitude, altitude in the l-frame
\item east velocity, north velocity, upward velocity in the l-frame
\item pitch, roll, heading in the a-frame
\item rotation rates about the pitch, roll, and yaw axes of the aircraft
\item acceleration in the lateral, longitudinal, and normal direction relative
to the aircraft reference frame.
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item store the measured rotations and accelerations in the last 6 components
of the state vector
\item via the function STMFV, calculated the time derivative of the state
vector. In the case of the attitude angles, this is done by calculating
the derivative of the transformation matrix from the a-frame to the
l-frame and then using the definition of components of that matrix
to find the derivative of the attitude angles.
\item use that derivative vector to increment the state vector
\item compensate for possible wrap-around of the heading a 0 and 360 deg
so that values stay within that range.
\item save the first 9 components of the state vector in a new data.frame
that represents an independent ``mechanization'' of the INU measurements.
These measurements should then be in reasonable agreement with the
INS solution.
\end{enumerate}
\end{enumerate}
<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' ', cache=TRUE>>=

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
SP$LAT[1] <- SV$LAT
SP$LON[1] <- SV$LON
SP$ALT[1] <- SV$GGALT
SP$VEW[1] <- SV$VEW
SP$VNS[1] <- SV$VNS
SP$VSPD[1] <- SV$VSPD
SP$PITCH[1] <- SV$PITCH
SP$ROLL[1] <- SV$ROLL
SP$THDG[1] <- SV$THDG
twoPi <- 2*pi

sv <- as.vector (SV, mode='numeric')
Rn <- SP$Rn[1]
Rm <- SP$Rm[1]
Grav <- SP$Grav[1]
stmf <- STMFV (sv)
## feedback coefficients for baro loop:
C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
wp3F <- 0;
hxF <- hxxF <- 0
hi3F <- SP$GGALT[1]
RK <- TRUE    ## use Runge-Kutta integration if true

for (i in 2:DL) {
  Rn <- SP$Rn[i]
  Rm <- SP$Rm[i]
  Grav <- SP$Grav[i]
  sv[10] <- SP$BPITCHR[i]
  sv[11] <- SP$BROLLR[i]
  sv[12] <- SP$BYAWR[i]
  sv[13] <- SP$BLATA[i]
  sv[14] <- SP$BLONGA[i]
  sv[15] <- SP$BNORMA[i]
  if (RK) {
    stmf1 <- STMFV (sv)
    sv1 <- sv + stmf1 * dt/2
    stmf2 <- STMFV (sv1)
    sv2 <- sv + stmf2 * dt/2
    stmf3 <- STMFV (sv2)
    sv3 <- sv + stmf3 * dt
    stmf4 <- STMFV (sv3)
    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
  } else {
    stmf <- STMFV (sv)
  }
  sv <- sv + stmf * dt
  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
  ## baro-loop
  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
  hxF <- hi3F - SP$GGALT[i]
  hxxF <- hxxF + hxF * dt
  sv[6] <- 0.5 * (sv[6] + wp3F)
  SP$LAT[i] <- sv[1]
  SP$LON[i] <- sv[2] 
  SP$ALT[i] <- sv[3]
  SP$VEW[i] <- sv[4]
  SP$VNS[i] <- sv[5]
  SP$VSPD[i] <- sv[6]
  SP$PITCH[i] <- sv[7] 
  SP$ROLL[i] <- sv[8] 
  SP$THDG[i] <- sv[9]
}
SP$LAT <- SP$LAT / Cradeg
SP$LON <- SP$LON / Cradeg
SP$PITCH <- SP$PITCH / Cradeg
SP$ROLL <- SP$ROLL / Cradeg
SP$THDG <- SP$THDG / Cradeg

@

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparison of INS-provided and integration-derived positions.', 'Comparison of INS-provided and integration-derived components of the aircraft velocity.', 'Comparison of INS-provided and integration-derived attitude angles.')>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
Data$LATX <- SP$LAT
Data$LONX <- SP$LON
Data$ALTX <- SP$ALT
r <- setRange (Data, 33000, 35500)
plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
plotWAC (Data[r, c('Time', 'LON', 'LONX')])
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
Data$VEWX <- SP$VEW
Data$VNSX <- SP$VNS
Data$VSPDX <- SP$VSPD
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
## find attitude angles from RaLM:
Data$PITCHX <- SP$PITCH
Data$ROLLX <- SP$ROLL
Data$THDGX <- SP$THDG
Data$DPITCH <- Data$PITCHX-Data$PITCH
Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
SP <- SPR    ## restore to state before integration

@

The result of that integration is shown in Figs.~1\textendash 3,
with comparisons to the INS-produced solutions. There are some differences,
but they are mostly understandable and could be corrected. For example,
the attitude angles show differences in sine waves during the circles
flown during this time segment and suggest a timing error that causes
one signal to be delayed relative to the comparable signal. The INS-produced
solution for altitude has a baro-loop applied to keep the altitude
near the pressure altitude, and that is not applied in this solution
so the vertical wind and position show large drifts. Perhaps the one
aspect that is troublesome is that in VNS and consequently in latitude.
Also, the data used here are the 25-Hz records, while the INS uses
a significantly higher data rate for its corresponding integration.
The remaining differences need further investigation, but the key
result from this part of the study is that as implemented above the
derivatives of components of the state vector are approximately correct
and integrate to reasonable values. The function providing those derivatives
is therefore a reasonable basis for the Kalman filter that follows.

\section*{The Kalman filter}

The preceding steps verify that at least an approximate calculation
of the derivatives of the state variables is available. On that basis,
an error-state Kalman filter can be developed. an error-state Kalman
filter can be developed. Before presenting that development, however,
it is necessary to discuss two aspects of the Kalman filter developed
here: 
\begin{enumerate}
\item Errors in the pitch and roll angles represent errors in the calculated
level position of the IRU. For a fixed orientation error, when the
aircraft turns, the errors in pitch and roll intermix, with for example
a pitch error during northbound flight becoming a roll error during
eastbound flight while the roll error becomes a pitch error. If a
Kalman filter is implemented with error terms for pitch and roll in
the a-frame, there will be large transient errors arising from course
changes that must be corrected via the Kalman filter, whereas if the
filter is implemented with errors in the l-frame the respective north
and east components of the attitude-angle errors remain approximately
constant. For this reason, it is preferable to implement the filter
using attitude-angle errors as they appear in the l-frame. The correction
terms developed by the Kalman filter must then be transformed back
to the a-frame before they are applied to the measurements of pitch
and roll. 
\item Conventional implementations of Kalman-filter updating use the measurements
of position and velocity from the GPS receiver as the external measurements
to which the INS measurements are compared. This works well for all
but the heading measurement. A heading error results in erroneous
resolution of measured accelerations into l-frame components and so
to errors in velocity, but the feedback of these errors to heading
is slow and noisy. Therefore, a more direct method of coupling GPS-derived
measurements to heading errors will be used by differentiating the
GPS-measured valocities to obtain independent measurements of acceleration
and then using these measured l-frame accelerations as additional
measurements to be compared to the INS solution. If there is an error
in heading, these accelerations will lead to a difference between
the GPS-derived direction of l-frame acceleration and the INS-derived
direction, and this can be considered a direct measurement of heading
error. Except in turns, the measured l-frame acceleration is too small
and noisy for this to be effective, but turns produce strong signals
and consequent constraints on the heading error.
\end{enumerate}
The Kalman filter is then constructed as follows:
\begin{enumerate}
\item The first step is to initialize an error-state-vector $\delta\mathbf{x}$
from initial measurements of the differences between the INS and GPS
values of position, velocity and acceleration. Other errors are unknown
at the start of the integration and so will be initialized as zero.
\item The covariance matrix characterizing the errors in the error-state-vector
is also needed. This is here initialized to have rather large components
because it is expected that the GPS measurements will have much lower
unceertainty than these INS-provided components. $\mathbf{V}$ is
initialized as a 15x15 diagonal matrix where the diagonal elements
are the squares of these values: \{2000/$R_{m}$, 2000/($R_{n}$cos$\Phi$),
500, 2, 2, 2, 0.3$^{\circ}$, 0.3$^{\circ}$, 1$^{\circ}$, 0.005$^{\circ}s^{-1}$,
0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.0005, 0.0005, 0.0005\}.
All entries are in SI units except those labeled as $^{\circ}$, in
which case the values are converted to radians before use. The variables
$R_{m}$ and $R_{n}$ are appropriate radii of the Earth. (See the
code) 
\item The function STMFV() was verified above and so provides at least an
approximate calculation of the derivatives of the state vector. For
an error-state Kalman filter, the propagation of the error state can
be found from the Jacobian of that function of the state vector, so
the state transition matrix is the sum of that Jacobian (multiplied
by the time step) and the 15-element diagonal matrix:\\
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}
\item The noise-covariance matrix $\mathbf{Q}$ represents the noise in
the solution. This is initialized as indicated in the code, via function
GCF.
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are known, the covariance matrix
can be updated via\\
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]
\item The Kalman gain is then given by\\
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]
where $\mathbf{H}$ is a 15X9 diagonal matrix representing how the
nine measured differences (GPS-INS) correspond to the error-state
vector. $\mathbf{R}$ is the measurement-noise-covariance matrix representing
the GPS noise, a 9x9 matrix having diagonal elements that are the
squares of these components: \{50/$R_{m}$, 50/($R_{n}\cos\Phi$,
100, 0.1, 0.1, 0.1, 0.001, 0.001, 0.001\}. The effect of measured
accelerations is more complex. The l-frame errors in acceleration,
transformed to the a-frame, correspond directly to the measured accelerations
from the INU (BLATA, BLONGA, BNORMA), so appropriate coupling is to
include the appropriate direction-cosine transformation matrix as
the coupling between the GPS measurements and the IRU-provided accelerations.
This requires that $\mathbf{H}$ contain components in the submatrix
$\mathbf{H}_{7-9,13-15}$ that are $\mathbf{R}_{l}^{a}$ as defined
previously. 
\item Define \textbf{$\delta\mathbf{z}$ }as the set of nine measurements
consisting of the differences between GPS and INS positions, velocities
and accelerations. The error-state vector is then further updated
as follows:\\
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]
\item Finally, the covariance matrix is updated further according to\\
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]
\end{enumerate}
To apply these equations, it is not necessary to use a high-rate file
and update at high rate, because it is expected that the errors vary
slowly. Turns and other maneuvers can introduce spurious effects if
time delays are not adjusted well. For these reasons, a 1-Hz data
file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles as well as
the rotation rates and accelerations will be smoothed before applying
the Kalman filter. DEEPWAVE flight 16 was selected, and the measurements
were filtered with 11-s smoothing of accelerations and 301-s smoothing
of measured velocity components and attitude angles.

<<new-data, include=TRUE, echo=FALSE>>=

Flight <- "16" 			
Project = "DW"     		
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
D1 <- getNetCDF (fname, VarList)
## remove heading adjustment as added during initial processing
Z <- data.frame(getAttributes(D1$THDG, .print=FALSE))
if ('CalibrationCoefficients' %in% names(Z)) {
  THDGoffset <- Z$CalibrationCoefficients[1]
} else {
  THDGoffset <- 0
}
D1$THDG <- (D1$THDG - THDGoffset) %% 360
DL <- nrow(D1)
## adjustments:
# D1$BYAWR <- D1$BYAWR - 0.005
# D1$BROLLR <- D1$BROLLR + 0.0005
# D1$BPITCHR <- D1$BPITCHR + 0.0005
# D1$BNORMA <- D1$BNORMA*1.005 - 0.015
# D1$BLONGA <- D1$BLONGA * 0.96
# D1$BLATA <- D1$BLATA * 1.1
s <- -120
si <- 0
Rate <- 1
SHIFT <- FALSE
SHIFT <- TRUE
if (SHIFT) {
  D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)
  D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
  # Data$BLONGA <- ShiftInTime (Data$BLONGA, Rate, s-80)
  # Data$BLATA <- ShiftInTime (Data$BLATA, Rate, s-80)
  # Data$BNORMA <- ShiftInTime (Data$BNORMA, Rate, s-80)
}

dt <- 1    ## this is a 1-Hz file
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
## the following is commented because the centripetal effect is already included in 'Gravity()'
# Re <- StandardConstant ('Re')
# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2 + D1$GGALT)
#interpolate if necessary: otherwise later filters fail
MaxGap <- 1000
D1$GGVNS <- ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
D1$GGVEW <- ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
D1$GGVSPD <- ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
D1$VNS <- vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
D1$VEW <- vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
D1$VSPD <- vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
## smooth the measurements when determining derivatives
.span <- 11    
## The following are accelerations determined from derivatives of the GPS velocities.
## These should match the measured accelerations after transformation to the l-frame
## and application of the rotation correction:
D1$vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
D1$vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
D1$vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
## transform to the a-frame for comparison to the IRU:
G <- D1$Grav
VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection (D1, VL)
AA <- XformLA (D1, LA, .inverse=TRUE)
AA[,3] <- AA[,3] - G
fa1 <- lm(D1$BLONGA ~ AA[, 1])
fa2 <- lm(D1$BLATA ~ AA[, 2])
fa3 <- lm(D1$BNORMA ~ AA[, 3])
AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame 
AL <- XformLA (D1, AB)                                    #l-frame
## now corrected for angular effects
## See Noureldin et al, 2013, Eq. (5.55)
AL <- AL + RotationCorrection (D1, VL)  ##### check this sign and prev call above
  
## the resulting l-frame accelerations
D1$LACCX <- AL[, 1]
D1$LACCY <- AL[, 2]
D1$LACCZ <- AL[, 3] + G
D1$LACCZ <- -D1$LACCZ
  
## smooth to match GPS-velocity derivatives
D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
.span <- 301
SMOOTH <- FALSE
if (SMOOTH) {
  vns <- signal::sgolayfilt (vns, 3, .span)
  vew <- signal::sgolayfilt (vew, 3, .span)
  vspd <- signal::sgolayfilt (vspd, 3, .span)
  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)

  D1$VNSF <- vns
  D1$VEWF <- vew
  D1$VSPDF <- vspd
  D1$GGVNSF <- ggvns
  D1$GGVEWF <- ggvew
  D1$GGVSPDF <- ggvspd
  D1$PITCHF <- pitch
  D1$ROLLF <- roll
  D1$THDGF <- thdg
}

## get the pitch and roll in the l-frame:
.thdg <- D1$THDG * Cradeg
D1$PITCHL <- D1$PITCH * cos (.thdg) - D1$ROLL * sin (.thdg)
D1$ROLLL <-  D1$PITCH * sin (.thdg) + D1$ROLL * cos (.thdg)

fm1 <- lm (D1$vedot ~ D1$LACCX)
fm2 <- lm (D1$vndot ~ D1$LACCY)
fm3 <- lm (D1$vudot ~ D1$LACCZ)

@

As a check on the uncertainty associated with the accelerometers,
the GPS measurements of velocity components were differentiated and
the resulting accelerations transformed to the a-frame and compared
to the measured accelerations from the IRU (with correction for the
Earth's rotation and the motion of the l-frame relative to an inertial
frame). For the longitudinal acceleration (along the aircraft axis),
the linear regression of the measured acceleration vs the GPS-derived
acceleration had offset \Sexpr{round(coef(fa1)[1], 4)} and slope
\Sexpr{round(coef(fa1)[2], 4)}., with a residual standard error of
\Sexpr{round(summary(fa1)$sigma, 4)}\,m\,s$^{-2}$. For the normal
component of acceleration, the corresponding values are respectively
\Sexpr{round(coef(fa3)[1], 4)}, \Sexpr{round(coef(fa3)[2], 4)}.,
and \Sexpr{round(summary(fa3)$sigma, 4)}\,m\,s$^{-2}$. These then
can be considered calibrations for the accelerometers as well as indications
of their uncertainty. \footnote{The lateral accelerations were too noisy for a similar calibration
because lateral accelerations are usually small and short-term except
during periods with significant slip, which were not present on this
flight.}

The differentiated measurements of velocity components from the GPS
can be considered as additional measurements corresponding to the
measured accelerations. This is discussed further in the following
sections.

\subsection*{Detecting the error in heading}

Most of the components of the state vector have good feedback from
GPS-derived measurements, but an exception is the measurement of heading.
For position and velocity, there is direct correspondence between
INS- and GPS-derived measurements. For pitch and roll, there is strong
coupling to errors in the eastward and northward components of aircraft
velocity. However, the coupling of INS-measured heading to GPS observations
is not a case of strong coupling (to which the Schuler oscillation
applies), and it is more difficult to update via measurements from
the GPS receiver. As specified above, the differentiated GPS velocities
provide an l-frame measurement of acceleration, and these can be transformed
back to the a-frame to provide measurements that correspond to BLATA,
BLONGA, and BNORMA. However, a difference in a-frame accelerations
from the two sources can arise not only from errors in the measured
accelerations but also (and more likely) from an error in heading,
which would cause incorrect translation between l-frame and a-frame
components. The source of coupling between GPS-derived measurements
and heading is via the aircraft-velocity components, because an error
in heading causes the IRU-measured accelerations to be resolved into
the \emph{l-}frame incorrectly and so introduces errors in the aircraft-velocity
components that can be detected via comparison to GPS-provided velocity
components. Unfortunately, in most cases the measured accelerations
are small, resulting in large uncertainties in any correction term
except during turns. There are three possible approaches, all of which
have been tried in this study:
\begin{enumerate}
\item The Kalman-filter structure as described above will use the errors
in velocity to correct the state vector. Via the derivative coefficient
matrix, the horizontal-velocity errors are dependent on errors in
horizontal-acceleration as well as on attitude-angle errors, esp.~via
strong coupling to the errors in roll and pitch. The coupling to heading
is typically an order of magnitude weaker. Without special attention,
the coupling to heading potentially can be obscured by the other sensitivities,
through which the errors in velocity can be attributed to error-state
components in horizontal acceleration and in roll and pitch. In turn,
an error in heading is dependent mostly on errors in the gyro rotation
rates. These sensitivities make it difficult to obtain a reliable
adjustment of heading in the standard approach, although an estimate
can be obtained.
\item The \emph{l-}frame accelerations measured by differentiating the GPS-derived
horizontal velocity components can be used as additional components
of the observation vector, complementing the position and velocity
measurements from GPS. These accelerations can then be used as independent
measurements of acceleration. While this provides some additional
adjustable parameters for the filter associated with the covariances
of the GPS-derived accelerations, the errors in acceleration can still
be attributed to errors in the measured accelerations. This seems
to add little to the sensitivity, and indeed in tests this led to
changes in pitch and roll corrections that appeared to produce degraded
results.
\item A more direct approach is to compare the measured horizontal-acceleration
vector obtained by transforming the measured \emph{a-}frame accelerations
to the \emph{l-}frame and comparing their horizontal direction to
the direction of acceleration determined by differentiating the GPS-measured
components of horizontal velocity. The difference is a measure of
the heading error and can be used as a component of the observation
vector $\mathbf{Z}$ with which to update the heading. That is, the
error in heading is measured to be\\
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}
where $a_{e}^{(l)}$ and $a_{n}^{(l)}$ are the \emph{l-}frame accelerations
obtained by transforming the IRU-measured accelerations from the \emph{a-}frame
to the \emph{l-}frame and $\dot{v}_{e}$ and $\dot{v}_{n}$ are the
eastward and northward components of the acceleration obtained from
the time-derivatives of the GPS-measured eastward and northward velocity
components $v_{e}$ and $v_{n}$. The assumption made when using this
formula is that the errors in the INS-produced accelerations in the
\emph{l-}frame arise from the heading error with negligible contribution
from the errors in the accelerometers. If this is the case, it would
be possible to base the heading correction on this formula alone,
but the more general case needs to consider how this might be influenced
by errors in accelerations, so it is preferable to incorporate this
into the Kalman filter and allow for the possibility that measured
accelerations need to be adjusted.
\end{enumerate}
The third approach leads to noisy estimates of the correction $\delta\psi$
except when accelerations are significant. Because significant accelerations
occur mostly in turns when both angles in (\ref{eq:Hcorr}) are changing
rapidly, it is very important to have correct relative timing between
the INS measurement of heading and the GPS measurement of velocity.\footnote{As an illustration, a 50-ms delay in heading during a 3-min turn causes
a shift in heading relative to the correct time of 0.1$^{\circ}$,
so adjustment to at least this uncertainty is desirable. } The GPS measurements are assigned correct times by the GPS receiver
and represent a standard clock against which to compare other measurements.\footnote{It appears that the relative timing between the IRU and the GPS can
drift enough during some flights to introduce significant errors.} If the GPS-vs-INS time shift is not removed, a bias will be introduced
into the heading correction that varies with turn direction. Therefore
the following procedure is followed to remove this time shift:
\begin{enumerate}
\item Differentiate the GPS-provided measurements to obtain $\dot{v}_{e}$
and $\dot{v}_{n}$.
\item Transform the unshifted body accelerations to the \emph{l-}frame,
with rotation corrections, to obtain the eastward and northward components
of acceleration ($a_{e}^{(l)}$, $a_{n}^{(l)}$) in the local-level
frame. 
\item Find the heading correction for unshifted measurements by calculating
$\delta\psi$ from (\ref{eq:Hcorr}).
\item Calculate the running-standard-deviation of $\delta\psi$ spanning
30 seconds. Select the subset of $\delta\psi$ for which that standard
deviation is less than 0.2$^{\circ}$.
\item Fit the subset to find the slope $b$ in the relationship $\delta\psi=a+b\thinspace\tan\phi$
where $\phi$ is the roll angle. The rate of turn $R$ is related
to the roll angle $\phi$ according to the relationship $R=g\thinspace\tan\phi/V$
where $V$ is the airspeed, so $\tan\phi=RV/g$ and $\delta\psi=a+bRV/g$.
A time delay of $\delta t$ produces a heading error of $-R\delta t$,
so $-R\delta t=a+bRV/g$ and the time shift can be estimated from\\
\begin{equation}
\delta t=-b\frac{V}{g}\label{eq:deltaT}
\end{equation}
For example, for DEEPWAVE flight 16, $b=0.2146^{\circ}$s$^{-1}$
= 0.003745\,rad\,s$^{-1}$ and $V\simeq240$\,m\,s$^{-1}$, so
(with g=9.8\,m\,s$^{-2}$) $\delta t=$-0.092~s. The negative sign
indicates that the INS-derived measurement of heading should be shifted
forward in time by 92\,ms relative to the GPS-derived measurements
of aircraft velocity. The standard error from the fit indicates that
this shift was determined with an uncertainty of about 3\,ms, so
this is a very sensitive method for determining the time shift.
\item Apply this time shift to the measurements of heading. For a file containing
measurements at 1~Hz, this requires creating an interpolated high-rate
vector of measurements, shifting that vector, and then extracting
a shifted 1-Hz vector from the shifted measurements. The Ranadu function
ShiftInTime() accomplishes this by interpolating to a 125-Hz variable.
The result can be checked by repeating step 5 using the shifted measurements;
for this case, the deduced shift needed for the shifted time series
was only 1~ms. 
\end{enumerate}
After an appropriate time shift is introduced, (\ref{eq:Hcorr}) is
an appropriate measurement of heading to include in the matrix $\mathbf{H}$,
where the appropriate components associated the heading error (component
9 in the error-state vector) with components 7 and 8 in the measurement
vector $\delta\mathbf{z}$. Specifically, column 9 in $\mathbf{H}$
should have contributions from rows 7 and 8. Formulated in this way,
the dependence is complex and non-linear, so it is simpler to add
a 10th component to the measurement vector with value given by \ref{eq:Hcorr})
and associate that directly (with coefficient 1 after appropriate
conversion from radians to degrees) with column 9 of the information
matrix $\mathbf{H}$, which then must have 10 rows and 15 columns.

Because typical horizontal accelerations in the l-frame are small,
this estimate of the heading error is too noisy to be useful except
in turns where the horizontal accelerations are significant, often
about 3~m/s$^{2}$. In normal straight flight, the standard deviation
in the estimate obtained from (\ref{eq:Hcorr}) is around 15$^{\circ}$,
but in turns this standard deviation reduces to typically about 0.03$^{\circ}$.
This has two important consequences. First, flights without turns
or other sources of horizontal acceleration will lack the information
for adjusting the heading. so in flights where this is important regular
turns should be part of the flight plans. Second, when the GPS-based
estimate of the heading error is used, an appropriate variance should
be assigned to prevent excessive noise from affecting the result from
the Kalman filter. 

<<Kalman-setup, include=TRUE, echo=FALSE>>=

## initial values of the state vector and error-state vector:
SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
## also need the corresponding noise vector:
tau <- 60
GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data record
  gcf <- vector('numeric', length=15)
  gcf[1] <- 30 / sp$Rm
  gcf[2] <- 30 / (sp$Rn * cos (sv$LAT))
  gcf[3] <- 150
  gcf[4:6] <- 0.3    ## 0.3
  gcf[7:8] <- 0.005*Cradeg  ## 0.005
  gcf[9] <- 0.015*Cradeg    ## 0.015
  gcf[10:11] <- 0.003*Cradeg    ## 0.015
  gcf[12] <- 0.003*Cradeg       ## 0.015
  gcf[13:15] <- 0.00002
  # gcf <- as.vector(gcf) * sqrt(2/tau)
  return (gcf)
}
gcf <- as.numeric (GCF (SV, D1[1, ]))

## The measurement model: calculate the measurements of acceleration from the GPS to add to the measurement vector
GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
dim(GAEL) <- c(DL, 3)
## transform to the a-frame
GAE <- XformLA (D1, GAEL, .inverse=TRUE)
DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS, VSPD-GGVSPD))
# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later
## The last three components provide direct feedback to measured acceleration
## in the a-frame but also provide feedback to heading, as developed below
# dim(DZ) <- c(DL, 9)
# dim(DZ) <- c(DL, 6)
# DZ[,1:2] <- DZ[, 1:2] * Cradeg
## now add the pseudo-measurement of heading error found from the accelerations:
D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the std dev
## add the heading correction to the measurement vector
DZ <- c(as.vector(DZ), D1$deltaPsi)
dim(DZ) <- c(DL, 7)
DZ[ ,1:2] <- DZ[ ,1:2] * Cradeg

## The observation matrix: (the first six and last three components of the state error 
## vector are observable, the latter requiring transformation from l-frame to a-frame)
## components 7-9 are connected to IRU-measured rotation rates via the transformation matrix l->a,
## so matrix H must vary with aircraft attitude angles. This is addressed by the GAEL->GAE transform.
# H <- diag(1, nrow=10, ncol=15)
# for (k in 7:9) {
#   H[k,k] <- 0
#   H[k,k+6] <- 1
# }
# H[10,9] <- 1
H <- diag(1, nrow=7, ncol=15)
H[7,7] <- 0
H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component 9


## at any time step, assume the measurements are contaminated by noise:
RCV <- matrix (rep(0,100), ncol=10)
RCV <- matrix (rep(0,49), ncol=7)
RCV[1,1] <- (10/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (10/(D1$Rn[1]*cos(SV$LAT)))^2
RCV[3,3] <- 100^2
RCV[4,4] <- 0.3^2            ## ve
RCV[5,5] <- 0.3^2
RCV[6,6] <- 0.3^2
# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measurement.
# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an error in heading, not
# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration is used for that.
# RCV[10,10] <- D1$sdPsi[1]^2
# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
# # RCV[10, 10] <- 1000  ## suppress effect
RCV[7,7] <- 1000  ## but update this each time step

## initialize covariance matrix with generous variances
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)


@

<<Kalman-loop, include=TRUE, echo=FALSE, eval=TRUE, fig.cap=' '>>=

Data <- D1
DL <- nrow (Data)
  # find PITCHL, ROLLL in the l-frame
  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal to AC
  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
  # UVL <- XformLA (Data, UV)
  # PitchL <- asin (-UVL[,2])
  # RollL <- asin (UVL[,1])
  #   .hdg <- Data$THDG*Cradeg
  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg

## note: if using l-frame PITCH and ROLL; STMFV must account for this

NSTEP <- 5      ## update time
SVEF <- array(dim=c(DL/NSTEP, 15))
CVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
                    ## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[1, 1:6]
## pitch and roll errors are going to be those in the l-frame; leave a-frame for now
SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions here
## start with zero for gyro and accelerometer errors
SVEF[1, ] <- SVE
CVEF[1, ] <- diag (CV)
# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
pctL <- 0
for (i in seq(2*NSTEP, DL, by=NSTEP)) {
  pct <- as.integer(100*i/DL)
  if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d', pct));pctL <- pct}
  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- Data$Rn[i]
  Rm <- Data$Rm[i]
  Grav <- Data$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
  ## modify to include this?
## modify this to include decaying error terms for the measurements:
# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new error-state vector:
  ## the pitch and roll error derivatives are now those in the a-frame, but
  ##   the pitch/roll error state is in the l-frame. Save the l-frame error state:
#   SVEL <- SVEA <- SVE
#   ## Transform l-frame pitch/roll error state to a-frame
#   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
#   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
#   ## apply derivatives to get a-frame change
#   SVEA <- dcm %*% SVEA
#   ## transform back to l-frame
#   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
#   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
  
  SVE <- dcm %*% SVE    ## take time step in error-state vector

  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  ## the Kalman gain:
  if (is.na(Data$sdPsi[i]) || (sqrt(Data$LACCX[i]^2+Data$LACCY[i]^2) < 0.1)) {
    H[7,9] <- 0
    # DZ[i, 7] <- NA
  } else {
    H[7,9] <- 0.0
    RCV[7, 7] <- Data$sdPsi[i]^2
  }
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
  CVEF[i/NSTEP, ] <- diag(CV)
}

## interpolate the results over the full data.frame:
IntFilter <- function (X, inRate, outRate) {
  if (inRate == outRate) {return (X)}
  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
  x <- 0:(length(X)-1)
  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
  T <- A$y
  T <- signal::filter(signal::sgolay(4,75),T)
  ## now shift to match 25-Hz:
  n <- as.integer (ratio / 2)
  NL = length(T)
  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
  return (T)
}
Cor <- vector('numeric', DL*15)
dim (Cor) <- c(DL, 15)
VCor <- vector ('numeric', DL*15)
dim (VCor) <- c(DL, 15)
X <- SVEF[, 1]
for (j in 1:15) {
  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
}
Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
Data$ALTKF <- Data$ALT - Cor[, 3]
Data$VEWKF <- Data$VEW - Cor[, 4]
Data$VNSKF <- Data$VNS - Cor[, 5]
Data$VSPDKF <- Data$VSPD - Cor[, 6]
Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
Data$BLATAKF <- Data$BLATA - Cor[, 13]
Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
Data$BNORMAKF <- Data$BNORMA - Cor[, 15]

Data$DLAT <- Data$LATKF-Data$GGLAT
Data$CLAT <- -Cor[, 1] / Cradeg
Data$DLON <- Data$LONKF-Data$GGLON
Data$CLON <- -Cor[, 2] / Cradeg
Data$DALT <- Data$ALTKF-Data$GGALT
Data$CALT <- -Cor[, 3]
Data$DVEW <- Data$VEWKF-Data$GGVEW
Data$CVEW <- -Cor[, 4]
Data$DVNS <- Data$VNSKF-Data$GGVNS
Data$CVNS <- -Cor[, 5]
Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
Data$CVSPD <- -Cor[, 6]
Data$CPITCH <- -Cor[, 7] / Cradeg
Data$CROLL <- -Cor[, 8] / Cradeg
Data$CTHDG <- -Cor[, 9] / Cradeg
KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.",
                    "Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines show the corrections applied to the original INS values by the Kalman filter.",
                      "Pitch Correction from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch (PC, red line)",
                      "Roll Correction from the Kalman filter (CROLL) and from Ranadu::CorrectPitch (RC, red line)",
                      "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")

@

\section*{Results}

There are several tests that the corrected values should pass:
\begin{enumerate}
\item Because the GPS measurements of position and aircraft velocity have
low uncertainty, the KF values should match these in long-term average,
perhaps with some high-frequency components not present in the GPS-provided
measurements.
\item The pitch-correction algorithm developed in the Tech Note should give
results in reasonable agreement with the KF values of pitch and roll.
\item The heading-correction algorithm should also produce results consistent
with the KF results.
\end{enumerate}
<<plot-Kalman, include=TRUE, echo=FALSE, fig.cap=c("Comparison of the KF, GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.", "Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines show the corrections applied to the original INS values by the Kalman filter.", "Pitch Correction from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch (PC, red line)", "Roll Correction from the Kalman filter (CROLL) and from Ranadu::CorrectPitch (RC, red line)", "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVSPD, CVSPD)), ylim=c(-2,2))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
PC <- CorrectPitch(Data, .span=601)
Data$PC <- -PC[, 1]
Data$RC <- -PC[, 2]
## translate pitch/roll corrections to the a-frame:
.hdg <- Data$THDG * Cradeg
C7 <- SmoothInterp (Cor[, 7], .Length=181)
C8 <- SmoothInterp (Cor[, 8], .Length=181)
# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
# Data$CPITCH <- CPITCH / Cradeg
# Data$CROLL <- CROLL / Cradeg
Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
Data$CTHDG <- SmoothInterp (Data$CTHDG, .Length=181)
Data$HC <- -CorrectHeading (Data, .plotfile='./HCPlot.pdf')
r <- setRange (Data, 70000, 123000)
plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH CORRECTION',' [',degree,']')), 
        ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
ival <- abs(Data$ROLL) > 4
Data$CPITCH[ival] <- NA
Data$PC[ival] <- NA
lineWAC(Data$Time[r], Data$CPITCH[r], lwd=3, col='blue')
lineWAC(Data$Time[r], Data$PC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), 
      ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
      ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
Data$CROLL[ival] <- NA
Data$RC[ival] <- NA
lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
abline(h=0, col='darkorange', lty=2)
plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylim=c(-0.4,0.4), lwd=0.7, legend.position='topright')
HE <- VCor[,9]
HE[HE < 0.0025] <- 0.0025
HE <- sqrt(HE)
# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
iv <- HE > 0.051
CCTHDG <- Data$CTHDG
CCTHDG[iv] <- NA
lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r]^2, spar=1.25)
Data$HCS <- predict(SS, as.numeric(Data$Time))$y
lineWAC(Data$Time[r], Data$HCS[r], col='red')


@

\clearpage

\begin{center}
\textsf{\textcolor{blue}{\textendash{} End of Memo \textendash{}}}
\par\end{center}

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow:}}} & Workflow\Sexpr{thisFileName}.pdf\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & https://github.com/WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}


\end{document}
