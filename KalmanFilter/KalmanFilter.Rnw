%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lxlist}}
\newcommand{\cc}[1]{\begin{lxlist}{Attachments:00}
\item [cc:] {#1}
\end{lxlist}}
\newcommand{\attach}[1]{\begin{lxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\usepackage{babel}
\begin{document}
\EOLmemo 

\global\addressee={Wind Uncertainty TN file}  

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & A Kalman filter to apply corrections to the wind measurements\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
# note that fig.pos="center" gave errors, changed to fig.align
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
thisFileName <- "KalmanFilter"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)
source ('~/RStudio/Ranadu/R/theme_WAC.R')
setwd ('~/RStudio/Ranadu/KalmanFilter')
Directory <- DataDirectory ()
Flight <- "rf15HR" 				# XXX change this
Project = "DWIRU"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
# ReloadData <- TRUE
SaveRData <- sprintf("%s.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  save (Data, file=SaveRData)
} else {
  load (file=SaveRData)
}

@

\section{Introduction and scope}

The intent of this study is to evaluate the errors present in the
measurements of attitude angles from the IRU on the NSF/NCAR~GV by
means of a Kalman filter applied to the difference between measurements
from a GPS and corresponding measurements from the IRU. The redundant
measurements are those of position and velocity,\footnote{Because GPS measurements of velocity have low uncertainty, those measurements
could be differentiated and, after transformation to the aircraft
reference frame, used as error measurements for the measured accelerations.} for which the GPS measurements are clearly superior especially at
low rate, so a necessary result will be that the corrected measurements
should be quite close to those from the GPS. The advantage of this
analysis, though, is that the coupling between errors in the attitude
angles and those in velocity makes it possible to evaluate the errors
in the attitude angles.

Before describing the implementation of the filter, it is useful to
explain the basic concept underlying a Kalman filter. A Kalman filter
provides a means of updating a sequence of state vectors (consisting,
in the present case, of INS measurements of position, velocity, and
attitude angles) by comparison to an independent set of measurements
(e.g., GPS-derived measurements of position and velocity). The updated
state vector obtained by this process consists of an appropriately
weighted combination of the state vector projected forward using normal
INS ``mechanization'' (i.e., determining the next step by using
the measured acceleration and rotation from the IRU) and the independent
measurements from GPS. Because errors in the state vector are coupled,
the update procedure can estimate errors in the attitude angles as
well as the components of the state vector that are measured directly
by the GPS. This is the primary reason for using a Kalman filter to
improve the wind measurements: Although the measurements of position
and velocity that result should differ little from those provided
by the GPS, the corrections to the attitude angles (pitch, roll, and
heading) can be estimated even though there is no direct measurement
of these except from the INS.

The weighting of the projected-forward state and new measurements
from GPS depends on obtaining estimates of the covariance matrix describing
the state vector as well as estimates of the noise sources contaminating
the measurements from both the GPS and the IRU-provided accelerations
and rotations. With proper weighting, the result should combine the
good high-frequency response of the INS with the good long-term stability
of the GPS. The covariance matrix characterizing the state vector
is updated as the filter is applied, but appropriate weighting depends
on reasonable estimation of the other error terms.

The operation of the filter depends on sequential use of a set of
matrices, so it is useful to define those as follows, where the variable
names following the symbols are the R variable names used in the following
code:
\begin{lyxlist}{00.00.0000}
\item [{$\delta\mathbf{x}_{k}$~{[}SVE{]}}] The error-state vector at
time index $k$. In the present case, this consists of these 15 components:
estimated errors in position, aircraft velocity, aircraft attitude,
IRU-measured rotation rate, and IRU-measured accelerations.
\item [{$\mathbf{T}_{k|k-1}$~{[}dcm{]}}] The 15x15 state transformation
matrix describing INS mechanism for the change from time $k-1$ to
time $k$. Then $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
where $\mathbf{T}$ combines the unit diagonal matrix with the time
step multiplied by the derivative matrix describing the state transformation.
As applied to the state vector, this state transformation matrix would
involve the derivatives used for normal INS mechanization to get how
the state vector advances, and so would duplicate the action of the
internal INS data processing. As interpreted for an error-state Kalman
filter, the matrix $\mathbf{T}$ is obtained by calculating the Jacobian
of that state-transition function as a function of the error-state
components. 
\item [{$\mathbf{V}$~{[}CV{]}}] The covariance matrix that applies to
the state vector $\delta\mathbf{x}$, a 15x15 matrix
\item [{$\mathbf{K}$~{[}K{]}}] The Kalman-gain matrix representing how
the error-state vector is updated using the current error state and
the new GPS measurements.
\item [{$\delta\mathbf{z}$~{[}DZ{]}}] The 9-component measured differences
between the INS and GPS measurements of position, velocity and acceleration.
The latter three components are obtained by differentiating the GPS-provided
velocity components. This differs from most conventional approaches
but proves useful for contraining the measurement of heading.
\item [{$\mathbf{H}$~{[}H{]}}] The 15x9-component matrix representing
how the measured differences $\delta\mathbf{z}$ correspond to the
state vector. 
\item [{$\mathbf{Q},\,\mathbf{R}$~{[}Q,~R{]}}] Matrices representing
respectively the anticipated noise contributions affecting the error-state
vector (15x15) and the measurements from the GPS (9x9).
\end{lyxlist}
The approach taken here will be to filter the error-state vector that
represents the difference between the best-estimate measurements and
those originally provided by the INS. The INS integration does not
need to be duplicated here to obtain the reference solution because
that is already available. However, the Kalman filter does need the
``state transition matrix'' that represents the forward integration,
so the first step in this analysis is to obtain such a matrix and
validate results using it against the available INS solution. The
Jacobian of that state-transition function then provides the matrix
$\mathbf{T}$ later used in this filter.

\section{Some component functions}

Some of the operations involved in that ``mechanization'' to replicate
the operation of the INS are contained in the following functions,
with code as in the associated R ``chunks.''
\begin{enumerate}
\item \emph{\uline{XfLArV()}}, a function of the current state vector,
provides a 3x3 matrix that transforms a vector from the a-frame (the
aircraft reference frame) to the l-frame, the local-level frame (with
\{x,y,z\} coordinates toward the East, North, and upward directions). 
\item \emph{\uline{RotationCorrection()}} calculates the correction to
accelerations needed to account for the rotation of the Earth and
of the l-frame relative to an inertial frame. This function provides
corrections to subtract from transformed accelerations before using
them in the l-frame.
\item \emph{\uline{STMFV()}} calculates the 15-component derivative of
the state vector given the state vector and the measurements from
the INU. This function is then used in the R function numDeriv::jacobian
to find the Jacobian needed later for the state transformation matrix
used to construct the Kalman filter.
\end{enumerate}
<<utility-functions, include=TRUE, echo=FALSE>>=

XfLArV <- function (data) {   ## XfLA but using input in radians and single row
  # data must contain PITCH, ROLL, HEADING as components [7:9]
  cosphi <- cos (data[8])
  sinphi <- sin (data[8])
  costheta <- cos (data[7])
  sintheta <- sin (data[7])
  cospsi <- cos (data[9])
  sinpsi <- sin (data[9])
  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-sinpsi*sintheta*cosphi,
           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinphi-cospsi*sintheta*cosphi,
           -sintheta, costheta*sinphi, -costheta*cosphi)
  RblM <- aperm( array (Rbl, dim=c(3,3)))
  return (RblM)
}

# other-functions ---------------------------------------------------------

Cradeg <- pi/180
dt <- 1/25               ## working with 25-Hz file
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')
Ree <- 6378137
Ecc <- 0.08181919
## The next correction calculates the correction needed to account for the rotation
## of the Earth and of the l-frame (ENU frame). See Noureldin et al., 2013, 
## Eqs. 5.55--5.57. Subtract this from the transformed accelerations before using them.
RotationCorrection <- function (.data, .V) {
  Cradeg <- pi/180
  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
  DL <- nrow (.data)
  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
  lat <- .data$LAT * Cradeg
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  Ree <- 6378137
  Ecc <- 0.08181919
  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
  M23 <- .V[,2] / Rm
  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
  M32 <- -.V[,2] / Rm
  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
  return (C)
}

Gravity <- function (latitude, altitude=0.) {
  sl2 <- (sin (latitude * Cradeg))^2
  g <- 9.780327 * ((1. + 0.001931851 * sl2) / 
                     (1. - 0.006694380 * sl2)) - 3.086e-6 * altitude
  ## Somigliana formula 1980 GRS:
  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 * altitude^2
  return(g)
}

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
Re <- StandardConstant ('Re')
# The following is commented because it is already in the Somagliana equation
# Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
#   (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)

############# this function calculates the derivatives of the state vector ###########
STMFV <- function (sv, .aaframe='a') { 
  stmf <- vector('numeric', length=15)
  ## transform back to a-frame if necessary
  if (.aaframe == 'l') {  ## if pitch/roll are in l-frame, translate to a-frame
    svs7 <- sv[7]
    svs8 <- sv[8]
    sv[7] <- cos (sv[9]) * svs7 - sin (sv[9]) * svs8
    sv[8] <- sin (sv[9]) * svs7 + cos (sv[9]) * svs8
  }
  rlm <- XfLArV(sv)    
  omega <- as.vector (c(-sv[5] / Rm, 
                        OmegaE*cos(sv[1])+sv[4]/(Rn),
                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2], omega[1], 0), ncol=3)
  Oilb <- Oill %*% rlm
  ## find the derivative of the transformation matrix:
  ## (must recalculate SRM from measured rotation rates)
  SRR <- c(0, -sv[12], -sv[10],
           sv[12], 0, sv[11],
           sv[10], -sv[11], 0)
  SRM <- aperm( array (SRR, dim=c(3,3)))
  dRLA <- rlm %*% SRM - Oilb
  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
  Grav <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch and roll!
  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-frame
  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
  ## now correct for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  VL <- c(sv[4], sv[5], sv[6])
  C <- vector ('numeric', 3)
  lat <- sv[1]
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
  M23 <- VL[2] / Rm
  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
  M32 <- -VL[2] / Rm
  C[1] <- M12 * VL[2] + M13 * VL[3]
  C[2] <- M21 * VL[1] + M23 * VL[3]
  C[3] <- M31 * VL[1] + M32 * VL[2]
  AL <- as.vector (AL - C, mode='numeric')
  AL[3] <- AL[3] + Grav
  AL[3] <- -AL[3]
  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
            0, 0, 0, 0, 0, 0)
  ## return sv to original if necessary
  if (.aaframe == 'l') {
    sv[7] <- svs7
    sv[8] <- svs8
    stmf7 <- stmf[7]
    stmf[7] <- cos(sv[9])*stmf7 + sin(sv[9])*stmf[8]
    stmf[8] <- -sin(sv[9])*stmf7 + cos(sv[9])*stmf[8]
  }
  return (as.vector (stmf, mode='numeric'))
}

@

<<INS-data, include=TRUE, echo=FALSE>>=

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA, BNORMA, 
                              BPITCHR, BROLLR, BYAWR,
                              GGVEW, GGVNS, Grav))

## adjustments:
SP$BYAWR <- SP$BYAWR - 0.005
SP$BROLLR <- SP$BROLLR + 0.0005
SP$BPITCHR <- SP$BPITCHR + 0.0005
# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
# SP$BLONGA <- SP$BLONGA * 0.96
# SP$BLATA <- SP$BLATA * 1.1
SP$BPITCHR <- SP$BPITCHR * Cradeg
SP$BROLLR <- SP$BROLLR * Cradeg
SP$BYAWR <- SP$BYAWR * Cradeg

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
SPR <- SP   ## save what INS produced, as reference

@

\section{The integration steps}

The purpose of this section is to demonstrate that the calculated
derivatives of the INS-provided variables lead to a reasonable ``mechanization''
that approximately duplicates the original calculations from the INS.
It is not necessary or expected that this mechanization will duplicate
that from the INS with high precision because the INS has information
and high-rate data not available to this new calculation. However,
if the results are reasonably close to those from the INS then that
provides some evidence that the derivatives being calculated are reeasonably
close to the correct values. These derivatives will then be used in
the implementation of the Kalman filter, where the filter will adjust
to compensate for remaining errors in these derivatives. 

The procedure used to produce variables corresponding to position,
velocity, and attitude angles for this test is as follows:
\begin{enumerate}
\item Initialize a state vector $\mathbf{x}$ having these components:

\begin{enumerate}
\item latitude, longitude, altitude in the l-frame
\item east velocity, north velocity, upward velocity in the l-frame
\item pitch, roll, heading in the a-frame\footnote{With appropriate transformations these calculations of attitude angles
can be performed in the l-frame instead, and there are some advantages
because the l-frame values of errors in pitch and roll, respectively
representing southward and westward tilts of the inertial platform,
are not mixed together when the heading changes as they are in the
a-frame.}
\item rotation rates about the pitch, roll, and yaw axes of the aircraft
\item acceleration in the lateral, longitudinal, and normal direction relative
to the aircraft reference frame.
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item store the measured rotations and accelerations in the last 6 components
of the state vector
\item via the function STMFV, calculated the time derivative of the state
vector. In the case of the attitude angles, this is done by calculating
the derivative of the transformation matrix from the a-frame to the
l-frame and then using the definition of components of that matrix
to find the derivative of the attitude angles.
\item use that derivative vector to increment the state vector
\item compensate for possible wrap-around of the heading a 0 and 360 deg
so that values stay within that range.
\item save the first 9 components of the state vector in a new data.frame
that represents an independent ``mechanization'' of the INU measurements.
These measurements should then be in reasonable agreement with the
INS solution.
\end{enumerate}
\end{enumerate}
<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' ', cache=TRUE>>=

SV <- with(Data[1, ], data.frame(LAT, LON, GGALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
SP$LAT[1] <- SV$LAT
SP$LON[1] <- SV$LON
SP$ALT[1] <- SV$GGALT
SP$VEW[1] <- SV$VEW
SP$VNS[1] <- SV$VNS
SP$VSPD[1] <- SV$VSPD
SP$PITCH[1] <- SV$PITCH
SP$ROLL[1] <- SV$ROLL
SP$THDG[1] <- SV$THDG
twoPi <- 2*pi

sv <- as.vector (SV, mode='numeric')
Rn <- SP$Rn[1]
Rm <- SP$Rm[1]
Grav <- SP$Grav[1]
stmf <- STMFV (sv)
## feedback coefficients for baro loop:
C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
wp3F <- 0;
hxF <- hxxF <- 0
hi3F <- SP$GGALT[1]
RK <- TRUE    ## use Runge-Kutta integration if true

for (i in 2:DL) {
  Rn <- SP$Rn[i]
  Rm <- SP$Rm[i]
  Grav <- SP$Grav[i]
  sv[10] <- SP$BPITCHR[i]
  sv[11] <- SP$BROLLR[i]
  sv[12] <- SP$BYAWR[i]
  sv[13] <- SP$BLATA[i]
  sv[14] <- SP$BLONGA[i]
  sv[15] <- SP$BNORMA[i]
  if (RK) {
    stmf1 <- STMFV (sv)
    sv1 <- sv + stmf1 * dt/2
    stmf2 <- STMFV (sv1)
    sv2 <- sv + stmf2 * dt/2
    stmf3 <- STMFV (sv2)
    sv3 <- sv + stmf3 * dt
    stmf4 <- STMFV (sv3)
    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
  } else {
    stmf <- STMFV (sv)
  }
  sv <- sv + stmf * dt
  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
  ## baro-loop
  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
  hxF <- hi3F - SP$GGALT[i]
  hxxF <- hxxF + hxF * dt
  sv[6] <- 0.5 * (sv[6] + wp3F)
  SP$LAT[i] <- sv[1]
  SP$LON[i] <- sv[2] 
  SP$ALT[i] <- sv[3]
  SP$VEW[i] <- sv[4]
  SP$VNS[i] <- sv[5]
  SP$VSPD[i] <- sv[6]
  SP$PITCH[i] <- sv[7] 
  SP$ROLL[i] <- sv[8] 
  SP$THDG[i] <- sv[9]
}
SP$LAT <- SP$LAT / Cradeg
SP$LON <- SP$LON / Cradeg
SP$PITCH <- SP$PITCH / Cradeg
SP$ROLL <- SP$ROLL / Cradeg
SP$THDG <- SP$THDG / Cradeg

@

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=c('Comparison of INS-provided and integration-derived positions.', 'Comparison of INS-provided and integration-derived components of the aircraft velocity.', 'Comparison of INS-provided and integration-derived attitude angles.')>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
Data$LATX <- SP$LAT
Data$LONX <- SP$LON
Data$ALTX <- SP$ALT
r <- setRange (Data, 33000, 35500)
plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
plotWAC (Data[r, c('Time', 'LON', 'LONX')])
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
Data$VEWX <- SP$VEW
Data$VNSX <- SP$VNS
Data$VSPDX <- SP$VSPD
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'VEW', 'VEWX')], legend.position='topright')
plotWAC (Data[r, c('Time', 'VNS', 'VNSX')], legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
## find attitude angles from RaLM:
Data$PITCHX <- SP$PITCH
Data$ROLLX <- SP$ROLL
Data$THDGX <- SP$THDG
Data$DPITCH <- Data$PITCHX-Data$PITCH
Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[r, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
plotWAC(Data[r, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC(Data[r, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
SP <- SPR    ## restore to state before integration

@

The result of that integration is compared to the INS-produced solution
in Figs.~1\textendash 3. There are some differences, but they are
mostly understandable and could be corrected. For example, the attitude
angles show sine-wave differences during the circles flown during
this time segment and suggest a timing error that causes one signal
to be delayed relative to the comparable signal. The INS-produced
solution for altitude has a baro-loop applied to keep the altitude
near the pressure altitude, and that is not applied in this solution
so the vertical wind and position show large drifts. Perhaps the one
aspect that is troublesome is that in VNS and consequently in latitude.
Also, the data used here are the 25-Hz records, while the INS uses
a higher data rate for its corresponding integration. The remaining
differences need further investigation, but the key result from this
part of the study is that as implemented above the derivatives of
components of the state vector are approximately correct and integrate
to reasonable values. The function providing those derivatives is
therefore a reasonable basis for the Kalman filter that follows.

\section{The Kalman filter}

The preceding steps verify that at least an approximate calculation
of the derivatives of the state variables is available. On that basis,
an error-state Kalman filter can be developed, as follows: 

\begin{enumerate}
\item The first step is to initialize an error-state-vector $\delta\mathbf{x}$
from initial measurements of the differences between the INS and GPS
values of position and velocity. Other errors in components of the
state vector are unknown at the start of the integration and so will
be initialized as zero. The 15-component vector used here contains
the respective errors in latitude, longitude, altitude, eastward ground
speed, northward ground speed, rate of climb, pitch, roll, heading,
pitch-axis rotation rate, roll-axis rotation rate, yaw-axis rotation
rate, lateral component of acceleration, longitudinal component of
acceleration, and normal component of acceleration.
\item The covariance matrix $\mathbf{V}$ characterizing the errors in the
error-state-vector is also needed. This is here initialized to have
rather large components because it is expected that the GPS measurements
will have much lower unceertainty than these INS-provided components
and that will constrain the covariance matrix during the calculation.
$\mathbf{V}$ is initialized as a 15x15 diagonal matrix where the
diagonal elements are the squares of these values: \{2000/$R_{m}$,
2000/($R_{n}$cos$\lambda$), 500, 2, 2, 2, 0.3$^{\circ}$, 0.3$^{\circ}$,
1$^{\circ}$, 0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$,
0.0005, 0.0005, 0.0005\}. All entries are in SI units except those
labeled as $^{\circ}$, in which case the values are converted to
radians before use. The variables $R_{m}$ and $R_{n}$ are appropriate
radii of the Earth and $\lambda$ is the latitude. (See the code) 
\item The function STMFV() was verified above and so provides at least an
approximate calculation of the derivatives of the state vector. For
an error-state Kalman filter, the propagation of the error state can
be found from the Jacobian of that function of the state vector, so
the error-state transition matrix $\mathbf{T}$ is the sum of that
Jacobian (multiplied by the time step) and the 15-element diagonal
matrix:\\
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}
\item The noise-covariance matrix $\mathbf{Q}$ represents the noise in
the solution. This is initialized as indicated in the code, via function
GCF. The results can be sensitively dependent on these values, and
the choices made here are the result of tuning to find a set of values
that provides reasonable results. The 15 values used are the squares
of the following: \{30/$R_{m}$, 30/$(R_{n}\cos\lambda$), 150, 0.3,
0.3, 0.3, 0.005$^{\circ}$, 0.005$^{\circ}$, 0.05$^{\circ}$, 0.003$^{\circ}$/s,
0.003$^{\circ}$/s, 0.003$^{\circ}$/s, 0.00002\,m\,s$^{-2}$\}.
All units are SI units except for those labeled as degrees, and in
those cases the values are converted to radians before use. These
values are used with a 5-s time step, and they may need adjustment
if a different time step is used. The very low value representing
noise in the measured accelerations had a significant effect on the
results. Larger values tended to degrade the results for the attitude
angles, presumably because errors could be attributed to errors in
measured accelerations. The results from this particular filter will
then rely on the assumption that, for the most part, errors in acceleration
are not significant.
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are known, the covariance matrix
can be updated each time step via\\
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]
\item The Kalman gain is then given by\\
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]
where $\mathbf{H}$ is a 15X6 diagonal matrix representing how the
six measured differences (GPS-INS) correspond to the error-state vector.
$\mathbf{R}$ is the measurement-noise-covariance matrix representing
the GPS noise, a 6x6 matrix having diagonal elements that are the
squares of these components: \{50/$R_{m}$, 50/($R_{n}\cos\Phi$,
100, 0.1, 0.1, 0.1\}.\footnote{Four additional measurements were explored for inclusion, the three
measurements of acceleration determined by differentiating the measurements
of velocity components from the GPS receiver and a representation
of heading error derived from the difference between the angle determined
by transforming measured accelerations to the l-frame and the corresponding
angle determined from the GPS-derived horizontal components of the
acceleration. These complicate the tuning and will not be discussed
in this report.} 
\item Define \textbf{$\delta\mathbf{z}$ }as the set of nine measurements
consisting of the differences between GPS and INS positions and velocities.
The error-state vector is then further updated as follows:\\
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]
\item Finally, the covariance matrix is updated further according to\\
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]
\end{enumerate}
To apply these equations, it is not necessary to use a high-rate file
and update at high rate because it is expected that the errors vary
slowly. However, turns and other maneuvers can introduce spurious
effects if time delays are not adjusted well. For these reasons, a
1-Hz data file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles as well as
the rotation rates and accelerations will be shifted in time where
needed and then smoothed before applying the Kalman filter. DEEPWAVE
flight 16 was selected, and the measurements were filtered with 11-s
smoothing of accelerations and 301-s smoothing of measured velocity
components and attitude angles.

<<new-data, include=TRUE, echo=FALSE, cache=TRUE>>=

Flight <- "16" 			
Project = "DW"     		
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
D1 <- getNetCDF (fname, c(VarList, 'PSXC', 'ATX', 'ACINS'))
## remove heading adjustments as added during initial processing
Z <- data.frame(getAttributes(D1$THDG, .print=FALSE))
if ('CalibrationCoefficients' %in% names(Z)) {
  THDGoffset <- Z$CalibrationCoefficients[1]
} else {
  THDGoffset <- 0
}
if ('TimeLag' %in% names(Z)) {
  D1$THDG <- ShiftInTime(D1$THDG, -Z$TimeLag[1])
}
D1$THDG <- (D1$THDG - THDGoffset) %% 360
DL <- nrow(D1)
## adjustments:
# D1$BYAWR <- D1$BYAWR - 0.005
# D1$BROLLR <- D1$BROLLR + 0.0005
# D1$BPITCHR <- D1$BPITCHR + 0.0005
# D1$BNORMA <- D1$BNORMA*1.005 - 0.015
# D1$BLONGA <- D1$BLONGA * 0.96
# D1$BLATA <- D1$BLATA * 1.1
s <- -120
# s <- -92
si <- 0
Rate <- 1
SHIFT <- FALSE
SHIFT <- TRUE
if (SHIFT) {
  D1$GGVEW <- ShiftInTime (D1$GGVEW, Rate, s)
  D1$GGVNS <- ShiftInTime (D1$GGVNS, Rate, s)
  # D1$BLONGA <- ShiftInTime (D1$BLONGA, Rate, s-80)
  # D1$BLATA <- ShiftInTime (D1$BLATA, Rate, s-80)
  # D1$BNORMA <- ShiftInTime (D1$BNORMA, Rate, s-80)
}

D1$DPDT <- c(0, diff(D1$PSXC))
Rd <- StandardConstant('Rd')
TK <- 273.15 + D1$ATX
g <- 9.80
D1$WPPRIME <- -Rd * TK / (D1$PSXC * g) * D1$DPDT
D1$WPSTAR <- cumsum(D1$ACINS)
D1$DIF <- D1$WPPRIME - D1$WPSTAR
D1$DIF <- zoo::na.approx (as.vector(D1$DIF), maxgap=1000, na.rm=FALSE)
tau <- 300
D1$DIFW <- signal::filter (signal::butter (3, 2/tau), D1$DIF)
D1$ROC <- D1$WPSTAR + D1$DIFW

dt <- 1    ## this is a 1-Hz file
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
## the following is commented because the centripetal effect is already included in 'Gravity()'
# Re <- StandardConstant ('Re')
# D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2 + D1$GGALT)
#interpolate if necessary: otherwise later filters fail
MaxGap <- 1000
D1$GGVNS <- ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
D1$GGVEW <- ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
D1$GGVSPD <- ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
D1$VNS <- vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
D1$VEW <- vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
D1$VSPD <- vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
## smooth the measurements when determining derivatives
.span <- 11    
## The following are accelerations determined from derivatives of the GPS velocities.
## These should match the measured accelerations after transformation to the l-frame
## and application of the rotation correction:
D1$vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
D1$vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
D1$vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
## transform to the a-frame for comparison to the IRU:
G <- D1$Grav
VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection (D1, VL)
AA <- XformLA (D1, LA, .inverse=TRUE)
AA[,3] <- AA[,3] - G
fa1 <- lm(D1$BLONGA ~ AA[, 1])
fa2 <- lm(D1$BLATA ~ AA[, 2])
fa3 <- lm(D1$BNORMA ~ AA[, 3])
AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame 
AL <- XformLA (D1, AB)                                    #l-frame
## now corrected for angular effects
## See Noureldin et al, 2013, Eq. (5.55)
AL <- AL + RotationCorrection (D1, VL)  ##### check this sign and prev call above
  
## the resulting l-frame accelerations
D1$LACCX <- AL[, 1]
D1$LACCY <- AL[, 2]
D1$LACCZ <- AL[, 3] + G
D1$LACCZ <- -D1$LACCZ
  
## smooth to match GPS-velocity derivatives
D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
.span <- 301
SMOOTH <- FALSE
if (SMOOTH) {
  vns <- signal::sgolayfilt (vns, 3, .span)
  vew <- signal::sgolayfilt (vew, 3, .span)
  vspd <- signal::sgolayfilt (vspd, 3, .span)
  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)

  D1$VNSF <- vns
  D1$VEWF <- vew
  D1$VSPDF <- vspd
  D1$GGVNSF <- ggvns
  D1$GGVEWF <- ggvew
  D1$GGVSPDF <- ggvspd
  D1$PITCHF <- pitch
  D1$ROLLF <- roll
  D1$THDGF <- thdg
}

## get the pitch and roll in the l-frame:
.thdg <- D1$THDG * Cradeg
D1$PITCHL <- D1$PITCH * cos (.thdg) + D1$ROLL * sin (.thdg)
D1$ROLLL <-  -D1$PITCH * sin (.thdg) + D1$ROLL * cos (.thdg)

fm1 <- lm (D1$vedot ~ D1$LACCX)
fm2 <- lm (D1$vndot ~ D1$LACCY)
fm3 <- lm (D1$vudot ~ D1$LACCZ)

@

As a check on the uncertainty associated with the accelerometers,
the GPS measurements of velocity components were differentiated and
the resulting accelerations transformed to the a-frame and compared
to the measured accelerations from the IRU (with correction for the
Earth's rotation and the motion of the l-frame relative to an inertial
frame). For the longitudinal acceleration (along the aircraft axis),
the linear regression of the measured acceleration vs the GPS-derived
acceleration had offset \Sexpr{round(coef(fa1)[1], 4)} and slope
\Sexpr{round(coef(fa1)[2], 4)}., with a residual standard error of
\Sexpr{round(summary(fa1)$sigma, 4)}\,m\,s$^{-2}$. For the normal
component of acceleration, the corresponding values are respectively
\Sexpr{round(coef(fa3)[1], 4)}, \Sexpr{round(coef(fa3)[2], 4)}.,
and \Sexpr{round(summary(fa3)$sigma, 4)}\,m\,s$^{-2}$. These then
can be considered calibrations for the accelerometers as well as indications
of their uncertainty. \footnote{The lateral accelerations were too noisy for a similar calibration
because lateral accelerations are usually small and short-term except
during periods with significant slip, which were not present on this
flight.}

The differentiated measurements of velocity components from the GPS
can be considered as additional measurements corresponding to the
measured accelerations. This is discussed further in the following
sections.

\subsection{Detecting the error in heading\label{subsec:heading-error}}

Most of the components of the state vector have good feedback from
GPS-derived measurements, but an exception is the measurement of heading.
For position and velocity, there is direct correspondence between
INS- and GPS-derived measurements. For pitch and roll, there is strong
coupling to errors in the eastward and northward components of aircraft
velocity. However, the coupling of INS-measured heading to GPS observations
is not a case of strong coupling (to which the Schuler oscillation
applies), and it is more difficult to update via measurements from
the GPS receiver. 

As specified above, the differentiated GPS velocities provide an l-frame
measurement of acceleration, and these can be transformed back to
the a-frame to provide measurements that correspond to BLATA, BLONGA,
and BNORMA. However, a difference in a-frame accelerations from the
two sources can arise not only from errors in the measured accelerations
but also (and more likely) from an error in heading, which would cause
incorrect translation between l-frame and a-frame components. The
source of coupling between GPS-derived measurements and heading is
via the aircraft-velocity components, because an error in heading
causes the IRU-measured accelerations to be resolved into the \emph{l-}frame
incorrectly and so introduces errors in the aircraft-velocity components
that can be detected via comparison to GPS-provided velocity components.
Unfortunately, in most cases the measured accelerations are small,
resulting in large uncertainties in any correction term except during
turns. 

For these reasons, it is useful to treat heading differently. Most
of the evidence from filghts that have been examined suggests that
the heading error is small and changes little during the flight. However,
the Kalman filter often leads to significant variations (often 0.2$^{\circ}$
or more) accompanied by large variances (of similar magnitude or larger)
that call the varying result into question. The only periods when
the heading error is constrained well is during turns, when there
are significant horizontal accelerations. With strong accelerations,
the direction of the acceleration is determined well and an error
in heading leads to errors in how those accelerations are translated
into the l-frame where they affect the ground-speed vector, leading
to errors in that vector that can be detected by the Kalman filter.

To illustrate the problem, consider the measured horizontal-acceleration
vector obtained by transforming the measured \emph{a-}frame accelerations
to the \emph{l-}frame. If there is no heading error, the azimuth angle
corresponding to this l-frame vector acceleration should be the same
as the azimuth angle of the vector acceleration determined by differentiating
the GPS-measured components of horizontal velocity. The difference
is a measure of the heading error: \\
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}
where $a_{e}^{(l)}$ and $a_{n}^{(l)}$ are the \emph{l-}frame accelerations
obtained by transforming the IRU-measured accelerations from the \emph{a-}frame
to the \emph{l-}frame and $\dot{v}_{e}$ and $\dot{v}_{n}$ are the
eastward and northward components of the acceleration obtained from
the time-derivatives of the GPS-measured eastward and northward velocity
components $v_{e}$ and $v_{n}$. The assumption made when using this
formula is that the errors in the INS-produced accelerations in the
\emph{l-}frame arise from the heading error with negligible contribution
from errors in the accelerometers themselves. If this is the case,
it would be possible to base the heading correction on this formula
alone, but the more general case needs to consider how this might
be influenced by errors in accelerations. Appropriately incorporating
this measurement of heading error into the Kalman filter would allow
for the possibility that measured accelerations as well as the heading
need to be adjusted.

Because significant horizontal accelerations occur mostly in turns
when both angles in (\ref{eq:Hcorr}) are changing rapidly, it is
very important to have correct relative timing between the INS measurement
of heading and the GPS measurement of velocity.\footnote{As an illustration, a 50-ms delay in heading during a 3-min turn causes
a shift in heading relative to the correct time of 0.1$^{\circ}$,
so adjustment to at least this uncertainty is desirable. } The GPS measurements are assigned correct times by the GPS receiver
and represent a standard clock against which to compare other measurements.\footnote{It appears that the relative timing between the IRU and the GPS can
drift enough during some flights to introduce significant errors.} If the GPS-vs-INS time shift is not removed, a bias will be introduced
into the heading correction that varies with turn direction. Therefore
the following procedure will be followed to remove this time shift:
\begin{enumerate}
\item Differentiate the GPS-provided measurements to obtain $\dot{v}_{e}$
and $\dot{v}_{n}$.
\item Transform the unshifted body accelerations to the \emph{l-}frame,
with rotation corrections, to obtain the eastward and northward components
of acceleration ($a_{e}^{(l)}$, $a_{n}^{(l)}$) in the local-level
frame. 
\item Find the heading correction for unshifted measurements by calculating
$\delta\psi$ from (\ref{eq:Hcorr}).
\item Calculate the running-standard-deviation of $\delta\psi$ spanning
30 seconds. Select the subset of $\delta\psi$ for which that standard
deviation is less than 0.2$^{\circ}$.
\item Fit the subset to find the slope $b$ in the relationship $\delta\psi=a+b\thinspace\tan\phi$
where $\phi$ is the roll angle. The rate of turn $R$ is related
to the roll angle $\phi$ according to the relationship $R=g\thinspace\tan\phi/V$
where $V$ is the airspeed, so $\tan\phi=RV/g$ and $\delta\psi=a+bRV/g$.
A time delay of $\delta t$ produces a heading error of $-R\delta t$,
so $-R\delta t=a+bRV/g$ and the time shift can be estimated from\\
\begin{equation}
\delta t=-b\frac{V}{g}\,\,\,\,.\label{eq:deltaT}
\end{equation}
For example, for DEEPWAVE flight 16, $b=0.2146^{\circ}$s$^{-1}$
= 0.003745\,rad\,s$^{-1}$ and $V\simeq240$\,m\,s$^{-1}$, so
(with g=9.8\,m\,s$^{-2}$) $\delta t=$-0.092~s. The negative sign
indicates that the INS-derived measurement of heading appears to be
shifted backward (earlier) in time by 92\,ms relative to the GPS-derived
measurements of aircraft velocity. The standard error from the fit
indicates that this shift was determined with an uncertainty of about
3\,ms, so this is a very sensitive way to determine the time shift.
Note that the result is not influenced by a real error in heading.
\item Apply this time shift to the measurements of ground speed from the
GPS (GGVEW and GGVNS), in this case shifting them backward (earlier)
in time by 92~ms while leaving the heading unshifted.\footnote{The reason that it is preferable to shift GGVEW and GGVNS rather than
THDG is that it is common in processed files for heading to already
be shifted. In the case discussed here, heading was already shifted
by $-80$~ms. However, this was done after processing by the INS,
so measurements like VEW and VNS have been determined with the heading
as used inteernally by the INS, not as shifted during subsequent processing.
The feedback provided by the Kalman filter then relies on the heading
before shifting, and subsequent shifting of the heading has no effect
on those measurements. It does affect the recalculated transformation
from a-frame to l-frame, so there would be an inconsistency between
(\ref{eq:Hcorr}) and other estimates of the heading error arising
from the Kalman filter.} For a file containing measurements at 1~Hz, this requires creating
an interpolated high-rate vector of measurements, shifting that vector,
and then extracting a shifted 1-Hz vector from the shifted measurements.
The Ranadu function ShiftInTime() accomplishes this by interpolating
to a 125-Hz variable. The result can be checked by repeating step
5 using the shifted measurements; for this case, the deduced shift
needed for the shifted time series was only 1~ms. 
\end{enumerate}
After an appropriate time shift is introduced, (\ref{eq:Hcorr}) is
an appropriate measurement of heading error to include in the error-measurement
vector $\delta\mathbf{z}$. Here, that is accomplished by adding a
seventh component to the measurement vector and a seventh row to$\mathbf{H}$,
where a matrix element 1 then appears in row 7, column 9. should have
contributions from rows 7 and 8. Formulated in this way, the dependence
is complex and non-linear, so it is simpler to add a 10th component
to the measurement vector with value given by \ref{eq:Hcorr}) and
associate that directly (with coefficient 1 after appropriate conversion
from radians to degrees) with column 9 of the information matrix $\mathbf{H}$,
which then must have 10 rows and 15 columns.

Because typical horizontal accelerations in the l-frame are small,
this estimate of the heading error is too noisy to be useful except
in turns where the horizontal accelerations are significant, often
about 3~m/s$^{2}$. In normal straight flight, the standard deviation
in the estimate obtained from (\ref{eq:Hcorr}) is around 15$^{\circ}$,
but in turns this standard deviation reduces to typically about 0.15$^{\circ}$.
This has two important consequences. First, flights without turns
or other sources of horizontal acceleration will lack the information
for adjusting the heading. so in flights where good wind measurements
are important regular turns should be part of the flight plans. Second,
when the GPS-based estimate of the heading error is used, an appropriate
variance should be assigned to prevent excessive noise from affecting
the result from the Kalman filter and it will be best to suppress
updating to the GPS result except when horizontal accelerations are
significant (perhaps >1\,m\,s$^{-2}$). For the flight being used
as an example, the mean and standard deviation of the correction from
(\ref{eq:Hcorr}) for all cases where the horizontal accelerations
exceed this criterion are 0.003$\pm0.15{}^{\circ}$ for 4295 1-Hz
measurements, and the mean error is determined to about 0.002$^{\circ}$.

\subsection{Smoothing the errors in pitch and roll\label{subsec:Smoothing-the-errors}}

Because the errors in pitch and roll are strongly coupled to the errors
in velocity, good estimates of these errors should arise naturally
from the Kalman filter. However, the errors so obtained are sometimes
noisy in comparison to the direct measurements, so application of
those corrections will introduce undesirable noise into the results
from the filter. Because it i8s expected that the main source of error
is reflected in the slowly varying Schuler oscillation, it is preferable
to smooth the corrections before application to the original measurements
to avoid the introduction of noise. As described above, the errors
in pitch and roll are those that apply to the original measurements
in the a-frame. However, if a major source of those errors is platform
misalignment that varies slowly, the errors will vary smoothly in
the l-frame, where l-frame pitch error refers to platform north-south
tilt and l-frame roll error refers to platform east-west tilt. In
the a-frame, each turn leads to mixing of the pitch and roll errors
and to abrupt changes, so smoothing in the l-frame followed by transformation
back to the a-frame produces a better result. This will be discussed
further after the results from the Kalman filter are presented.

<<Kalman-setup, include=TRUE, echo=FALSE>>=

## initial values of the state vector and error-state vector:
SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
## also need the corresponding noise vector:
tau <- 60
GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data record
  gcf <- vector('numeric', length=15)
  gcf[1] <- 30 / sp$Rm
  gcf[2] <- 30 / (sp$Rn * cos (sv$LAT))
  gcf[3] <- 150
  gcf[4:6] <- 0.3    ## 0.3
  gcf[7:8] <- 0.005*Cradeg  ## 0.005
  gcf[9] <- 0.05*Cradeg    ## 0.015
  gcf[10:11] <- 0.003*Cradeg    ## 0.015
  gcf[12] <- 0.003*Cradeg       ## 0.015
  gcf[13:15] <- 0.00002
  # gcf <- as.vector(gcf) * sqrt(2/tau)
  return (gcf)
}
gcf <- as.numeric (GCF (SV, D1[1, ]))

## The measurement model: calculate the measurements of acceleration from the GPS to add to the measurement vector
GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
dim(GAEL) <- c(DL, 3)
## transform to the a-frame
GAE <- XformLA (D1, GAEL, .inverse=TRUE)
DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW, VNS-GGVNS, ROC-GGVSPD))
# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later
## The last three components provide direct feedback to measured acceleration
## in the a-frame but also provide feedback to heading, as developed below
# dim(DZ) <- c(DL, 9)
# dim(DZ) <- c(DL, 6)
# DZ[,1:2] <- DZ[, 1:2] * Cradeg
## now add the pseudo-measurement of heading error found from the accelerations:
D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the std dev
## add the heading correction to the measurement vector
DZ <- c(as.vector(DZ), D1$deltaPsi)
dim(DZ) <- c(DL, 7)
DZ[ ,1:2] <- DZ[ ,1:2] * Cradeg

## The observation matrix: (the first six and last three components of the state error 
## vector are observable, the latter requiring transformation from l-frame to a-frame)
## components 7-9 are connected to IRU-measured rotation rates via the transformation matrix l->a,
## so matrix H must vary with aircraft attitude angles. This is addressed by the GAEL->GAE transform.
# H <- diag(1, nrow=10, ncol=15)
# for (k in 7:9) {
#   H[k,k] <- 0
#   H[k,k+6] <- 1
# }
# H[10,9] <- 1
H <- diag(1, nrow=7, ncol=15)
H[7,7] <- 0
H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component 9


## at any time step, assume the measurements are contaminated by noise:
RCV <- matrix (rep(0,100), ncol=10)
RCV <- matrix (rep(0,49), ncol=7)
RCV[1,1] <- (10/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (10/(D1$Rn[1]*cos(SV$LAT)))^2
RCV[3,3] <- 100^2
RCV[4,4] <- 0.3^2            ## ve
RCV[5,5] <- 0.3^2
RCV[6,6] <- 0.3^2
# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measurement.
# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an error in heading, not
# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration is used for that.
# RCV[10,10] <- D1$sdPsi[1]^2
# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
# # RCV[10, 10] <- 1000  ## suppress effect
RCV[7,7] <- 1000  ## but update this each time step

## initialize covariance matrix with generous variances
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)


@

<<Kalman-loop, include=TRUE, echo=FALSE, eval=TRUE, cache=TRUE>>=

Data <- D1
DL <- nrow (Data)
  # find PITCHL, ROLLL in the l-frame
  # find PitchL, RollL, ThdgL in the l-frame: start with unit vector normal to AC
  # UV <- array (c(rep(0,DL), rep(0,DL), rep(-1,DL)), dim=c(DL,3))
  # UVL <- XformLA (Data, UV)
  # PitchL <- asin (-UVL[,2])
  # RollL <- asin (UVL[,1])
  #   .hdg <- Data$THDG*Cradeg
  #   PitchA <- (sin(.hdg)*RollL + cos(.hdg)*PitchL)/Cradeg
  #   RollA <- (cos(.hdg)*RollL - sin(.hdg)*PitchL)/Cradeg

## note: if using l-frame PITCH and ROLL; STMFV must account for this

NSTEP <- 5      ## update time
SVEF <- array(dim=c(DL/NSTEP, 15))
CVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
                    ## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[1, 1:6]
## pitch and roll errors are going to be those in the l-frame
SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions here
## start with zero for gyro and accelerometer errors
SVEF[1, ] <- SVE
CVEF[1, ] <- diag (CV)
# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
pctL <- 0
MH <- 0    ## 0 suppresses use of deltaPsi as error in heading
for (i in seq(2*NSTEP, DL, by=NSTEP)) {
  pct <- as.integer(100*i/DL)
  # if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d', pct));pctL <- pct}
  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL, THDG,
                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- Data$Rn[i]
  Rm <- Data$Rm[i]
  Grav <- Data$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv, .aaframe='a') * dt * NSTEP + diag(15)
  ## modify to include this?
## modify this to include decaying error terms for the measurements:
# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new error-state vector:
  ## the pitch and roll error derivatives are now those in the a-frame, but
  ##   the pitch/roll error state is in the l-frame. Save the l-frame error state:
#   SVEL <- SVEA <- SVE
#   ## Transform l-frame pitch/roll error state to a-frame
#   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
#   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
#   ## apply derivatives to get a-frame change
#   SVEA <- dcm %*% SVEA
#   ## transform back to l-frame
#   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
#   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
  
  SVE <- dcm %*% SVE    ## take time step in error-state vector

  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  ## the Kalman gain:
  if (is.na(Data$sdPsi[i]) || (sqrt(Data$LACCX[i]^2+Data$LACCY[i]^2) < 1)) {
    H[7,9] <- 0
    # DZ[i, 7] <- NA
  } else {
    H[7,9] <- MH
    RCV[7, 7] <- 10*Data$sdPsi[i]^2
  }
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
  CVEF[i/NSTEP, ] <- diag(CV)
}

## interpolate the results over the full data.frame:
IntFilter <- function (X, inRate, outRate) {
  if (inRate == outRate) {return (X)}
  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
  x <- 0:(length(X)-1)
  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
  T <- A$y
  T <- signal::filter(signal::sgolay(4,75),T)
  ## now shift to match 25-Hz:
  n <- as.integer (ratio / 2)
  NL = length(T)
  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
  return (T)
}
Cor <- vector('numeric', DL*15)
dim (Cor) <- c(DL, 15)
VCor <- vector ('numeric', DL*15)
dim (VCor) <- c(DL, 15)
X <- SVEF[, 1]
for (j in 1:15) {
  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
  VCor[VCor[,j] < 0] <- 0 
  if (j > 6) {next}
  Cor[, j] <- zoo::na.approx (as.vector (Cor[, j]), maxgap=1000, na.rm=FALSE)
  Cor[is.na(Cor[, j]), j] <- 0
  Cor[, j] <- signal::filtfilt (signal::butter (3, 1/600), Cor[, j])
}
# Cor7 <- Cor[, 7]
# VC7 <- VCor[, 7]
# .hdg <- Data$THDG * Cradeg
# Cor[, 7] <- cos(.hdg) * Cor7 - sin(.hdg) * Cor[, 8]
# Cor[, 8] <- sin(.hdg) * Cor7 + cos(.hdg) * Cor[, 8]
# VCor[, 7] <- cos(.hdg) * VC7 - sin(.hdg) * VCor[, 8]
# VCor[, 8] <- sin(.hdg) * VC7 + cos(.hdg) * VCor[, 8]
Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
Data$ALTKF <- Data$ALT - Cor[, 3]
Data$VEWKF <- Data$VEW - Cor[, 4]
Data$VNSKF <- Data$VNS - Cor[, 5]
Data$ROCKF <- Data$ROC - Cor[, 6]
Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
Data$BLATAKF <- Data$BLATA - Cor[, 13]
Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
Data$BNORMAKF <- Data$BNORMA - Cor[, 15]

Data$DLAT <- Data$LATKF-Data$GGLAT
Data$CLAT <- -Cor[, 1] / Cradeg
Data$DLON <- Data$LONKF-Data$GGLON
Data$CLON <- -Cor[, 2] / Cradeg
Data$DALT <- Data$ALTKF-Data$GGALT
Data$CALT <- -Cor[, 3]
Data$DVEW <- Data$VEWKF-Data$GGVEW
Data$CVEW <- -Cor[, 4]
Data$DVNS <- Data$VNSKF-Data$GGVNS
Data$CVNS <- -Cor[, 5]
Data$DROC <- Data$ROCKF-Data$GGVSPD
Data$CROC <- -Cor[, 6]
Data$CPITCH <- -Cor[, 7] / Cradeg
Data$CROLL <- -Cor[, 8] / Cradeg
Data$CTHDG <- -Cor[, 9] / Cradeg
KalmanCaptions <- c("Comparison of the KF, GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.",
                    "Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines show the corrections applied to the original INS values by the Kalman filter.",
                      "Pitch Correction from the Kalman filter (CPITCH, blue line) and from Ranadu::CorrectPitch (PC, red line)",
                      "Roll Correction from the Kalman filter (CROLL) and from Ranadu::CorrectPitch (RC, red line)",
                      "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")

@

\clearpage

\section{Results}


\subsection{Position}

The KF (Kalman filter) results for position, for DEEPWAVE flight 16,
are shown in Fig.~\ref{fig:plot-Kalman-position}. The blue lines
in the top two panels show that differences between the KF and GPS
measurements (DLAT=LAT$-$GGLAT+CLAT and DLON=LON$-$GGLON+CLON where
CLAT and CLON are the corrections produced by the Kalman filter) are
neglibly small for latitude and longitude, at the resolution of these
plots. (0.01$^{\circ}$ in latitude corresponds approximately to 1
km.) This good agreement arises from the corrections CLAT and CLON
shown as the green lines, which show a smoothly varying Schuler oscillation.
\footnote{Before subtraction from the original measurement, this correction
has been filtered using a three-pole low-pass Butterworth filter with
cutoff frequency corresponding to a period of 600~s. This avoids
the introduction of noise from the Kalman filter that otherwise would
contaminate the high-frequency variance spectra.} When the differences are examined at higher resolution, however,
there are step-change features in the KF result that are not present
in the GPS measurement, at a level of about 10~m. The reason is that
this is the resolution at which the original measurements from the
INS (variables LAT and LON) are recorded, so a smoothly varying correction
as provided by the Kalman filter preserves these step changes. Because
the true values of latitude and longitude are not expected to show
high-frequency components at these frequencies, the results after
correction are further filtered using a low-pass filter with a cutoff
frequency corresponding to about 10~s. This effectively smooths the
jumps arising from the original measurements from the INS and leads
to agreement between the KF and GPS values corresponding to about
10~m standard deviation for the part of the flight track that excludes
the initial climb and final descent. Some part of this standard deviation
likely arises from minor time shifts between the measurements from
the INS and GPS.

<<plot-Kalman-position, include=TRUE, echo=FALSE, fig.cap="Comparison of the KF (Kalman filter), GPS, and INS values of latitude, longitude, and altitude for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.">>=

r <- setRange (Data, 70000, 122000)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DLAT, CLAT)))
plotWAC (subset (Data[r, ],, c(Time, DLON, CLON)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DALT, CALT)))
sdZ <- with (Data[r, ], sd(DALT, na.rm=TRUE))
## filter the result to smooth the jumps arising from limited INS resolution:
Data$LATKF <- zoo::na.approx (as.vector (Data$LATKF), maxgap=1000, na.rm=FALSE)
Data$LONKF <- zoo::na.approx (as.vector (Data$LONKF), maxgap=1000, na.rm=FALSE)
Data$LATKF[is.na(Data$LATKF)] <- 0
Data$LONKF[is.na(Data$LONKF)] <- 0
Data$LATKF <- signal::filtfilt (signal::butter (3, 1/10), Data$LATKF)
Data$LONKF <- signal::filtfilt (signal::butter (3, 1/10), Data$LONKF)
sdvew <- with(Data[r, ], sd(GGVEW-VEWKF, na.rm=TRUE))
sdvns <- with(Data[r, ], sd(GGVNS-VNSKF, na.rm=TRUE))
meanvz <- with (Data[r, ], mean(ROCKF-GGVSPD, na.rm=TRUE))
sdvz <- with (Data[r, ], sd(GGVSPD-ROCKF, na.rm=TRUE))

@

The bottom panel in Fig.~\ref{fig:plot-Kalman-position} shows that
a significant offset is required to correct the altitude, as expected
because the INS-provided altitude is updated to the pressure altitude
while the GPS provides geometric altitude above MSL. The repetitive
pattern in the correction arises from the repeated portions of the
flight track, which passed over the South Island of New Zealand in
retracing patterns. The updating effectively adjusts the altitude
to match the GPS-measured altitude, with a standard deviation in the
central part of this flight track that was \Sexpr{round(sdZ, 0)}~m. 

The result then is that the KF values are in agreement with the GPS-provided
measurements of position to within about 10~m in each component of
the position vector. The uncertainty arising from the calculated covariance
matrix also indicates uncertainty for individual measurements of latitude
or longitude corresponding to about 10~m.

\subsection{Ground-speed components}

Figure \ref{fig:plot-Kalman-velocity} shows the corresponding differences
between the aircraft-velocity components and the GPS-provided measurements,
for the same flight as that shown in the preceding figure. For the
two horizontal components of ground speed, the mean difference between
KF and GPS results is negligible ($<0.00001$~m/s) and the standard
deviation of this difference is about \Sexpr{round(sdvns, 2)}~m/s,
mostly arising in turns and likely the result of small timing differences
between INS-provided and GPS-provided measurements. There does not
appear to be a problem with resolution for the INS variables (VEW
and VNS) as there was for position, so no further smoothing of these
results is needed. Indeed, plots of the KF and GPS variables for short
time periods indicate that there is more noise in the GPS-provided
variables (GGVEW and GGVNS) than in the KF variables, so using these
variables in the calculation of horizontal wind may lead to better
high-frequency spectral characteristics than those obtained using
the GPS-provided variables. This will be explored further in Sect.~XXX
{[}later section discussing the impact of the KF on wind measurements).

The difference between the KF and GPS variables for rate-of-climb
of the aircraft, shown in the bottom panel of Fig.~\ref{fig:plot-Kalman-velocity},
is more significant and needs further discussion. This calculation
was first done using the INS-provided variable VSPD as the vertical-motion
component of the state variable. While the mean values were similar,
the standard deviation in this difference was about 0.28~m/s, which
is larger than expected or desirable. The difficulty likely arises
from the INS variable VSPD, which is processed internally in the INS
before being provided to the GV data system for recording. Studies
of this variable indicate that it has been filtered and shifted in
time, and the INS processing includes a baro-loop that updates to
the pressure altitude. This memo (Recommendation161107f.pdf) argues
that VSPD is a poor variable to use when calculating the vertical
wind and that an alternative variable (ROC) would provide a better
representation of the rate of climb of the aircraft. That new variable
has been used in the present calculation instead of VSPD because it
gives a better representation of the rate of climb while still being
independent of the GPS measurements. The Kalman filter then updates
that variable to the GPS measurement (GGVSPD), to produce the new
variable ROCKF that is shown in this plot. The mean difference between
the GPS value and the Kalman filter was \Sexpr{round(meanvz,3)}~m/s,
with standard deviation \Sexpr{round(sdvz, 2)}~m/s. Section~XXX
explores the characteristics of the new variable (ROCKF) as it would
influence calculation of the vertical wind.

<<plot-Kalman-velocity, include=TRUE, echo=FALSE, fig.cap="Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-provided values, while the green lines (red line in the bottom panel) show the corrections applied to the original INS values by the Kalman filter.">>=

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DVEW, CVEW)))
plotWAC (subset (Data[r, ],, c(Time, DVNS, CVNS)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset (Data[r, ],, c(Time, DROC, CROC)), ylim=c(-2,2),
         lwd=c(1,2), col=c('blue', 'red'))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset

@

\subsection{Attitude angles}

\subsubsection{Roll and pitch}

The primary value of the Kalman-filter solution is that it can improving
the measurements of attitude angles. Measurements of position and
velocity with good quality are already available from the GPS, so
the results in this sub-section are the primary reason for considering
use of this Kalman filter to improve the measurements of wind. As
discussed in Sect.~\ref{subsec:Smoothing-the-errors}, it is expected
that the errors in pitch and roll will vary more smoothly in the l-frame
than in the a-frame because each turn changes how any platform misalignment
is resolved into pitch and roll errors. It is therefore useful to
transform the pitch and roll errors to the l-frame for smoothing by
averaging or filtering. The transformation is\\
\begin{eqnarray}
\delta\theta^{(l)} & = & \cos\psi\thinspace\delta\theta^{(a)}+\sin\psi\thinspace\delta\phi^{(a)}\label{eq:lpitch}
\end{eqnarray}
\begin{eqnarray}
\delta\phi^{(l)} & = & -\sin\psi\thinspace\delta\theta^{(a)}+\cos\psi\thinspace\delta\phi^{(a)}\label{eq:lroll}
\end{eqnarray}
where $\theta$ is pitch, $\phi$ is roll, $\psi$ is heading, and
the superscripts indicate the reference frame. After this transformation
is applied to the error-state vector produced by the Kalman filter,
the pitch and roll errors in the l-frame are as shown in \ref{fig:plot-Kalman-angles1}.
The Schuler oscillation is evident in both, with some departures that
are mostly associated with turns. Also shown in this plot is the result
of applying a low-pass third-order Butterworth filter with 900~s
cutoff period to the errors. The result is a smoothly varying error
signal dominated by the Schuler oscillation that eliminates much of
the apparent noise introduced by the Kalman filter. Figure \ref{fig:plot-Kalman-angles2}
shows the result of transforming the smoothed error signal back to
the a-frame. These estimated errors are then subtracted from the original
measurements to obtain the results from the Kalman filter.

The variances associated with l-frame pitch and roll can be found
by appropriate derivation from (\ref{eq:lpitch}) and (\ref{eq:lroll}).
The resulting variances correspond to a standard deviation of typically
about 0.2$^{\circ}$, but that then is reduced by an appropriate factor
representing the reduction in standard deviation from averaging many
points, as was done with the low-pass filter with 900~s cutoff. Averaging
900 points would reduce the expected standard deviation by a factor
of 1/30, so this seems an appropriate factor to use when representing
the smoothed-correction uncertainty. Orange vertical lines in Fig.~\ref{fig:plot-Kalman-angles1}
show the resulting standard uncertainty in pitch and roll in the l-frame,
and this then leads to the standard uncertainty in the a-frame for
the smoothed error estimates, as shown in Fig.~\ref{fig:plot-Kalman-angles2}.
The mean standard deviation obtained in this way is 0.01$^{\circ}$
for both pitch and roll in either the a-frame or l-frame, so this
is reasonable estimate of the uncertainty after correction using the
Kalman filter.

<<plot-Kalman-angles, include=TRUE, echo=FALSE, fig.cap=c("Errors in pitch and roll after transformation to the l-frame (blue lines). The red lines result from the application of a centered low-pass third-order Butterworth filter to the errors, where the filter cutoff frequency corresponds to a period of 900 s. Short black lines plotted each 2 min show the estimated standard uncertainty.", "The result of transforming the filtered result shown in the previous figure back to the a-frame, for pitch and roll errors. Also shown as red lines are the results from the Ranadu routine CorrectPitch(). The short black lines plotted each 2 min show the estimated standard uncertainty.")>>=

.hdg <- Data$THDG * Cradeg
Data$CPL <- (cos(.hdg)*Cor[,7]+sin(.hdg)*Cor[,8]) / Cradeg
Data$CRL <- (-sin(.hdg)*Cor[,7]+cos(.hdg)*Cor[,8]) / Cradeg
Data$SDCPL <- sqrt(cos(.hdg)^2*VCor[,7]+sin(.hdg)^2*VCor[,8]) / (Cradeg * 30)
Data$SDCRL <- sqrt(sin(.hdg)^2*VCor[,7]+cos(.hdg)^2*VCor[,8]) / (Cradeg * 30)
Data$SDCPA <- sqrt(cos(.hdg)^2*Data$SDCPL^2 + sin(.hdg)^2*Data$SDCRL^2)
Data$SDCRA <- sqrt(sin(.hdg)^2*Data$SDCPL^2 + cos(.hdg)^2*Data$SDCRL^2)
Data$CPLF <- signal::filtfilt (signal::butter (3, 1/900), Data$CPL)
Data$CRLF <- signal::filtfilt (signal::butter (3, 1/900), Data$CRL)
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
with(Data[r, ], plotWAC(data.frame(Time, CPL, CPLF), col=c('blue', 'red'), 
                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame pitch error'))
for (k in seq(1, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]), 
        c(Data$CPLF[r[k]]+Data$SDCPL[r[k]], Data$CPLF[r[k]]-Data$SDCPL[r[k]]), 
        lwd=0.7, col='black')}
op <- par (mar=c(5,4,1,1)+0.1)
with(Data[r, ], plotWAC(data.frame(Time, CRL, CRLF), col=c('blue', 'red'), 
                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame roll error'))
for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]), 
        c(Data$CRLF[r[k]]+Data$SDCRL[r[k]], Data$CRLF[r[k]]-Data$SDCRL[r[k]]), 
        lwd=0.7, col='black')}
Data$CPAF <- cos(.hdg)*Data$CPLF - sin(.hdg)*Data$CRLF
Data$CRAF <- sin(.hdg)*Data$CPLF + cos(.hdg)*Data$CRLF
PC <- CorrectPitch(Data, .span=901)
Data$PC <- PC[, 1]
Data$RC <- PC[, 2]
op <- par (mar=c(2,4,1,1)+0.1)
with(Data[r, ], plotWAC(data.frame(Time, CPAF, PC), col=c('blue', 'red'), 
                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame pitch error'))
for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]), 
        c(Data$CPAF[r[k]]+Data$SDCPA[r[k]], Data$CPAF[r[k]]-Data$SDCPA[r[k]]), 
        lwd=0.7, col='black')}
op <- par (mar=c(5,4,1,1)+0.1)
with(Data[r, ], plotWAC(data.frame(Time, CRAF, RC), col=c('blue', 'red'), 
                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame roll error'))
for (k in seq(10, length(r), 120)) {lines(c(Data$Time[r[k]], Data$Time[r[k]]), 
        c(Data$CRAF[r[k]]+Data$SDCRA[r[k]], Data$CRAF[r[k]]-Data$SDCRA[r[k]]), 
        lwd=0.7, col='black')}
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
## save corrected values, obtained by subtracting the smoothed a-frame corrections:
Data$PITCHKF <- Data$PITCH - Data$CPAF
Data$ROLLKF <- Data$ROLL - Data$CRAF

# VC7 <- (cos(.hdg)^2*VCor[, 7] + sin (.hdg)^2*VCor[,8])
# VC7[VC7 < 0.000006] <- 0.000006
# SP <- smooth.spline(Data$Time[r], Data$CPL[r], w=1/VC7[r], spar=0.7)

## translate pitch/roll corrections to the a-frame:
.hdg <- Data$THDG * Cradeg
C7 <- SmoothInterp (Cor[, 7], .Length=181)
C8 <- SmoothInterp (Cor[, 8], .Length=181)
# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
# Data$CPITCH <- CPITCH / Cradeg
# Data$CROLL <- CROLL / Cradeg
# Data$CPITCH <- SmoothInterp (Data$CPITCH, .Length=181)
# Data$CROLL <- SmoothInterp (Data$CROLL, .Length=181)
Data$CTHDG <- SmoothInterp (Data$CTHDG, .Length=181)
Data$HC <- -CorrectHeading (Data, .plotfile='./HCPlot.pdf')
# plotWAC(subset(Data[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH CORRECTION',' [',degree,']')), 
#         ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
# CCPITCH <- Data$CPITCH
# PCC <- Data$PC
# ival <- abs(Data$ROLL) > 4
# CCPITCH[ival] <- NA
# PCC[ival] <- NA
# lineWAC(Data$Time[r], CCPITCH[r], lwd=3, col='blue')
# lineWAC(Data$Time[r], PCC[r], lwd=3, col='red')
# abline(h=0, col='darkorange', lty=2)

# with(Data[r,], plotWAC(data.frame(Time, CPL)))
# lineWAC(Data$Time[r], predict(SP, as.numeric(Data$Time))$y[r], col='red')
# lineWAC(Data$Time[r], sqrt(VC7[r])+predict(SP, as.numeric(Data$Time))$y[r], col='darkgreen')
# lineWAC(Data$Time[r], -sqrt(VC7[r])+predict(SP, as.numeric(Data$Time))$y[r], col='darkgreen')
# Y <- predict(SP, as.numeric(Data$Time))$y[r]
# plotWAC(data.frame(Data$Time[r], Y, Y+sqrt(VC7[r]), Y-sqrt(VC7[r]), Data$CPL[r]), 
#         col=c('blue', 'darkgreen', 'darkgreen', 'red'), lty=c(1,2,2,1))
# plotWAC(subset(Data[r,],,c(Time, CROLL, RC)), 
#       ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
#       ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
# Data$CROLL[ival] <- NA
# Data$RC[ival] <- NA
# lineWAC(Data$Time[r], Data$CROLL[r], lwd=3, col='blue')
# lineWAC(Data$Time[r], Data$RC[r], lwd=3, col='red')
# abline(h=0, col='darkorange', lty=2)
Data$dP <- Data$deltaPsi/Cradeg
HA <- with(Data, sqrt(LACCX^2+LACCY^2))
Data$dP[HA < 1] <- NA
sddP <- sd(Data$dP[r], na.rm=TRUE)

@

\subsubsection{Heading}

The heading angle is more difficult to handle because, for most flight
conditions, the heading is poorly constrained and some unrealistic
errors with large uncertainty are produced by the Kalman filter. The
flight pattern for the particular flight used for this example included
frequent changes in flight direction, as shown in Fig.~\ref{fig:plot-Kalman-heading1},
so those turns result in accelerations that can constrain the heading
periodically during the flight. In Sect.~\ref{subsec:heading-error},
it was argued that (\ref{eq:Hcorr}) provides an estimate of the error
in heading. However, for the full flight (excluding initial climb
and final descent) the mean value provided by this formula was \Sexpr{round(mean(Data$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}$^{\circ}$
but the standard deviation of the correction provided by this equation
was \Sexpr{round(sd(Data$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}$^{\circ}$,
so using this correction throughout the flight will likely introduce
corrections with large uncertainty. To avoid the noise and uncertainty
this would introduce, it is useful to limit the correction to those
times when horizontal accelerations are large. Figure~\ref{fig:plot-Kalman-heading2}
shows the values from (\ref{eq:Hcorr}) for those times when the horizontal
acceleration was more than 1~m\,s$^{-2}$. The mean value of $\delta\psi$
for these periods was smaller than 0.001$^{\circ}$ and the standard
deviation of the 4295 values was \Sexpr{round(sddP, 2)}. This indicates
that the uncertainty in the average error in heading is smaller than
0.01$^{\circ}$ when the average is calculated for the entire flight. 

The result for the heading error from the Kalman filter is shown as
the blue line in Fig.~\ref{fig:plot-Kalman-heading3}. The varying
correction often has large uncertainty. The thicker blue lines indicate
those regions where the Kalman-filter estimate of the covariance corresponds
to a standard deviation smaller than about 0.2$^{\circ}$. As in the
preceding plot, these regions are confined to the turns where horizontal
accelerations are significant. A smoothing spline\footnote{The ``smooth.spline()'' function provided by the ``stats'' package
in R was used, in parameter ``spar=1.1'' to give strong smoothing.} that uses weight factors inversely proportional to the covariance
leads to the red line in Fig.~\ref{fig:plot-Kalman-heading3}, for
which the mean error is $<0.002^{\circ}$ and the standard deviation
for individual measurements is about 0.02$^{\circ}$. Another check
on the heading error is provided by the correction algorithm ``Ranadu::CorrectHeading()'',
which leads to the green line in the figure. which has mean and standard
deviation \Sexpr{round(mean(Data$HC[r], na.rm=TRUE),3)}$\pm$\Sexpr{round(sd(Data$HC[r], na.rm=TRUE),3)}.
Perhaps the best interpretation for this flight is that, within about
0.02$^{\circ}$ uncertainty, there is no heading error. However, in
general the spline fit represented by the red line may be the preferable
result to use as a correction to the heading.

When applying the Kalman filter to the measurements from the INS,
it is important to recognize that the results reported by the INS
are those that have been used during its internal mechanization to
find, for example, the ground-speed vector and the l-frame accelerations.
In processed data sets, it has been common to introduce adjustments
to the heading or, less often, the pitch to improve the performance
of wind measurements during calibration maneuvers. It is particularly
common to find an offset in heading that was introduced to give better
agreement for winds during reverse-course maneuvers. However, it is
difficult to separate an offset in sideslip from an offset in heading,
as discussed in the NCAR Technical Note on uncertainty in wind measurements.
It now appears that the offset often introduced to heading should
have instead been an offset in sideslip. Because these offsets are
introduced after the INS has performed its internal calculations,
the Kalman filter has no mechanism for detecting that an offset has
been introduced and will still produce estimates of heading error
applicable to the original measurements. It is therefore important
to remove any special adjustments that have been introduced to heading
or other INS-provided variables before processing via the Kalman filter.

<<plot-Kalman-heading, include=TRUE, echo=FALSE, fig.cap=c("The flight track for DEEPWAVE flight 16, 4 July 2012. The dashed-line topography shows the South Island of New Zealand.", "Heading error estimated from (2), for only those periods of DEEPWAVE flight 16 where the horizontal acceleration is larger than 1\\ m\\,s$^{-2}$.", "Heading Correction from the Kalman filter (CTHDG) and from Ranadu::CorrectHeading (HC, green line)")>>=

DT <- getNetCDF(fname)
plotTrack(DT)
Data$dP <- Data$deltaPsi/Cradeg
HA <- with(Data, sqrt(LACCX^2+LACCY^2))
Data$dP[HA < 1] <- NA
plotWAC(subset(Data[r,],,c(Time, dP)))
sddP <- sd(Data$dP[r], na.rm=TRUE)
plotWAC(subset(Data[r, ],, c(Time, CTHDG, HC)), ylim=c(-0.4,0.4), lwd=0.7, legend.position='topright')
HE <- VCor[,9]
HE[HE < 0.00001] <- 0.00001
# lineWAC(Data$Time[r], Data$THDG[r]/1000, col='brown', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG-HE, col='magenta', lwd=0.7)
# lineWAC(Data$Time, Data$CTHDG+HE, col='magenta', lwd=0.7)
iv <- HE > 0.0012    # 0.0025
CCTHDG <- Data$CTHDG
CCTHDG[iv] <- NA
lineWAC(Data$Time[r], CCTHDG[r], lwd=3, col='blue')
SS <- smooth.spline(Data$Time[r], Data$CTHDG[r], w=1/HE[r], spar=1.1)
Data$HCS <- predict(SS, as.numeric(Data$Time))$y
lineWAC(Data$Time[r], Data$HCS[r], col='red')
Data$THDGKF <- Data$THDG - Data$HCS    ## save the corrected heading

@

\clearpage

\begin{center}
\textsf{\textcolor{blue}{\textendash{} End of Memo \textendash{}}}
\par\end{center}

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow:}}} & Workflow\Sexpr{thisFileName}.pdf\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & https://github.com/WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}


\end{document}
