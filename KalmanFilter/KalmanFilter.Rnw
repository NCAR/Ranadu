%% LyX 2.1.4 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\usepackage{babel}
\begin{document}
\EOLmemo 

\global\addressee={Wind Uncertainty TN file}  % >>change "File" to the "To:" name desired

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & A Kalman filter to apply corrections to the wind measurements\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
opts_chunk$set(fig.width=6, fig.height=5, fig.pos="center", digits=4)
thisFileName <- "KalmanFilter"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)
Directory <- DataDirectory ()
Flight <- "rf15HR" 				# XXX change this
Project = "DWIRU"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
# ReloadData <- TRUE
SaveRData <- sprintf("%s.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=33000, End=40000)
  save (Data, file=SaveRData)
} else {
  load (file=SaveRData)
}

@


\section*{Introduction and scope}

The intent of this study is to evaluate the errors present in the
measurements of attitude angles from the IRU on the NSF/NCAR~GV by
means of a Kalman filter applied to the difference between measurements
from a GPS and corresponding measurements from the IRU. The redundant
measurements are those of position and velocity, for which the GPS
measurements are clearly superior especially at low rate, so a necessary
result will be that the corrected measurements should be quite close
to those from the GPS. The advantage of this analysis, though, is
that the coupling between errors in the attitude angles and those
in velocity makes it possible to evaluate the errors in the attitude
angles also.

The approach taken here will be to use as the state vector the error
state that represents the difference between the best measurements
and those originally provided by the INS. The INS solution provides
the 9 components consisting of the position vector, the velocity vector,
and the orientation vector. To obtain these, the INS integrates the
measured accelerations and rotations from the INU. That integration
does not need to be duplicated here to obtain the reference solution.
However, the Kalman filter does need the ``state transition matrix''
that represents the forward integration, so the first step in this
analysis is to obtain such a matrix and validate results using it
against the available INS solution. 


\section*{Some component functions}

Some of the operations involved in that ``mechanization'' are contained
in the following functions, with code as in the associated R ``chunks.''
\begin{enumerate}
\item XfLA() transforms a vector from the ``aircraft'' reference frame
or the a-frame to the l-frame, the local-level frame with (x,y,z)
coordinates toward the East, North, and upward directions.
\item RotationCorrection() calculates the correction to accelerations needed
to account for the rotation of the Earth and of the l-frame relative
to an inertial frame. This function provides corrections to subtract
from transformed accelerations before using them in the l-frame.
\item STMFV() calculates the derivative of the state vector (defined below)
given the state vector and the measurements from the INU.
\end{enumerate}
<<utility-functions, include=TRUE, echo=FALSE>>=



XfLArV <- function (data) {   ## XfLA but using input in radians and single row
  # data must contain PITCH, ROLL, HEADING as components [7:9]
  cosphi <- cos (data[8])
  sinphi <- sin (data[8])
  costheta <- cos (data[7])
  sintheta <- sin (data[7])
  cospsi <- cos (data[9])
  sinpsi <- sin (data[9])
  Rbl <- c(sinpsi*costheta, cospsi*cosphi+sinpsi*sintheta*sinphi, cospsi*sinphi-sinpsi*sintheta*cosphi,
           cospsi*costheta, -sinpsi*cosphi+cospsi*sintheta*sinphi, -sinpsi*sinphi-cospsi*sintheta*cosphi,
           -sintheta, costheta*sinphi, -costheta*cosphi)
  RblM <- aperm( array (Rbl, dim=c(3,3)))
  return (RblM)
}

# other-functions ---------------------------------------------------------

Cradeg <- pi/180
dt <- 1/25               ## working with 25-Hz file
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')
Ree <- 6378137
Ecc <- 0.08181919
## The next correction calculates the correction needed to account for the rotation
## of the Earth and of the l-frame (ENU frame). See Noureldin et al., 2013, 
## Eqs. 5.55--5.57. Subtract this from the transformed accelerations before using them.
RotationCorrection <- function (.data, .V) {
  Cradeg <- pi/180
  omegaE <- StandardConstant ('Omega')  ## Earth'r angular velocity
  DL <- nrow (.data)
  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
  lat <- .data$LAT * Cradeg
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  Ree <- 6378137
  Ecc <- 0.08181919
  Rn <- Ree / (1 - (Ecc * sinLat)^2)^0.5 + .data$GGALT
  Rm <- Rn * (1 - Ecc^2) / (1 - (Ecc * sinLat)^2) + .data$GGALT
  M12 <- -2 * omegaE * sinLat - .V[,1] * tanLat / Rn
  M13 <- 2 * omegaE * cosLat + .V[,1] / Rn
  M21 <- 2 * omegaE * sinLat + .V[,1] * tanLat / Rn
  M23 <- .V[,2] / Rm
  M31 <- -2 * omegaE * cosLat - .V[,1] / Rn
  M32 <- -.V[,2] / Rm
  C[,1] <- M12 * .V[,2] + M13 * .V[,3]
  C[,2] <- M21 * .V[,1] + M23 * .V[,3]
  C[,3] <- M31 * .V[,1] + M32 * .V[,2]
  return (C)
}

Gravity <- function (latitude, altitude=0.) {
  sl2 <- (sin (latitude * Cradeg))^2
  g <- 9.780327 * ((1. + 0.001931851 * sl2) / 
                     (1. - 0.006694380 * sl2)) - 3.086e-6 * altitude
  ## Somigliana formula 1980 GRS:
  # g <- 9.7803267714 * (1 + sl2 * (5.2790414e-3 + 2.32718e-5 * sl2)) 
  #      - (3.0876910891e-6 + 4.3977311e-9 * sl2) * altitude + 7.211e-13 * altitude^2
  return(g)
}

Data$Grav <- Gravity (Data$LAT[1], Data$GGALT[1])
Re <- StandardConstant ('Re')
Data$Grav <- Data$Grav - StandardConstant('Omega')^2 * 
  (Re * sin (Data$LAT * Cradeg)^2 + Data$GGALT)

STMFV <- function (sv) { 
  stmf <- vector('numeric', length=15)
  rlm <- XfLArV(sv)    
  omega <- as.vector (c(-sv[5] / Rm, 
                        OmegaE*cos(sv[1])+sv[4]/(Rn),
                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/Rn), mode='numeric')
  Oill <- matrix (c(0, -omega[3], omega[2], omega[3], 0, -omega[1], -omega[2], omega[1], 0), ncol=3)
  Oilb <- Oill %*% rlm
  ## find the derivative of the transformation matrix:
  ## (must recalculate SRM from measured rotation rates)
  SRR <- c(0, -sv[12], -sv[10],
           sv[12], 0, sv[11],
           sv[10], -sv[11], 0)
  SRM <- aperm( array (SRR, dim=c(3,3)))
  dRLA <- rlm %*% SRM - Oilb
  DR <- c(sv[5] / Rm, sv[4] / (Rn * cos (sv[1])), sv[6])
  # G <- as.numeric (Gravity (sv[1]/Cradeg, sv[3]))    # * 0.9 improves pitch and roll!
  AA <- as.vector (c(sv[14], sv[13], sv[15]+Grav), mode='numeric') # aircraft-frame
  AL <- as.vector (rlm %*% as.matrix(AA), mode='numeric')   # l-frame
  ## now correct for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  VL <- c(sv[4], sv[5], sv[6])
  C <- vector ('numeric', 3)
  lat <- sv[1]
  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
  M12 <- -2 * OmegaE * sinLat - VL[1] * tanLat / Rn
  M13 <- 2 * OmegaE * cosLat + VL[1] / Rn
  M21 <- 2 * OmegaE * sinLat + VL[1] * tanLat / Rn
  M23 <- VL[2] / Rm
  M31 <- -2 * OmegaE * cosLat - VL[1] / Rn
  M32 <- -VL[2] / Rm
  C[1] <- M12 * VL[2] + M13 * VL[3]
  C[2] <- M21 * VL[1] + M23 * VL[3]
  C[3] <- M31 * VL[1] + M32 * VL[2]
  AL <- as.vector (AL - C, mode='numeric')
  AL[3] <- AL[3] + Grav
  AL[3] <- -AL[3]
  stmf <- c(DR, AL, -dRLA[3,1]/sqrt(1-rlm[3,1]^2), 
            1/(1+(rlm[3,2]/rlm[3,3])^2) * (rlm[3,2]/rlm[3,3]) * 
              (-dRLA[3,2]/rlm[3,2] + dRLA[3,3]/rlm[3,3]), 
            1/(1+(rlm[1,1]/rlm[1,2])^2) * (rlm[1,1]/rlm[1,2]) * 
              (dRLA[1,1]/rlm[1,1] - dRLA[1,2]/rlm[1,2]),
            0, 0, 0, 0, 0, 0)
  return (as.vector (stmf, mode='numeric'))
}

@

<<INS-data, include=TRUE, echo=FALSE>>=

SP <- with (Data, data.frame (LON, LAT, ALT, VNS, VEW, VSPD, 
                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA, BNORMA, 
                              BPITCHR, BROLLR, BYAWR,
                              GGVEW, GGVNS, Grav))
SP$BPITCHR <- SP$BPITCHR * Cradeg
SP$BROLLR <- SP$BROLLR * Cradeg
SP$BYAWR <- SP$BYAWR * Cradeg
Drot <- with (Data, data.frame (BYAWR, BPITCHR, BROLLR))

## adjustments:
Drot$BYAWR <- Drot$BYAWR - 0.005
Drot$BROLLR <- Drot$BROLLR + 0.0005
# SP$BNORMA <- SP$BNORMA*1.005 - 0.015
# SP$BLONGA <- SP$BLONGA * 0.96

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 + Data$GGALT
SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
SPR <- SP   ## save what INS produced, as reference

@


\section*{The integration steps}
\begin{enumerate}
\item Initialize a state vector $\mathbf{x}$ having these components:

\begin{enumerate}
\item latitude, longitude, altitude in the l-frame
\item east velocity, north velocity, upward velocity in the l-frame
\item pitch, roll, heading in the l-frame
\item rotation rates about the pitch, roll, and yaw axes of the aircraft
\item acceleration in the lateral, longitudinal, and normal direction relative
to the aircraft reference frame.
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item store the measured rotations and accelerations in the last 6 components
of the state vector
\item via the function STMFV, calculated the time derivative of the state
vector. In the case of the attitude angles, this is done by calculating
the derivative of the transformation matrix from the a-frame to the
l-frame and then using the definition of components of that matrix
to find the derivative of the attitude angles.
\item use that derivative vector to increment the state vector
\item compensate for possible wrap-around of the heading a 0 and 360 deg
so that values stay within that range.
\item save the first 9 components of the state vector in a new data.frame
that represents an independent ``mechanization'' of the INU measurements.
These measurements should then be in reasonable agreement with the
INS solution.
\end{enumerate}
\end{enumerate}
<<mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=

SV <- with(Data[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
SP$LAT[1] <- SV$LAT
SP$LON[1] <- SV$LON
SP$ALT[1] <- SV$ALT
SP$VEW[1] <- SV$VEW
SP$VNS[1] <- SV$VNS
SP$VSPD[1] <- SV$VSPD
SP$PITCH[1] <- SV$PITCH
SP$ROLL[1] <- SV$ROLL
SP$THDG[1] <- SV$THDG
twoPi <- 2*pi

sv <- as.vector (SV, mode='numeric')
for (i in 2:DL) {
  Rn <- SP$Rn[i]
  Rm <- SP$Rm[i]
  Grav <- SP$Grav[i]
  sv[10] <- SP$BPITCHR[i]
  sv[11] <- SP$BROLLR[i]
  sv[12] <- SP$BYAWR[i]
  sv[13] <- SP$BLATA[i]
  sv[14] <- SP$BLONGA[i]
  sv[15] <- SP$BNORMA[i]
  stmf <- STMFV (sv)
  sv <- sv + stmf * dt
  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
  SP$LAT[i] <- sv[1]
  SP$LON[i] <- sv[2] 
  SP$ALT[i] <- sv[3]
  SP$VEW[i] <- sv[4]
  SP$VNS[i] <- sv[5]
  SP$VSPD[i] <- sv[6]
  SP$PITCH[i] <- sv[7] 
  SP$ROLL[i] <- sv[8] 
  SP$THDG[i] <- sv[9]
}
SP$LAT <- SP$LAT / Cradeg
SP$LON <- SP$LON / Cradeg
SP$PITCH <- SP$PITCH / Cradeg
SP$ROLL <- SP$ROLL / Cradeg
SP$THDG <- SP$THDG / Cradeg

@

<<plot-mechanization, include=TRUE, echo=FALSE, fig.lp='fig:', fig.cap=' '>>=

op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
Data$LATX <- SP$LAT
Data$LONX <- SP$LON
Data$ALTX <- SP$ALT
plotWAC (Data[, c('Time', 'LAT', 'LATX')])
plotWAC (Data[, c('Time', 'LON', 'LONX')])
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[, c('Time', 'ALT', 'ALTX')])
Data$VEWX <- SP$VEW
Data$VNSX <- SP$VNS
Data$VSPDX <- SP$VSPD
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[, c('Time', 'VEW', 'VEWX')], legend.position='topright')
plotWAC (Data[, c('Time', 'VNS', 'VNSX')], legend.position='topright')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (Data[, c('Time', 'VSPD', 'VSPDX')])
## find attitude angles from RaLM:
Data$PITCHX <- SP$PITCH
Data$ROLLX <- SP$ROLL
Data$THDGX <- SP$THDG
Data$DPITCH <- Data$PITCHX-Data$PITCH
Data$DROLL <- (Data$ROLLX-Data$ROLL)*10
Data$DTHDG <- 180+(Data$THDGX-Data$THDG)*10
op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (Data[, c('Time', 'PITCH', 'PITCHX', 'DPITCH')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
plotWAC(Data[, c('Time', 'ROLL', 'ROLLX', 'DROLL')])
lines (c(Data$Time[1], Data$Time[DL]), c(0,0), col='green')
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC(Data[, c('Time', 'THDG', 'THDGX', 'DTHDG')], ylim=c(0,360))
lines(c(Data$Time[1], Data$Time[DL]), c(180,180), col='green')
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
SP <- SPR    ## restore to state before integration

@

The result of that integration is shown in Figs.~1--3, with comparisons
to the INS-produced solutions. There are some differences, but they
are mostly understandable and could be corrected. For example, the
attitude angles show differences in sine waves during the circles
flown during this time segment and suggest a timing error that causes
one signal to be delayed relative to the comparable signal. The INS-produced
solution for altitude has a baro-loop applied to keep the altitude
near the pressure altitude, and that is not applied in this solution
so the vertical wind and position show large drifts. Perhaps the one
aspect that is troublesome is that in VNS and consequently in latitude.
Also, the data used here are the 25-Hz records, while the INS uses
a significantly higher data rate for its corresponding integration.
The remaining differences need further investigation, but the key
result from this part of the study is that as implemented above the
derivatives of components of the state vector are approximately correct
and integrate to reasonable values. The function providing those derivatives
is therefore a reasonable basis for the Kalman filter that follows.


\section*{The Kalman filter}

The preceding steps verify that at least an approximate calculation
of the derivatives of the state variables is available. On that basis,
an error-state Kalman filter can be developed, as follows:
\begin{enumerate}
\item The first step is to initialize an error-state-vector $\delta\mathbf{x}$
from initial measurements of the differences between the INS and GPS
values of position and velocity. Other errors are unknown at the start
of the integration and so will be initialized as zero.
\item The covariance matrix characterizing the errors in the error-state-vector
is also needed. This is here initialized to have rather large components
because it is expected that the GPS measurements will have much lower
unceertainty than these INS-provided components. $\mathbf{V}$ is
initialized as a 15x15 diagonal matrix where the diagonal elements
are the squares of these values: \{2000/$R_{m}$, 2000/($R_{n}$cos$\Phi$),
500, 2, 2, 2, 0.3$^{\circ}$, 0.3$^{\circ}$, 1$^{\circ}$, 0.005$^{\circ}s^{-1}$,
0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.0005, 0.0005, 0.0005\}.
All entries are in SI units escelt those labeled as $^{\circ}$, in
which case the values are converted to radians before use. The variables
$R_{m}$ and $R_{n}$ are appropriate radii of the Earth. (See the
code) 
\item The function STMFV() was verified above and so provides at least an
approximate calculation of the derivatives of the state vector. For
an error-state Kalman filter, the propagation of the error state can
be found from the Jacobian of that function of the state vector, so
the state transition matrix is the sum of that Jacobian (multiplied
by the time step) and the 15-element diagonal matrix:\\
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\item The noise-covariance matrix $\mathbf{Q}$ represents the noise in
the solution. This is initialized as indicated in the code, via function
GCF.
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are known, the covariance matrix
can be updated via\\
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\item The Kalman gain is then given by\\
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]
where $\mathbf{H}$ is a 15X6 diagonal matrix representing how the
6 measured differences (GPS-INS) correspond to the error-state vector.
$\mathbf{R}$ is the measurement-noise-covariance matrix representing
the GPS noise, a 6x6 matrix having diagonal elements that are the
squares of these components: \{50/$R_{m}$, 50/($R_{n}\cos\Phi$,
100, 0.1, 0.1, 0.1\}.
\item Consider $\delta z$ the six measurements consisting of the differences
between GPS and INS positions and velocities. The error-state vector
is then further updated as follows:\\
\[
\delta\mathbf{x}_{k}=\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\item Finally, the covariance matrix is updated further according to\\
\[
\mathbf{V}=\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end{enumerate}
To apply these equations, it is not necessary to use a high-rate file
and update at high rate, because it is expected that the errors vary
slowly. Turns and other maneuvers can introduce spurious effects if
time delays are not adjusted well. For these reasons, a 1-Hz data
file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles as well as
the rotation rates and accelerations will be smoothed before applying
the Kalman filter. DEEPWAVE flight 16 was selected, and the measurements
were filtered with 11-s smoothing of accelerations and 301-s smoothing
of measured velocity components and attitude angles.

<<new-data, include=TRUE, echo=FALSE>>=

Flight <- "16" 				# XXX change this
Project = "DW"     			 # XXX change this
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
D1 <- getNetCDF (fname, VarList)
DL <- nrow(D1)
dt <- 1
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
Re <- StandardConstant ('Re')
D1$Grav <- D1$Grav - StandardConstant('Omega')^2 * (Re * sin (D1$LAT * Cradeg)^2 + D1$GGALT)
  #interpolate if necessary:
  MaxGap <- 1000
  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
  ggvspd <- zoo::na.approx (as.vector(D1$GGVSPD), maxgap=MaxGap, na.rm = FALSE)
  vns <- zoo::na.approx (as.vector(D1$VNS), maxgap=MaxGap, na.rm = FALSE)
  vew <- zoo::na.approx (as.vector(D1$VEW), maxgap=MaxGap, na.rm = FALSE)
  vspd <- zoo::na.approx (as.vector(D1$VSPD), maxgap=MaxGap, na.rm = FALSE)
  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
  D1$BPITCHR <- zoo::na.approx (as.vector (D1$BPITCHR), maxgap=MaxGap, na.rm=FALSE)
  D1$BROLLR <- zoo::na.approx (as.vector (D1$BROLLR), maxgap=MaxGap, na.rm=FALSE)
  D1$BYAWR <- zoo::na.approx (as.vector (D1$BYAWR), maxgap=MaxGap, na.rm=FALSE)
  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
  ## smooth the measurements
  .span <- 11    
  ## The following are accelerations determined from derivatives of the GPS velocities.
  ## These should match the measured accelerations after transformation to the l-frame
  ## and application of the rotation correction:
  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
  vudot <- signal::sgolayfilt (ggvspd, 3, .span, m=1)
  ## transform to the a-frame for comparison to the IRU:
  G <- D1$Grav
  VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
  LA <- matrix (c(vedot, vndot, -vudot - G), ncol=3) + RotationCorrection (D1, VL)
  AA <- XformLA (D1, LA, .inverse=TRUE)
  AA[,3] <- AA[,3] - G
  fa1 <- lm(D1$BLONGA ~ AA[, 1])
  fa2 <- lm(D1$BLATA ~ AA[, 2])
  fa3 <- lm(D1$BNORMA ~ AA[, 3])
  AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame 
  AL <- XformLA (D1, AB)                                    #l-frame
  ## now corrected for angular effects
  ## See Noureldin et al, 2013, Eq. (5.55)
  AL <- AL - RotationCorrection (D1, VL)
  
  ## the resulting l-frame accelerations
  D1$LACCX <- AL[, 1]
  D1$LACCY <- AL[, 2]
  D1$LACCZ <- AL[, 3] + G
  D1$LACCZ <- -D1$LACCZ
  
  ## smooth to match GPS-velocity derivatives
  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
  .span <- 301
  vns <- signal::sgolayfilt (vns, 3, .span)
  vew <- signal::sgolayfilt (vew, 3, .span)
  vspd <- signal::sgolayfilt (vspd, 3, .span)
  ggvns <- signal::sgolayfilt (ggvns, 3, .span)
  ggvew <- signal::sgolayfilt (ggvew, 3, .span)
  ggvspd <- signal::sgolayfilt (ggvspd, 3, .span)
  pitch <- signal::sgolayfilt (D1$PITCH, 3, .span)
  roll <- signal::sgolayfilt (D1$ROLL, 3, .span)
  thdg <- signal::sgolayfilt (D1$THDG, 3, .span)

D1$VNSF <- vns
D1$VEWF <- vew
D1$VSPDF <- vspd
D1$GGVNSF <- ggvns
D1$GGVEWF <- ggvew
D1$GGVSPDF <- ggvspd
D1$PITCHF <- pitch
D1$ROLLF <- roll
D1$THDGF <- thdg

fm1 <- lm (vedot ~ D1$LACCX)
fm2 <- lm (vndot ~ D1$LACCY)
fm3 <- lm (vudot ~ D1$LACCZ)

@

As a check on the uncertainty associated with the accelerometers,
the GPS measurements of velocity components were differentiated and
the resulting accelerations transformed to the a-frame and compared
to the measured accelerations from the IRU (with correction for the
Earth's rotation and the motion of the l-frame relative to an inertial
frame). For the longitudinal acceleration (along the aircraft axis),
the linear regression of the measured acceleration vs the GPS-derived
acceleration had offset \Sexpr{round(coef(fa1)[1], 4)} and slope
\Sexpr{round(coef(fa1)[2], 4)}., with a residual standard error of
\Sexpr{round(summary(fa1)$sigma, 4)}\,m\,s$^{-2}$. For the normal
component of acceleration, the corresponding values are respectively
\Sexpr{round(coef(fa3)[1], 4)}, \Sexpr{round(coef(fa3)[2], 4)}.,
and \Sexpr{round(summary(fa3)$sigma, 4)}\,m\,s$^{-2}$. These then
can be considered calibrations for the accelerometers as well as indications
of their uncertainty. \footnote{The lateral accelerations were too noisy for a similar calibration
because lateral accelerations are usually small and short-term except
during periods with significant slip, which were not present on this
flight.}

The differentiated measurements of velocity components from the GPS
might be considered as additional measurements corresponding to the
measured accelerations, but this will not be part of this initial
study because the accelerometers appear to have low uncertainty and
because the effect of errors in acceleration would also appear as
errors in velocity and so should be detected by the conventional 6-component
measurement vector for Kalman filtering.

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=


op <- par (mar=c(2,4,1,1)+0.1)
layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
plotWAC (subset(D1,, c(Time, VEW, VEWF)))
plotWAC (subset(D1,, c(Time, VNS, VNSF)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
op <- par (mar=c(2,4,1,1)+0.1)
plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
op <- par (mar=c(5,4,1,1)+0.1)
plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset

@

<<Kalman-setup, include=TRUE, echo=FALSE>>=

## also need the noise vector:
tau <- 60
GCF <- function (sv, sp) {
  gcf <- vector('numeric', length=15)
  gcf[1] <- 100 / sp$Rm
  gcf[2] <- 100 / (sp$Rn * cos (sv[1]))
  gcf[3] <- 50
  gcf[4:6] <- 0.5
  gcf[7:9] <- 0.05*Cradeg
  # gcf[1:9] <- 0
  gcf[10:12] <- 0.05*Cradeg*sqrt(2/tau)
  gcf[13:15] <- 0.002*sqrt(2/tau)
  return (gcf)
}
i <- 1
gcf <- as.numeric (GCF (SV, D1[i, ]))
# Gnoise <- gcf * rnorm(15)
# dsve <- dcm %*% SVE   # + Gnoise
# SVEP <- SVE + dt * as.vector(dsve, mode='numeric')  ## take a time step

## The measurement model:
DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEWF-GGVEWF, VNSF-GGVNSF, VSPDF-GGVSPDF))
dim(DZ) <- c(DL, 6)
DZ[,1:2] <- DZ[, 1:2] * Cradeg

## the observation matrix: (the first six components of the state error vector are observable)
H <- diag(1, nrow=6, ncol=15)

## at any time step, assume the measurements are contaminated by noise:
## GPS measurement noise
RN <- c(50/D1$Rm[1], 50/(D1$Rn[1]*cos(SV[1])), 10, 0.1, 0.1, 0.1)
RCV <- matrix (rep(0,36), ncol=6)
RCV[1,1] <- (50/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (50/(D1$Rn[1]*cos(SV[1])))^2
RCV[3,3] <- 100^2
RCV[4,4] <- 0.1^2            ## ve
RCV[5,5] <- 0.1^2
RCV[6,6] <- 0.1^2

## initialize covariance matrix
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)


@

<<Kalman-loop, include=TRUE, echo=FALSE, eval=FALSE>>=

Data <- D1
DL <- nrow (Data)
SV <- with(Data[1, ], data.frame(LAT, LON, ALT, VEWF, VNSF, VSPDF, PITCHF, ROLLF, THDGF,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
NSTEP <- 10      ## update time
SVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[1, 1:6]
SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions here
## start with zero for gyro and accelerometer errors
SVEF[1, ] <- SVE
for (i in seq(2*NSTEP, DL, by=NSTEP)) {
  SV <- with(Data[i, ], data.frame(LAT, LON, ALT, VEWF, VNSF, VSPDF, PITCHF, ROLLF, THDGF,
                                   BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- Data$Rn[i]
  Rm <- Data$Rm[i]
  Grav <- Data$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
  ## modify to include this?
## modify this to include decaying error terms for the measurements:
# dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
# dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new state vector:
  SVE <- dcm %*% SVE
  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  ## the Kalman gain:
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
}

## interpolate the results over the full data.frame:
  IntFilter <- function (X, inRate, outRate) {
    if (inRate == outRate) {return (X)}
    ratio <- as.integer(outRate/inRate)    ## expected to be an integer
    x <- 0:(length(X)-1)
    A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
    T <- A$y
    T <- signal::filter(signal::sgolay(4,75),T)
    ## now shift to match 25-Hz:
    n <- as.integer (ratio / 2)
    NL = length(T)
    T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
    return (T)
  }
  Cor <- vector('numeric', DL*15)
  dim (Cor) <- c(DL, 15)
  X <- SVEF[, 1]
  for (j in 1:15) {
    Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
  }
  Data$LATKF <- Data$LAT - Cor[, 1]/Cradeg
  Data$LONKF <- Data$LON - Cor[, 2]/Cradeg
  Data$ALTKF <- Data$ALT - Cor[, 3]
  Data$VEWKF <- Data$VEW - Cor[, 4]
  Data$VNSKF <- Data$VNS - Cor[, 5]
  Data$VSPDKF <- Data$VSPD - Cor[, 6]
  Data$PITCHKF <- Data$PITCH - Cor[, 7]/Cradeg
  Data$ROLLKF <- Data$ROLL - Cor[, 8]/Cradeg
  Data$THDGKF <- Data$THDG - Cor[, 9]/Cradeg
  Data$BPITCHRKF <- Data$BPITCHR - Cor[, 10]/Cradeg
  Data$BROLLRKF <- Data$BROLLR - Cor[, 11]/Cradeg
  Data$BYAWRKF <- Data$BYAWR - Cor[, 12]/Cradeg
  Data$BLATAKF <- Data$BLATA - Cor[, 13]
  Data$BLONGAKF <- Data$BLONGA - Cor[, 14]
  Data$BNORMAKF <- Data$BNORMA - Cor[, 15]

  Data$DVEW <- Data$VEWKF-Data$GGVEW
Data$DVNS <- Data$VNSKF-Data$GGVNS
Data$DVSPD <- Data$VSPD-Data$GGVSPD
Data$DVSPD <- Data$VSPDKF-Data$GGVSPD
Data$DPITCH <- Data$PITCH-Data$PITCHKF
Data$DROLL <- Data$ROLL-Data$ROLLKF
Data$DTHDG <- Data$THDG-Data$THDGKF
Data$PC <- -CorrectPitch(Data, .span=301)[,1]
plotWAC(subset(Data[setRange(Data, 70000, 123000),],,c(Time, DPITCH, PC)))

@

\clearpage

\begin{center}
\textsf{\textcolor{blue}{-- End of Memo --}}
\par\end{center}

Reproducibility:

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & \Sexpr{thisFileName}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \Sexpr{thisFileName}.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \Sexpr{thisFileName}.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & /scr/raf\_data/\Sexpr{Project}/\Sexpr{Flight}.nc \tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow:}}} & Workflow\Sexpr{thisFileName}.pdf\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & https://github.com/WilliamCooper/\Sexpr{thisFileName}.git\tabularnewline
\end{tabular}

%\cc{first attachment\\second\\3rd att}
\end{document}
