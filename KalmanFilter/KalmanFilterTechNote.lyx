#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}


\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package babel
\inputencoding auto
\fontencoding T1
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command makeindex
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Technical Note: Kalman Filter"
\pdf_author "William A. Cooper"
\pdf_subject "improvement of  wind measurements, GV"
\pdf_keywords "Kalman, wind,uncertainty, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle false
\papersize letterpaper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 2
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices true
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\backgroundcolor #ffffff
\boxbgcolor #f7f7f7
\index Index
\shortcut idx
\color #008000
\end_index
\index Variable Names
\shortcut var
\color #00aaff
\end_index
\index List of Symbols
\shortcut lis
\color #ff0000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
A Kalman Filter 
\begin_inset Newline newline
\end_inset

 to Improve
\begin_inset Newline newline
\end_inset

Measurements of Wind
\begin_inset Newline newline
\end_inset

 from the 
\begin_inset Newline newline
\end_inset

NSF/NCAR Gulfstream V Research Aircraft
\end_layout

\begin_layout Author
William A.
 Cooper
\end_layout

\begin_layout Date

\color red
DRAFT
\color inherit
 1/23/2017
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset

 
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% LyX 2.2.2 created this file.
  For more info, see http://www.lyx.org/.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
A recent Technical Note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) discussed the uncertainty
\begin_inset Index idx
status open

\begin_layout Plain Layout
uncertainty
\end_layout

\end_inset

 associated with measurements of wind from the NSF/NCAR Gulfstream V research
 aircraft, hereafter called the GV.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Gulfstream V
\end_layout

\end_inset

 aircraft is owned by the National Science Foundation and operated by the
 Research Aviation Facility (RAF), Earth Observing Laboratory (EOL), National
 Center for Atmospheric Research (NCAR).
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
NSF/NCAR GV
\end_layout

\end_inset

 The components and algorithms that comprise the wind-measuring system on
 the GV were documented in that reference, so that information will not
 be repeated here.
 The central content of that technical note was a detailed analysis of uncertain
ty for the wind measurements.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
standard uncertainty
\end_layout

\end_inset

standard uncertainty was estimated to be about 0.1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 for vertical wind and 0.4
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 for each component of the horizontal wind.
 These estimates were based on the analyzed performance of the inertial
 navigation system, and are lower than would be expected from direct specificati
ons for that system.
 The largest contributions to uncertainty were associated with the measurements
 of pitch and heading, for respectively the vertical and horizontal wind
 components.
 Improvement in the measurements of these attitude angles therefore is the
 indicated step toward improved measurements of wind.
\end_layout

\begin_layout Standard
Two approaches are taken in the present technical note to improve the measuremen
ts of pitch and heading.
 The first uses a simplified analysis of the strong coupling
\begin_inset Index idx
status open

\begin_layout Plain Layout
strong coupling
\end_layout

\end_inset

 represented by the Schuler oscillation
\begin_inset Index idx
status open

\begin_layout Plain Layout
Schuler oscillation
\end_layout

\end_inset

 to evaluate errors in pitch and couples this with a related analysis to
 find the correction in heading.
 The second implements a full error-state Kalman filter to produce adjusted
 measurements of the attitude angles and also the ground-speed components
 and rate-of-climb of the aircraft.
 The agreement between these two methods then supports the validity of each,
 while the first provides a much simpler method for determining the corrections.
\end_layout

\begin_layout Standard
This introduction will present a brief discussion of the steps involved
 in using an error-state Kalman filter to update measurements from the inertial
 systems on the aircraft (which do not have internal Kalman filters) using
 reference measurements from a GPS receiver.
 The results from the GPS receiver are very good for aircraft position and
 velocity, so the Kalman filter adds little to these measurements.
 The primary value of the Kalman filter presented here is that it improves
 the measurements of pitch and heading.
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset

2 will then develop expressions for the derivatives of the primary measurements
 from the inertial navigation system (INS) and will show that these derivatives
 provide a reasonable basis for mechanization,
\begin_inset Index idx
status open

\begin_layout Plain Layout
mechanization
\end_layout

\end_inset

 i.e., calculating the history of the position, velocity, and attitude angles
 of the aircraft from the basic measurements provided by the inertial reference
 unit (IRU).
\begin_inset Foot
status open

\begin_layout Plain Layout
In this document, the IRU will refer to the portion of the instrument that
 produces the basic measurements of body acceleration and body rotation
 rate, while the INS will refer to the full system that uses those basic
 measurements to propagate the location, velocity, and attitude angles of
 the aircraft forward in time from an initial state determined during alignment
 of the instrument.
\end_layout

\end_inset

 Those measurements are the vector rotation rate and vector acceleration
 of the aircraft in an inertial frame, so the test of the calculated derivatives
 is that the results for the 
\begin_inset Quotes eld
\end_inset

state vector
\begin_inset Quotes erd
\end_inset

 (consisting of position, velocity, and attitude angles of the aircraft)
 are in reasonable agreement with the values provided by the INS.
 The importance of this step is that the validated state-vector derivative
 then will be used in implementation of the error-state Kalman filter.
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset

3 is a diversion from the main development of this technical note.
 It contains several ancillary topics:, (i) defining a new variable representing
 the rate of climb of the aircraft that is an improvement over the measurement
 provided by the INS; (ii) determining the IRU-provided measurements of
 rotation and acceleration by differentiating the recorded attitude angles;
 (iii) Simplified algorithms for finding the errors in pitch and heading;
 and (iv) a revision to the empirical representation of angle of attack.
 The first is useful because the INS inherently updates the variable representin
g the vertical speed of the aircraft by comparison to the pressure altitude,
 while the measurement of wind needs a variable representing the rate of
 change in geometric altitude.
 The second topic is useful because, for many of the early projects with
 the GV, the body rotations and body accelerations were not recorded, yet
 they are needed by the Kalman filter.
 Reconstructing them makes it possible to process those older projects or
 even to process from the standard data archives, which normally do not
 include the body rotations and body accelerations.
 The third topic provides a complementary approach to finding the same errors
 in attitude angles that the Kalman filter will produce.
 It will provide a useful check on the results from that filter.
 Finally, Sect.
\begin_inset space ~
\end_inset

3.4 extends the discussion of sensitivity coefficients contained in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

 by presenting a new empirical representation that has advantages over the
 method used previously.
 Improved pitch measurements lead to improved determination of the coefficients
 used in this empirical representation, so that is an added benefit of the
 Kalman filter.
 All these will find important uses in the implementation of the Kalman
 filter or the new calculation of wind that is based on the corrections
 it provides.
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset

4 then discusses the details of the Kalman filter.
 A script based on the programming language R has been developed to calculate
 the estimated errors from the Kalman filter, apply the indicated corrections
 to the measured state vector, and add those new variables to the standard
 netCDF data file.
 This section includes discussion of the aspects of that code that represent
 the Kalman filter.
 The results are shown and compared to reference results and to the alternate
 methods of determining the pitch and heading corrections as discussed in
 Sect.
\begin_inset space ~
\end_inset

3.
 
\end_layout

\begin_layout Standard
Section 5 the presents results from calculating the wind using the corrected
 state vector.
 The conclusion of this section is a summary of the value of the Kalman
 filter and so serves as a conclusion to the report.
\end_layout

\begin_layout Standard
Several steps have been taken with the goal of making this work internally
 documented and reproducible, as discussed in the Appendix.
 The program that produces this document (via LaTeX), named KalmanFilterTechNote.
Rnw,
\begin_inset Index idx
status open

\begin_layout Plain Layout
program file
\end_layout

\end_inset

 also performs all the calculations, generates the figures (with a few exception
s) and quoted results, and produces the new archive file, so that file contains
 everything needed to reproduce this work.
 Subsets of the data files are also preserved and made available.
 Another document, called the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
workflow document
\end_layout

\end_inset

workflow document (KalmanFilterWorkflow.pdf) accompanies this technical note
 and the primary program file.
 It serves several purposes, primarily to elaborate upon the material in
 the present document.
 Some of the derivations are justified in more detail, and instructions
 are provided for running the R script to added the corrected variables
 to a netCDF file.
 Some details of how that modification of an existing file is done are included
 in the workflow document, and there is also some discussion of methods
 that were explored but abandoned.
 The workflow document should provide valuable information to anyone wanting
 to modify the R script.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Initialization.R
\end_layout

\begin_layout Plain Layout

# version as of 160110; note that source statement in header over-rides
 this code
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages, specifies the file used for
 the illustration
\end_layout

\begin_layout Plain Layout

## of mechanization, specifies the variables needed from the archive file,
 and
\end_layout

\begin_layout Plain Layout

## specifies some time shifts.
 The data file used here is not part of the standard
\end_layout

\begin_layout Plain Layout

## archives.
 It was produced specially to provide high-rate values of the measured
\end_layout

\begin_layout Plain Layout

## variables, and it is therefore preserved in .Rdata format so that file
 can be
\end_layout

\begin_layout Plain Layout

## archived and re-used to ensure reproducibility.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## chunk "initialization.R"
\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "KalmanFilterTechNote"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## needed for the jacobian() function
\end_layout

\begin_layout Plain Layout

library(signal)
\end_layout

\begin_layout Plain Layout

library(reshape2)
\end_layout

\begin_layout Plain Layout

library(grid)
\end_layout

\begin_layout Plain Layout

options(stringsAsFactors=FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## temporary; remove once Ranadu is updated
\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/theme_WAC2.R')
\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/getNetCDF.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/Ranadu/KalmanFilter')
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "rf15HR" 			
\end_layout

\begin_layout Plain Layout

Project = "DWIRU"     		
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, VarList, Start=31000, End=40000)
\end_layout

\begin_layout Plain Layout

  ## remove heading adjustments if added during initial processing
\end_layout

\begin_layout Plain Layout

  Z <- data.frame(getAttributes(Data$THDG, .print=FALSE))
\end_layout

\begin_layout Plain Layout

  if ('CalibrationCoefficients' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

    THDGoffset <- Z$CalibrationCoefficients[1]
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    THDGoffset <- 0
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ## re signs: assumed lag has been corrected, so use - sign to remove
\end_layout

\begin_layout Plain Layout

  if ('TimeLag' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

    Data$THDG <- ShiftInTime(Data$THDG, .rate=25, .shift=-Z$TimeLag[1])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data$THDG <- (Data$THDG - THDGoffset) %% 360
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

## Remove time lags imposed during processing:
\end_layout

\begin_layout Plain Layout

for (V in VarList) {
\end_layout

\begin_layout Plain Layout

  if (V == 'THDG') {next}
\end_layout

\begin_layout Plain Layout

  Z <- data.frame(getAttributes(Data[, V], .print=FALSE))
\end_layout

\begin_layout Plain Layout

  ## re signs: assumed lag has been corrected, so use - sign to remove
\end_layout

\begin_layout Plain Layout

  if ('TimeLag' %in% names(Z)) {
\end_layout

\begin_layout Plain Layout

    Data[, V] <- ShiftInTime(Data[, V], .rate=25, .shift=-Z$TimeLag[1])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# .shift <- -70
\end_layout

\begin_layout Plain Layout

VV <- c('BLONGA', 'BLATA', 'BNORMA')
\end_layout

\begin_layout Plain Layout

.shift <- c(-50,-50,-50)
\end_layout

\begin_layout Plain Layout

names(.shift) <- VV
\end_layout

\begin_layout Plain Layout

for (V in VV) {
\end_layout

\begin_layout Plain Layout

  Data[, V] <- ShiftInTime (Data[, V], 25, .shift[V])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Data[, 'VSPD'] <- ShiftInTime (Data[, 'VSPD'], 25, 40)
\end_layout

\begin_layout Plain Layout

# Data[, 'VEW'] <- ShiftInTime (Data[, 'VEW'], 25, 60)
\end_layout

\begin_layout Plain Layout

# Data[, 'VNS'] <- ShiftInTime (Data[, 'VNS'], 25, 60)
\end_layout

\begin_layout Plain Layout

Data[, 'PITCH'] <- ShiftInTime (Data[, 'PITCH'], 25, 20)
\end_layout

\begin_layout Plain Layout

Data[, 'ROLL'] <- ShiftInTime (Data[, 'ROLL'], 25, 20)
\end_layout

\begin_layout Plain Layout

.shift = 60
\end_layout

\begin_layout Plain Layout

## Get some derivatives used later (but better value are obtained later
\end_layout

\begin_layout Plain Layout

## via Savitzgy-Golay polynomials.)
\end_layout

\begin_layout Plain Layout

Rate <- attr (Data, 'Rate')
\end_layout

\begin_layout Plain Layout

Data$pdot <- c(0, diff (Data$PITCH)) * Rate
\end_layout

\begin_layout Plain Layout

Data$rdot <- c(0, diff (Data$ROLL)) * Rate
\end_layout

\begin_layout Plain Layout

Data$hdot <- c(0, diff (Data$THDG))
\end_layout

\begin_layout Plain Layout

Data$hdot <- (Data$hdot + 540) %% 360 - 180
\end_layout

\begin_layout Plain Layout

Data$hdot <- Data$hdot * Rate
\end_layout

\begin_layout Plain Layout

shift <- -500 / Rate
\end_layout

\begin_layout Plain Layout

Data$pdot <- ShiftInTime (Data$pdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

Data$rdot <- ShiftInTime (Data$rdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

Data$hdot <- ShiftInTime (Data$hdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Brief summary of the Kalman filter
\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kalman filter
\end_layout

\end_inset

Kalman filter provides a means of updating a sequence of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
state vector
\end_layout

\end_inset

state vectors (consisting, in the present case, of INS measurements of position,
 velocity, and attitude angles) by comparison to an independent set of measureme
nts (e.g., GPS-derived measurements of position and velocity).
 The updated state vector obtained by this process consists of an appropriately
 weighted combination of the state vector projected forward using normal
 INS 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 (i.e., determining the next step by using the measured acceleration and rotation
 from the IRU) and the independent measurements from GPS.
 Because errors in the state vector are coupled, the update procedure can
 estimate errors in the attitude angles as well as the components of the
 state vector that are measured directly by the GPS.
 This is the primary reason for using a Kalman filter to improve the wind
 measurements: Although the measurements of position and velocity that result
 should differ little from those provided by the GPS, appropriate corrections
 to the attitude angles (pitch, roll, and heading) can be estimated even
 though there is no direct measurement of these except from the INS.
\end_layout

\begin_layout Standard
The weighting of the projected-forward state and new measurements from GPS
 depends on obtaining estimates of the covariance matrix describing the
 state vector as well as estimates of the noise sources contaminating the
 measurements from both the GPS and the IRU-provided accelerations and rotations.
 With proper weighting, the result should combine the good high-frequency
 response of the INS with the good long-term stability of the GPS.
 The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
covariance matrix
\end_layout

\end_inset

covariance matrix characterizing the state vector is updated as the filter
 is applied, but appropriate weighting depends on reasonable estimation
 of the other error terms.
\end_layout

\begin_layout Standard
The operation of the filter depends on sequential use of a set of matrices,
 so it is useful to define those as follows, where the variable names following
 the symbols are the R variable names used in the R code:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{x}_{k}$
\end_inset


\begin_inset space ~
\end_inset

[SVE] The error-state vector
\begin_inset Index idx
status open

\begin_layout Plain Layout
error-state vector
\end_layout

\end_inset

 at time index 
\begin_inset Formula $k$
\end_inset

.
 In the present case, this consists of these 15 components: estimated errors
 in position, aircraft velocity, aircraft attitude, IRU-measured rotation
 rate, and IRU-measured accelerations.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{T}_{k|k-1}$
\end_inset


\begin_inset space ~
\end_inset

[dcm] The 15x15 state transition matrix
\begin_inset Index idx
status open

\begin_layout Plain Layout
state transition matrix
\end_layout

\end_inset

 describing INS mechanization
\begin_inset Index idx
status open

\begin_layout Plain Layout
mechanization
\end_layout

\end_inset

 for the change from time 
\begin_inset Formula $k-1$
\end_inset

 to time 
\begin_inset Formula $k$
\end_inset

.
 Then 
\begin_inset Formula $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
\end_inset

 where 
\begin_inset Formula $\mathbf{T}$
\end_inset

 combines the unit diagonal matrix with the time step multiplied by the
 derivative matrix describing the state transformation.
 As applied to the state vector, this state transformation matrix would
 involve the derivatives used for normal INS mechanization to advance the
 state vector, and so would duplicate the action of the internal INS data
 processing.
 As interpreted for an error-state Kalman filter, the matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is obtained by calculating the Jacobian of that state-transition function
 as a function of the error-state components.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{V}$
\end_inset


\begin_inset space ~
\end_inset

[CV] The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
covariance matrix
\end_layout

\end_inset

covariance matrix that applies to the state vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

, a 15x15 matrix
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{K}$
\end_inset


\begin_inset space ~
\end_inset

[K] The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
Kalman-gain matrix
\end_layout

\end_inset

Kalman-gain matrix representing how the error-state vector is updated using
 the current error state and the new GPS measurements.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\delta\mathbf{z}$
\end_inset


\begin_inset space ~
\end_inset

[DZ] The 6-component measured differences between the INS and GPS measurements
 of position and velocity.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{H}$
\end_inset


\begin_inset space ~
\end_inset

[H] The 15x6-component matrix representing how the measured differences
 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 correspond to the state vector.
 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
\begin_inset Formula $\mathbf{Q},\,\mathbf{R}$
\end_inset


\begin_inset space ~
\end_inset

[Q,
\begin_inset space ~
\end_inset

R] Matrices representing respectively the anticipated noise contributions
 affecting the error-state vector (15x15) and the measurements from the
 GPS (6x6).
\begin_inset Index idx
status open

\begin_layout Plain Layout
noise|measurement
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The approach taken here will be to filter the error-state vector that represents
 the difference between the best-estimate measurements and those originally
 provided by the INS.
 The INS integration does not need to be duplicated here to obtain the reference
 solution because that is already available.
 However, the Kalman filter does need the 
\begin_inset Quotes eld
\end_inset

state transition matrix
\begin_inset Quotes erd
\end_inset

 that represents the forward integration, so the first step in this analysis
 is to obtain such a matrix and validate results using it against the available
 INS solution.
 The Jacobian
\begin_inset Index idx
status open

\begin_layout Plain Layout
Jacobian
\end_layout

\end_inset

 of that state-transition function then provides the matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 later used in this filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<utility-functions, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## check the rate of the file
\end_layout

\begin_layout Plain Layout

# ATT <- getAttributes(Data, .print=FALSE)
\end_layout

\begin_layout Plain Layout

# Rate <- DataFileInfo (fname)$Rate  ## only rates 1 and 25 supported
\end_layout

\begin_layout Plain Layout

dt <- 1/Rate               
\end_layout

\begin_layout Plain Layout

DL <- nrow(Data)
\end_layout

\begin_layout Plain Layout

OmegaE <- StandardConstant ('Omega')  ## Earth's rotation rate
\end_layout

\begin_layout Plain Layout

OmegaE <- 15*Cradeg/3600              ## better match to INS?
\end_layout

\begin_layout Plain Layout

Ree <- 6378137                        ## for radii of curvature
\end_layout

\begin_layout Plain Layout

Ecc <- 0.08181919
\end_layout

\begin_layout Plain Layout

Data$Grav <- Gravity (Data$LAT, Data$GGALT)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source ('chunks/RotationCorrection.R')
\end_layout

\begin_layout Plain Layout

source ('chunks/STMFV.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<INS-data, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

r <- setRange (Data, 31000, 35500)
\end_layout

\begin_layout Plain Layout

Data <- Data[r,]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
The derivative of the state vector
\end_layout

\begin_layout Subsection
The procedure to be used
\begin_inset CommandInset label
LatexCommand label
name "subsec:mech-procedures"

\end_inset


\end_layout

\begin_layout Standard
The state vector used in this section will consist of the three components
 of position, three components of aircraft motion relative to the Earth,
 and three attitude angles.
 In later sections a different vector, the error-state vector, will be used
 for the Kalman filter, and in that case three components of measured rotation
 rate and three components of measured acceleration will be added to the
 state vector so that the Kalman filter can treat the possibility of error
 in the latter six components as well as the first nine.
 However, the purpose of this section is to develop expressions for the
 derivatives of the nine-component state vector in terms of the IRU-provided
 measurements of rotation rates and accelerations and to demonstrate that
 the calculated derivatives lead to a reasonable 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 that approximately duplicates the original calculations from the INS.
 It is not necessary or expected that this mechanization will produce an
 exact duplicate of the INS mechanization because the INS has calibration
 information and high-rate data not available to this new calculation.
 However, if the results are reasonably close to those from the INS then
 that provides some evidence that the derivatives being calculated are reeasonab
ly close to the correct values.
 These derivatives will then be used in the implementation of the Kalman
 filter, where the filter will adjust to compensate for remaining errors
 in these derivatives.
 
\end_layout

\begin_layout Standard
The procedure used to produce variables corresponding to position, velocity,
 and attitude angles for this test is as follows:
\end_layout

\begin_layout Enumerate
Initialize a state vector 
\begin_inset Formula $\mathbf{x}$
\end_inset

 having these components:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
latitude, longitude, altitude in the l-frame, the reference frame relative
 to the Earth that has east, north, and upward axes at the location of the
 aircraft;
\end_layout

\begin_layout Enumerate
east, north, and upward velocity in the l-frame
\end_layout

\begin_layout Enumerate
pitch, roll, heading in the a-frame
\begin_inset Foot
status open

\begin_layout Plain Layout
With appropriate transformations these calculations of attitude angles can
 be performed in the l-frame instead, and there are some advantages because
 the l-frame values of errors in pitch and roll, respectively representing
 southward and westward tilts of the inertial platform, are not mixed together
 when the heading changes as they are in the a-frame.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
For each time increment:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
calculated the time derivative of the state vector.
 In the case of the attitude angles, this is done by calculating the derivative
 of the transformation matrix from the a-frame to the l-frame and then using
 the definition of components of that matrix to find the derivative of the
 attitude angles.
\end_layout

\begin_layout Enumerate
use that derivative vector to increment the state vector, compensating for
 possible wrap-around of the heading at 0 and 360 deg so that values stay
 within that range.
\end_layout

\begin_layout Enumerate
save the 9 components of the state vector in a new tabulation that represents
 an independent 
\begin_inset Quotes eld
\end_inset

mechanization
\begin_inset Quotes erd
\end_inset

 of the INU measurements.
 These measurements should then be in reasonable agreement with the INS
 solution.
\end_layout

\end_deeper
\begin_layout Subsection
The components of the derivative array
\begin_inset CommandInset label
LatexCommand label
name "subsec:deriv-array"

\end_inset


\end_layout

\begin_layout Standard
The derivatives are calculated as follows:
\end_layout

\begin_layout Enumerate
The position derivatives are determined from the components of the velocity,
 {
\begin_inset Formula $v_{e},\,v_{n},\,v_{z}$
\end_inset

}.
 The changes in latitude and longitude depend on the normal and meridional
 radii of curvature of the Earth, respectively denoted 
\begin_inset Formula $R_{n}$
\end_inset

 and 
\begin_inset Formula $R_{m}$
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, pp.
\begin_inset space ~
\end_inset

47–48, provide definitions of these radii and a detailed derivation.
 The derivatives of latitude 
\begin_inset Formula $\lambda$
\end_inset

 and longitude 
\begin_inset Formula $\Phi$
\end_inset

 are then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{eqnarray}
\dot{\lambda} & = & \frac{v_{n}}{R_{m}}\label{eq:dlat}\\
\dot{\Phi} & = & \frac{v_{e}}{R_{n}\cos\lambda}\label{eq:dlong}
\end{eqnarray}

\end_inset

and the derivative of the altitude is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{eqnarray}
\dot{z} & = & v_{z}\label{eq:dz}
\end{eqnarray}

\end_inset

where dots over quantities denote the time derivative.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Enumerate
The velocity derivatives are determined from the measured accelerations,
 but the accelerations are measured in the a-frame, with axes such that
 the unit coordinates are 
\begin_inset Formula $\hat{x}$
\end_inset

 forward along the longitudinal axis of the aircraft, 
\begin_inset Formula $\hat{y}$
\end_inset

 starboard in the direction of the right wing, and 
\begin_inset Formula $\hat{z}$
\end_inset

 along the direction determined by their cross product and generally downward.
 These measurements of acceleration must be transformed to the l-frame where
 the velocities are defined, using the attitude angles for pitch, roll,
 and heading, denoted {
\begin_inset Formula $\theta,\,\phi,\,\psi$
\end_inset

}.
 In addition, because the accelerations are measured in an inertial frame,
 corrections must be made for the inertial forces that arise because the
 l-frame is moving relative to the Earth and so it changing orientation,
 and because the rotation of the Earth introduces additional Coriolis accelerati
ons relative to an inertial frame.
 The coordinate transformation matrix that transforms a vector from the
 a-frame to the l-frame will be denoted 
\begin_inset Formula $\mathbf{R}_{a}^{l}$
\end_inset

 and consists of four sequential transformations, first a rotation by 
\begin_inset Formula $\phi$
\end_inset

 about the roll axis, then a rotation by 
\begin_inset Formula $\theta$
\end_inset

 about the pitch axis, then a rotation by 
\begin_inset Formula $\psi$
\end_inset

 about the resulting 
\begin_inset Formula $\hat{z}$
\end_inset

 axis, and finally exchange of the 
\begin_inset Formula $\hat{x}$
\end_inset

 and 
\begin_inset Formula $\hat{y}$
\end_inset

 components and reversal of the sign of the 
\begin_inset Formula $\hat{z}$
\end_inset

 component to change to the l-frame coordinate system.
 The transformation was presented in detail by 
\begin_inset CommandInset citation
LatexCommand citet
key "Bulletin23"

\end_inset

, and is also specified and developed in the workflow document that accompanies
 this technical note.
 The a-frame measurements of acceleration are transformed to the l-frame
 using this transformation matrix, but only after the acceleration of gravity
 is added to the normal component because the IRU reports the normal component
 of gravity as that with the acceleration of gravity subtracted.
 Then the transformed accelerations are corrected for apparent forces generated
 by the inertial forces.
 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, pp.
\begin_inset space ~
\end_inset

178–179, give the equations used, and these are repeated in the workflow
 document and are coded into the transformation function 
\begin_inset Quotes eld
\end_inset

STMFV
\begin_inset space ~
\end_inset

()
\begin_inset Quotes erd
\end_inset

 in the R code embedded in the program that generates this document.
\end_layout

\begin_layout Enumerate
Calculating the derivatives of the attitude angles is more involved.
 The attitude angles can be found if the transformation matrix 
\begin_inset Formula $\mathbf{R}_{a}^{l}$
\end_inset

 is known by using the definitions of the components of that matrix in terms
 of the attitude angles.
 For example, the [3.1] component of that matrix is 
\begin_inset Formula $-\sin\theta$
\end_inset

, so 
\begin_inset Formula $\theta=-\arcsin(R_{a}^{l}[3,1])$
\end_inset

.
 The measured rotation rates, transformed to the l-frame, give the derivative
 of the transformation matrix, except that again corrections for inertial
 effects arising from the Earth's rotation and the motion of the l-frame
 are needed.
 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, pp.
\begin_inset space ~
\end_inset

179–180, also provide the required correction for the derivative of the
 transformation matrix, as documented further in the workflow document and
 the code.
 
\end_layout

\begin_layout Standard
The function 
\begin_inset Quotes eld
\end_inset

STMFV
\begin_inset space ~
\end_inset

()
\begin_inset Quotes erd
\end_inset

 returns these derivatives, given the state vector and the measurements
 from the IRU.
 The procedures and code are complicated enough that verification is important,
 so several tests are made of the results in the remainder of this section.
\end_layout

\begin_layout Subsection
Tests of the derivatives
\end_layout

\begin_layout Subsubsection
Checking the transformed accelerations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Checking-accelerations"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<check-accelerations, include=TRUE, digits=4, fig.cap='', cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

options(scipen = 1, digits = 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1 <- Data  ## temporary; avoid making changes to the reference data.frame
\end_layout

\begin_layout Plain Layout

D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5 + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
\end_layout

\begin_layout Plain Layout

D1$Grav <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch (D1)
\end_layout

\begin_layout Plain Layout

# D1$PITCH <- D1$PITCH - PC[, 1]
\end_layout

\begin_layout Plain Layout

# D1$ROLL <- D1$ROLL - PC[, 2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## adjust GPS velocity components for GPS antenna location
\end_layout

\begin_layout Plain Layout

LG <- -4.30 
\end_layout

\begin_layout Plain Layout

# D1$GGVEW <- D1$GGVEW - LG * D1$hdot * cos(D1$ROLL*Cradeg) * sin(D1$THDG*Cradeg
) * Cradeg
\end_layout

\begin_layout Plain Layout

# D1$GGVNS <- D1$GGVNS + LG * D1$hdot * cos(D1$ROLL*Cradeg) * cos(D1$THDG*Cradeg
) * Cradeg
\end_layout

\begin_layout Plain Layout

# D1$GGVSPD <- D1$GGVSPD - LG * (D1$pdot + D1$hdot * sin(D1$ROLL*Cradeg))
 * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#interpolate if necessary: otherwise later filters fail
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

for (V in c('GGVNS', 'GGVEW', 'GGVSPD', 'VNS', 'VEW', 'VSPD')) {
\end_layout

\begin_layout Plain Layout

  D1[, V] <- zoo::na.approx (as.vector (D1[, V]), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## smooth the measurements when determining derivatives
\end_layout

\begin_layout Plain Layout

.span <- 25    
\end_layout

\begin_layout Plain Layout

## The following are accelerations determined from derivatives of the INS
 and GPS velocities.
\end_layout

\begin_layout Plain Layout

## These should match the measured accelerations after transformation to
 the l-frame
\end_layout

\begin_layout Plain Layout

## and application of the rotation correction:
\end_layout

\begin_layout Plain Layout

D1$vndot <- signal::sgolayfilt (D1$GGVNS, 3, .span, m=1) * Rate  # m=1 for
 first deriv.
\end_layout

\begin_layout Plain Layout

D1$vedot <- signal::sgolayfilt (D1$GGVEW, 3, .span, m=1) * Rate
\end_layout

\begin_layout Plain Layout

D1$vudot <- signal::sgolayfilt (D1$GGVSPD, 3, .span, m=1) * Rate
\end_layout

\begin_layout Plain Layout

D1$vndot2 <- signal::sgolayfilt (D1$VNS, 3, .span, m=1) * Rate  # m=1 for
 first deriv.
\end_layout

\begin_layout Plain Layout

D1$vedot2 <- signal::sgolayfilt (D1$VEW, 3, .span, m=1) * Rate
\end_layout

\begin_layout Plain Layout

D1$vudot2 <- signal::sgolayfilt (D1$VSPD, 3, .span, m=1) * Rate
\end_layout

\begin_layout Plain Layout

## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

G <- D1$Grav
\end_layout

\begin_layout Plain Layout

VL <- matrix(c(D1$GGVEW, D1$GGVNS, D1$GGVSPD), ncol=3)
\end_layout

\begin_layout Plain Layout

VL2 <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3)
\end_layout

\begin_layout Plain Layout

LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection
 (D1, VL) 
\end_layout

\begin_layout Plain Layout

LA2 <- matrix (c(D1$vedot2, D1$vndot2, -D1$vudot2 - G), ncol=3) + RotationCorrec
tion (D1, VL2)
\end_layout

\begin_layout Plain Layout

AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA2 <- XformLA (D1, LA2, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA[,3] <- AA[,3] - G
\end_layout

\begin_layout Plain Layout

AA2[,3] <- AA2[,3] - G
\end_layout

\begin_layout Plain Layout

fa1 <- lm(AA[, 1] ~ D1$BLONGA)
\end_layout

\begin_layout Plain Layout

fa2 <- lm(AA[, 2] ~ D1$BLATA)
\end_layout

\begin_layout Plain Layout

fa3 <- lm(AA[, 3] ~ D1$BNORMA)
\end_layout

\begin_layout Plain Layout

fb1 <- lm(AA2[, 1] ~ D1$BLONGA)
\end_layout

\begin_layout Plain Layout

fb2 <- lm(AA2[, 2] ~ D1$BLATA)
\end_layout

\begin_layout Plain Layout

fb3 <- lm(AA2[, 3] ~ D1$BNORMA)
\end_layout

\begin_layout Plain Layout

cfa1 <- coef(fa1); cfa2 <- coef(fa2); cfa3 <- coef(fa3)
\end_layout

\begin_layout Plain Layout

D1$BLONGA <- cfa1[1] + cfa1[2] * Data$BLONGA
\end_layout

\begin_layout Plain Layout

D1$BLATA  <- cfa2[1] + cfa2[2] * Data$BLATA
\end_layout

\begin_layout Plain Layout

D1$BNORMA <- cfa3[1] + cfa3[2] * Data$BNORMA
\end_layout

\begin_layout Plain Layout

AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #a-frame 
\end_layout

\begin_layout Plain Layout

AL <- XformLA (D1, AB)                                    #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

RC <- RotationCorrection (D1, VL)
\end_layout

\begin_layout Plain Layout

AL <- AL - RC  ##### note this sign and prev call above -- checked!
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## the resulting l-frame accelerations
\end_layout

\begin_layout Plain Layout

D1$LACCX <- AL[, 1]
\end_layout

\begin_layout Plain Layout

D1$LACCY <- AL[, 2]
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- AL[, 3] + G
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- -D1$LACCZ
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

## smooth to match GPS-velocity derivatives
\end_layout

\begin_layout Plain Layout

D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fm1 <- lm (D1$vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (D1$vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (D1$vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

fn1 <- lm (D1$vedot2 ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fn2 <- lm (D1$vndot2 ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fn3 <- lm (D1$vudot2 ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

c01 <- summary(fm1)$coef[1]
\end_layout

\begin_layout Plain Layout

c11 <- summary(fm1)$coef[2]
\end_layout

\begin_layout Plain Layout

s1 <- summary(fm1)$sigma
\end_layout

\begin_layout Plain Layout

r1 <- summary(fm1)$r.squared
\end_layout

\begin_layout Plain Layout

c02 <- summary(fm2)$coef[1]
\end_layout

\begin_layout Plain Layout

c12 <- summary(fm2)$coef[2]
\end_layout

\begin_layout Plain Layout

s2 <- summary(fm2)$sigma
\end_layout

\begin_layout Plain Layout

r2 <- summary(fm2)$r.squared
\end_layout

\begin_layout Plain Layout

c03 <- summary(fm3)$coef[1]
\end_layout

\begin_layout Plain Layout

c13 <- summary(fm3)$coef[2]
\end_layout

\begin_layout Plain Layout

s3 <- summary(fm3)$sigma
\end_layout

\begin_layout Plain Layout

r3 <- summary(fm3)$r.squared
\end_layout

\begin_layout Plain Layout

c04 <- summary(fn1)$coef[1]
\end_layout

\begin_layout Plain Layout

c14 <- summary(fn1)$coef[2]
\end_layout

\begin_layout Plain Layout

s4 <- summary(fn1)$sigma
\end_layout

\begin_layout Plain Layout

r4 <- summary(fn1)$r.squared
\end_layout

\begin_layout Plain Layout

c05 <- summary(fn2)$coef[1]
\end_layout

\begin_layout Plain Layout

c15 <- summary(fn2)$coef[2]
\end_layout

\begin_layout Plain Layout

s5 <- summary(fn2)$sigma
\end_layout

\begin_layout Plain Layout

r5 <- summary(fn2)$r.squared
\end_layout

\begin_layout Plain Layout

c06 <- summary(fn3)$coef[1]
\end_layout

\begin_layout Plain Layout

c16 <- summary(fn3)$coef[2]
\end_layout

\begin_layout Plain Layout

s6 <- summary(fn3)$sigma
\end_layout

\begin_layout Plain Layout

r6 <- summary(fn3)$r.squared
\end_layout

\begin_layout Plain Layout

options(digits=5)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The components of acceleration expressed in the l-frame can be compared
 to the accelerations determined by differentiating either the INS-produced
 or the GPS-produced measurements of aircraft velocity.
 The former is a check on the derivation; the latter is a check on the calibrati
on of the accelerometers.
 The derivatives of the velocities were determined by taking differences
 between consecutive measurements, although it was useful to smooth the
 result using a Savitzky-Golay third-order polynomial spanning 11 25-Hz
 samples to reduce noise arising from the limited resolution of the differences.
 
\end_layout

\begin_layout Standard
Relative timing among the measurements can influence these results.
 Many of the variables have corrections applied for assumed lags, so in
 this check of accelerations those lags were first removed.
 Then there were additional lags apparent among variables provided by the
 INS, even when tagged with the same times.
 To determine these lags, a pitch maneuver (where the pilots induce rapid
 changes in pitch with associated climbs and descents during straight flight)
 was used, from DEEPWAVE flight 15, 3:16:00–3:18:00 UTC.
 Shifting among the measurements from the INS was explored to see what provided
 the best agreement between measured accelerations (variables BLONGA, BLATA,
 BNORMA) and the accelerations determined by differentiating the INS variables
 for aircraft velocity (VEW, VNS, VSPD) and then transforming the resulting
 accelerations to the a-frame (where the IRU-provided accelerations are
 measured).
 That transformation must include correction for inertial effects as discussed
 in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:deriv-array"

\end_inset

, item 2.
 The standard deviation of the difference between the measured acceleration
 and that determined by differentiating the measured aircraft velocity was
 minimized if the measurements of acceleration were moved 50
\begin_inset space ~
\end_inset

ms earlier in time, the measurements of pitch and roll were shifted 20
\begin_inset space ~
\end_inset

ms later in time, and no shift was applied to the measurements of aircraft
 velocity.
 These are all important only in relation to each other; the same result
 is obtained if the accelerations are moved earlier by 70
\begin_inset space ~
\end_inset

ms, measurements of velocity moved earlier by 20
\begin_inset space ~
\end_inset

ms, and measurements of pitch and roll left unshifted.
 The specifications for the INS state that there may be lags in the times
 when variables are transmitted from the unit of up to about 70
\begin_inset space ~
\end_inset

ms for accelerations and attitude angles and up to 110
\begin_inset space ~
\end_inset

ms for velocity components, so these shifts are within the approximate range
 expected.
 For the purpose of comparing accelerations, the optimal shifts were applied
 to the measurements.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
fit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $c_{0}$
\end_inset

 [m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $c_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sigma$
\end_inset

 [m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $R^{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS east
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c01}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c11}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{s1}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{r1}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GPS north
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c02}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c12}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{s2}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{r2}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INS east
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c04}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c14}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{s4}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{r4}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INS north
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c05}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{c15}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{s5}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{r5}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Results of fitting the l-frame acceleration as a function of the derivative
 listed in the 
\begin_inset Quotes eld
\end_inset

fit
\begin_inset Quotes erd
\end_inset

 column.
 The coefficients represent, for example, 
\begin_inset Formula $\dot{v}_{e}\sim c_{0}+c_{1}a_{e}^{l}$
\end_inset

 where 
\begin_inset Formula $a_{e}^{l}$
\end_inset

 is the eastward component of acceleration after transformation to the l-frame.
 The residual standard deviation is tabulated as 
\begin_inset Formula $\sigma,$
\end_inset

 and the square of the correlation coefficient is 
\begin_inset Formula $R^{2}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:accel-fits"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $c_{0}$
\end_inset

 [m
\begin_inset space ~
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 ]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $c_{1}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BLONGA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa1)$coef[1]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa1)$coef[2]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BLATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa2)$coef[1]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa2)$coef[2]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BNORMA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa3)$coef[1]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{summary(fa3)$coef[2]}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Results like those in the preceding table but for accelerations in the a-frame.
\begin_inset CommandInset label
LatexCommand label
name "tab:a-frame-fits"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:accel-fits"

\end_inset

 shows the results of fitting linear polynomials in the measured accelerations
 after transformation to the l-frame (with inertial corrections) to the
 derivatives determined by differentiation.
 The GPS measurements provide independent measurements of the accelerations,
 so the first two fits can be considered checks of the calibrations of the
 accelerometers as well as a test of the calculation procedures.
 They indicate only small offsets and near-unity slopes.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The third is an indication that the calibration of the normal component
 needs adjustment, because the slope is only about 0.95.
 
\end_layout

\end_inset

The last two fits compare only INS-dependent values, so they test the validity
 of the transformations and protect against any unknown calibration adjustments
 that might have been applied by the INS without affecting the reported
 accelerations.
 
\end_layout

\begin_layout Standard
A better estimate of accelerometer calibration can be obtained by transforming
 the l-frame accelerations determined by differentiating the GPS-provided
 velocities to the a-frame, where they can be compared directly to the component
s of the measured accelerations.
 When this is done, the calibrations in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:a-frame-fits"

\end_inset

 result from linear fits.
 Lateral accelerations are usually small, so the second calibration is not
 as reliable as the other two, but all show reasonable agreement between
 the calibrations in use and those indicated by these fits.
 Although the small adjustments have little effect, the calibrations indicated
 in this table will be applied to the measured accelerations in the remainder
 of this technical note.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-acc, include=TRUE, fig.height=6,fig.cap='Comparison of measured acceleratio
ns {BLONGA, BLATA, BNORMA, blue lines} to the accelerations determined by
 differentiating the velocity components measured by the GPS receiver and
 then translating these to the a-frame (dashed red lines), from a period
 during DEEPWAVE flight 15 that includes a pitch maneuver, a speed run and
 a yaw maneuver at the times corresponding to the plot annotations.', cache=FALSE
>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# source ('chunks/multiplot.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# r <- setRange(D1, 33330, 33515)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/theme_WAC2.R')
\end_layout

\begin_layout Plain Layout

source ('~/RStudio/Ranadu/R/ggplotWAC.R')
\end_layout

\begin_layout Plain Layout

# grid.newpage()
\end_layout

\begin_layout Plain Layout

D1$AA1 <- AA[,1]
\end_layout

\begin_layout Plain Layout

D1$AA2 <- AA[,2]
\end_layout

\begin_layout Plain Layout

D1$AA3 <- AA[,3]
\end_layout

\begin_layout Plain Layout

t1 <- D1$Time[getIndex(D1, 31700)]
\end_layout

\begin_layout Plain Layout

t2 <- D1$Time[getIndex(D1, 32535)]
\end_layout

\begin_layout Plain Layout

t3 <- D1$Time[getIndex(D1, 33320)]
\end_layout

\begin_layout Plain Layout

PanelGroup <- gl (3, 3, labels=c('longitudinal', 'lateral', 'normal'))
\end_layout

\begin_layout Plain Layout

label.df <- data.frame (t=c(t1,t2,t3), y=c(-0.4,1.7,0.3), 
\end_layout

\begin_layout Plain Layout

                        PanelGroup, label=c('pitch', 'speed-run', 'yaw'))
\end_layout

\begin_layout Plain Layout

d <- with (D1[setRange(D1, 31300, 33600), ], data.frame(Time, BLONGA, AA1,
 BLATA, AA2, BNORMA, AA3))
\end_layout

\begin_layout Plain Layout

suppressWarnings (print (
\end_layout

\begin_layout Plain Layout

ggplotWAC(d, col=c('blue', 'red'), lwd=c(0.8,0.6), lty=c(1,42), panels=3,
\end_layout

\begin_layout Plain Layout

          ylab=expression(paste('acceleration [m ',s^2,']')),
\end_layout

\begin_layout Plain Layout

          labelL=c('IRU', 'GPS'), labelP=c('longitudinal', 'lateral', 'normal'),
 
\end_layout

\begin_layout Plain Layout

          legend.position=c(0.8, 0.94)) 
\end_layout

\begin_layout Plain Layout

        + geom_label (aes(x=t, y=y, label=label), data=label.df[4,], inherit.aes=F
ALSE)
\end_layout

\begin_layout Plain Layout

        + geom_label (aes(x=t, y=y, label=label), data=label.df[2,], inherit.aes=F
ALSE)
\end_layout

\begin_layout Plain Layout

        + geom_label (aes(x=t, y=y, label=label), data=label.df[6,], inherit.aes=F
ALSE)
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## use the calibration determined by comparison to GPS:
\end_layout

\begin_layout Plain Layout

cfa1 <- coef(fa1); cfa2 <- coef(fa2); cfa3 <- coef(fa3)
\end_layout

\begin_layout Plain Layout

Data$BLONGA <- cfa1[1] + cfa1[2] * Data$BLONGA
\end_layout

\begin_layout Plain Layout

Data$BLATA  <- cfa2[1] + cfa2[2] * Data$BLATA
\end_layout

\begin_layout Plain Layout

Data$BNORMA <- cfa3[1] + cfa3[2] * Data$BNORMA
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-acc}
\end_layout

\end_inset

 shows a short flight segment comparing the measured accelerations and the
 accelerations determined by differentiating the GPS-provided velocities
 and transforming to the a-frame.
 There were three maneuvers that introduced accelerations: (i) a pitch maneuver
 near 3:17:00 UTC where pilots varied the pitch rapidly, causing periodic
 accelerations normal to the aircraft; (ii) a speed run centered near 3:25:00
 UTC where the airspeed was varied through the flight envelope of the GV,
 producing large changes in pitch and resulting resolution of the acceleration
 of gravity into varying contributions to the longitudinal acceleration;
 and (iii) a yaw maneuver near 3:34:00 UTC where strong lateral accelerations
 were induced by rudder action.
 The good agreement and the near-identity calibrations tabulated above support
 that the accelerations are being treated properly in the calculations and
 also that the calibrations of the accelerometers are good.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
with(D1[r, ], ggplotWAC (data.frame (Time, AA1, BLONGA),
\end_layout

\begin_layout Plain Layout
                         ylab='longitudinal',
\end_layout

\begin_layout Plain Layout
                         col=c('red', 'blue'), lty=c(1,1), 
\end_layout

\begin_layout Plain Layout
                         ylim=c(0.35, 0.65), lmargin=1.65,
\end_layout

\begin_layout Plain Layout
                         lwd=c(1.5,0.7), position=c(3,3)))
\end_layout

\begin_layout Plain Layout
with(D1[r, ], ggplotWAC (data.frame (Time, AA2, BLATA), 
\end_layout

\begin_layout Plain Layout
                         ylab='lateral',
\end_layout

\begin_layout Plain Layout
                         col=c('red', 'blue'), lty=c(1,1),
\end_layout

\begin_layout Plain Layout
                         ylim=c(-0.42, 0.5), lmargin=0.85,
\end_layout

\begin_layout Plain Layout
                         lwd=c(1.5,.7), position=c(2,3)))
\end_layout

\begin_layout Plain Layout
with(D1[r, ], ggplotWAC (data.frame (Time, AA3, BNORMA),
\end_layout

\begin_layout Plain Layout
                         ylab='normal',
\end_layout

\begin_layout Plain Layout
                         col=c('red', 'blue'), lty=c(1,1), 
\end_layout

\begin_layout Plain Layout
                         ylim=c(-1.15, 1.15),
\end_layout

\begin_layout Plain Layout
lwd=c(1.5,.7), position=c(1,3)))
\end_layout

\begin_layout Plain Layout
DL <- nrow(d)
\end_layout

\begin_layout Plain Layout
dm <- melt (d, 'Time')
\end_layout

\begin_layout Plain Layout
dd1 <- data.frame (dm, V=rep(gl(2,DL,labels=c('GPS','IRU')),3),
\end_layout

\begin_layout Plain Layout
                  group2=gl(3,2*DL, labels=c('longitudinal', 'lateral',
 'normal')))
\end_layout

\begin_layout Plain Layout
colrs1 <- rep(c('red', 'blue'),3)
\end_layout

\begin_layout Plain Layout
lwd1 <- rep(c(0.8,0.6),3)
\end_layout

\begin_layout Plain Layout
lty1 <- rep(c(1,42),3)
\end_layout

\begin_layout Plain Layout
lvl1 <- levels(dd1$V)
\end_layout

\begin_layout Plain Layout
fig1 <- ggplot(dd1, aes(Time, value, colour=V, linetype=V))
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + geom_line(aes(size=V))
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + ylab(expression(paste('acceleration [m ',s^2,']')))
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + scale_size_manual ('', labels=lvl1, breaks=lvl1, values =
 lwd1)
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + scale_linetype_manual ('', labels=lvl1, breaks=lvl1, values
 = lty1)
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + scale_colour_manual('', labels = lvl1, breaks=lvl1, values
 = colrs1)
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + facet_grid(group2 ~ ., scales='free_y') + theme_WAC() 
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + theme(legend.position=c(0.8,0.97))
\end_layout

\begin_layout Plain Layout
fig1 <- fig1 + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)
))
\end_layout

\begin_layout Plain Layout
print (fig1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<mechanization, include=TRUE, fig.lp='fig:', fig.cap=' ', cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP <- with (Data, data.frame (LAT, LON, ALT, VEW, VNS, VSPD, 
\end_layout

\begin_layout Plain Layout

                              ROLL, PITCH, THDG, GGALT, GGVSPD, BLATA, BLONGA,
 BNORMA, 
\end_layout

\begin_layout Plain Layout

                              BPITCHR, BROLLR, BYAWR,
\end_layout

\begin_layout Plain Layout

                              GGVEW, GGVNS, Grav))
\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

# SP$BYAWR <- (SP$BYAWR - 0.0003) * 1.008
\end_layout

\begin_layout Plain Layout

SP$BROLLR <- SP$BROLLR + 0.0002
\end_layout

\begin_layout Plain Layout

SP$BPITCHR <- SP$BPITCHR + 0.001
\end_layout

\begin_layout Plain Layout

# SP$BNORMA <- SP$BNORMA*1.0086 - 0.0083
\end_layout

\begin_layout Plain Layout

# SP$BLONGA <- SP$BLONGA * 1.0062 - 0.0002
\end_layout

\begin_layout Plain Layout

# SP$BLATA <- SP$BLATA * 1.0604 + 0.0030
\end_layout

\begin_layout Plain Layout

## consider the possible effects of misalignment of INS wrt AC axes
\end_layout

\begin_layout Plain Layout

VROT <- array(c(SP$BPITCHR, SP$BROLLR, SP$BYAWR), dim=c(nrow(SP), 3))
\end_layout

\begin_layout Plain Layout

SX <- data.frame(ROLL=rep(0.05,nrow(SP)), PITCH=rep(0.15,nrow(SP)), THDG=rep(0,nrow
(SP)))
\end_layout

\begin_layout Plain Layout

VROTA <- XformLA(SX, VROT)
\end_layout

\begin_layout Plain Layout

# SP$BPITCHR <- VROTA[,2]
\end_layout

\begin_layout Plain Layout

# SP$BROLLR <- VROTA[,1]
\end_layout

\begin_layout Plain Layout

# SP$BYAWR <- -VROTA[,3]
\end_layout

\begin_layout Plain Layout

#SP$BPITCHR <- SP$BPITCHR * Cradeg
\end_layout

\begin_layout Plain Layout

#SP$BROLLR <- SP$BROLLR * Cradeg
\end_layout

\begin_layout Plain Layout

#SP$BYAWR <- SP$BYAWR * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SP$Rn <- Ree / (1 - (Ecc*sin(Data$GGLAT*Cradeg))^2)^0.5 
\end_layout

\begin_layout Plain Layout

SP$Rm <- SP$Rn * (1-Ecc^2) / (1-(Ecc*sin(Data$GGLAT*Cradeg))^2) + Data$GGALT
\end_layout

\begin_layout Plain Layout

SP$Rn <- SP$Rn + Data$GGALT
\end_layout

\begin_layout Plain Layout

SPR <- SP   ## save what INS produced, as reference
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the starting point for the integration:
\end_layout

\begin_layout Plain Layout

SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

SP$LAT[1] <- SV$LAT
\end_layout

\begin_layout Plain Layout

SP$LON[1] <- SV$LON
\end_layout

\begin_layout Plain Layout

SP$ALT[1] <- SV$ALT
\end_layout

\begin_layout Plain Layout

SP$VEW[1] <- SV$VEW
\end_layout

\begin_layout Plain Layout

SP$VNS[1] <- SV$VNS
\end_layout

\begin_layout Plain Layout

SP$VSPD[1] <- SV$VSPD
\end_layout

\begin_layout Plain Layout

SP$PITCH[1] <- SV$PITCH
\end_layout

\begin_layout Plain Layout

SP$ROLL[1] <- SV$ROLL
\end_layout

\begin_layout Plain Layout

SP$THDG[1] <- SV$THDG
\end_layout

\begin_layout Plain Layout

twoPi <- 2*pi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sv <- matrix (as.vector(SV, 'numeric'), nrow=1)
\end_layout

\begin_layout Plain Layout

## these are expected to be global in STMFV
\end_layout

\begin_layout Plain Layout

Rn <- SP$Rn[1]
\end_layout

\begin_layout Plain Layout

Rm <- SP$Rm[1]
\end_layout

\begin_layout Plain Layout

Grav <- SP$Grav[1]
\end_layout

\begin_layout Plain Layout

stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

## feedback coefficients for baro loop:
\end_layout

\begin_layout Plain Layout

C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
\end_layout

\begin_layout Plain Layout

wp3F <- 0;
\end_layout

\begin_layout Plain Layout

hxF <- hxxF <- 0
\end_layout

\begin_layout Plain Layout

hi3F <- SP$GGALT[1]
\end_layout

\begin_layout Plain Layout

RK <- TRUE    ## use Runge-Kutta integration if true
\end_layout

\begin_layout Plain Layout

RK <- FALSE
\end_layout

\begin_layout Plain Layout

DL <- nrow(SP)
\end_layout

\begin_layout Plain Layout

for (i in 2:DL) {
\end_layout

\begin_layout Plain Layout

  Rn <- SP$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- SP$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- SP$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv[10] <- SP$BPITCHR[i] * Cradeg
\end_layout

\begin_layout Plain Layout

  sv[11] <- SP$BROLLR[i] * Cradeg
\end_layout

\begin_layout Plain Layout

  sv[12] <- SP$BYAWR[i] * Cradeg
\end_layout

\begin_layout Plain Layout

  sv[13] <- SP$BLATA[i]
\end_layout

\begin_layout Plain Layout

  sv[14] <- SP$BLONGA[i]
\end_layout

\begin_layout Plain Layout

  sv[15] <- SP$BNORMA[i]
\end_layout

\begin_layout Plain Layout

  if (RK) {
\end_layout

\begin_layout Plain Layout

    stmf1 <- c(STMFV (sv), rep(0,6))
\end_layout

\begin_layout Plain Layout

    sv1 <- sv + stmf1 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf2 <- c(STMFV (sv1), rep(0,6))
\end_layout

\begin_layout Plain Layout

    sv2 <- sv + stmf2 * dt/2
\end_layout

\begin_layout Plain Layout

    stmf3 <- c(STMFV (sv2), rep(0,6))
\end_layout

\begin_layout Plain Layout

    sv3 <- sv + stmf3 * dt
\end_layout

\begin_layout Plain Layout

    stmf4 <- c(STMFV (sv3), rep(0,6))
\end_layout

\begin_layout Plain Layout

    stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    ## here the original state-vector components are used to calculate the
 derivatives:
\end_layout

\begin_layout Plain Layout

    svp <- with(D1[i,], 
\end_layout

\begin_layout Plain Layout

      c(LAT,LON,ALT,VEW,VNS,VSPD,PITCH,ROLL,THDG,BPITCHR,BROLLR,BYAWR,BLATA,BLON
GA,BNORMA))
\end_layout

\begin_layout Plain Layout

    svp[c(1:2,7:12)] <- svp[c(1:2,7:12)]*Cradeg
\end_layout

\begin_layout Plain Layout

    svp <- matrix (as.vector(svp, 'numeric'), nrow=1)
\end_layout

\begin_layout Plain Layout

    stmf <- c(STMFV (svp), rep(0,6))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sv <- sv + stmf * dt
\end_layout

\begin_layout Plain Layout

  if (sv[9] < 0) {sv[9] <- sv[9] + twoPi}
\end_layout

\begin_layout Plain Layout

  if (sv[9] > twoPi) {sv[9]<- sv[9] - twoPi}
\end_layout

\begin_layout Plain Layout

  ## baro-loop
\end_layout

\begin_layout Plain Layout

  wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
\end_layout

\begin_layout Plain Layout

  hi3F <- hi3F + (wp3F - C0 * hxF) * dt
\end_layout

\begin_layout Plain Layout

  hxF <- hi3F - SP$GGALT[i]
\end_layout

\begin_layout Plain Layout

  hxxF <- hxxF + hxF * dt
\end_layout

\begin_layout Plain Layout

  sv[6] <- 0.5 * (sv[6] + wp3F)
\end_layout

\begin_layout Plain Layout

  SP$LAT[i] <- sv[1]
\end_layout

\begin_layout Plain Layout

  SP$LON[i] <- sv[2] 
\end_layout

\begin_layout Plain Layout

  SP$ALT[i] <- sv[3]
\end_layout

\begin_layout Plain Layout

  SP$VEW[i] <- sv[4]
\end_layout

\begin_layout Plain Layout

  SP$VNS[i] <- sv[5]
\end_layout

\begin_layout Plain Layout

  SP$VSPD[i] <- sv[6]
\end_layout

\begin_layout Plain Layout

  SP$PITCH[i] <- sv[7] 
\end_layout

\begin_layout Plain Layout

  SP$ROLL[i] <- sv[8] 
\end_layout

\begin_layout Plain Layout

  SP$THDG[i] <- sv[9]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

SP$LAT <- SP$LAT / Cradeg
\end_layout

\begin_layout Plain Layout

SP$LON <- SP$LON / Cradeg
\end_layout

\begin_layout Plain Layout

SP$PITCH <- SP$PITCH / Cradeg
\end_layout

\begin_layout Plain Layout

SP$ROLL <- SP$ROLL / Cradeg
\end_layout

\begin_layout Plain Layout

SP$THDG <- SP$THDG / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Checking the rotation rates
\begin_inset CommandInset label
LatexCommand label
name "subsec:Checking-the-rotation"

\end_inset


\end_layout

\begin_layout Standard
Independent measurements of rotation rates are not available as they are
 for accelerations, so a similar direct test and calibration are not possible.
 However, if the wind remains constant, a flight maneuver consisting of
 a circular pattern should produce a 360
\begin_inset Formula $^{\circ}$
\end_inset

change in heading, and the start and end points can be identified from GPS-provi
ded measurements by finding the times when the groundspeed components return
 to their original values.
 DEEPWAVE flight 15 included several circle patterns in the flight plan,
 including four from 3:38:00 to 3:55:00 UTC, two counterclockwise and then
 two clockwise.
 Without inertial corrections, which are very small integrated over the
 circles, the rate of change in heading should be 
\begin_inset Formula $\dot{\psi}$
\end_inset

=BYAWR/
\begin_inset Formula $\cos\phi$
\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle, so comparing this to the change in heading tests that
 the reported rotation rates are correct.
 The total heading change from 3:38:50 to 3:46:40 is 
\begin_inset Formula $-$
\end_inset

718.2
\begin_inset Formula $^{\circ}$
\end_inset

, while the sum of BYAWR/
\begin_inset Formula $\cos\phi$
\end_inset

 for the same period is 
\begin_inset Formula $-720.1^{\circ}$
\end_inset

, so these agree to within 0.2%.
 For the two clockwise turns from 3:46:40 to 3:54:30, the corresponding
 sums are 720.1 and 720.6, in still better agreement.
 This only checks for consistency, because the INS mechanization should
 produce the same result as that obtained by the difference in output variables,
 but one significant conclusion is that the inertial corrections have only
 a very small net effect on the rotation rate about the heading or yaw axis.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<psi-dot, include=TRUE, fig.cap=''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A <- atan2(D1$vedot, D1$vndot)/Cradeg
\end_layout

\begin_layout Plain Layout

r1 <- setRange(D1, 33938, 34610)
\end_layout

\begin_layout Plain Layout

r2 <- setRange (D1, 34710, 35348)
\end_layout

\begin_layout Plain Layout

dA <- c(0, diff(A))
\end_layout

\begin_layout Plain Layout

dA[dA > 180] <- dA[dA > 180] - 360
\end_layout

\begin_layout Plain Layout

dA[dA < -180] <- dA[dA < -180] + 360
\end_layout

\begin_layout Plain Layout

mdh1 <- mean(D1$hdot[r1])
\end_layout

\begin_layout Plain Layout

mda1 <- mean(dA[r1]) * Rate
\end_layout

\begin_layout Plain Layout

mdh2 <- mean(D1$hdot[r2])
\end_layout

\begin_layout Plain Layout

mda2 <- mean(dA[r2]) * Rate
\end_layout

\begin_layout Plain Layout

sdmh1 <- sd(D1$hdot[r1]) / sqrt(length(r1)-1)
\end_layout

\begin_layout Plain Layout

sdmh2 <- sd(D1$hdot[r1]) / sqrt(length(r2)-1)
\end_layout

\begin_layout Plain Layout

sdma1 <- sd(dA[r1]) * Rate / sqrt(length(r1)-1)
\end_layout

\begin_layout Plain Layout

sdma2 <- sd(dA[r1]) * Rate / sqrt (length(r2)-1)
\end_layout

\begin_layout Plain Layout

cfydot <- coef(lm (c(mda1, mda2) ~ c(mdh1, mdh2)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another test of the rotation rate about the yaw axis can be obtained by
 comparing 
\begin_inset Formula $\dot{\psi}$
\end_inset

 in steady turns to the rate of change in the orientation of the acceleration
 vector determined from the GPS.
 In circle maneuvers, the horizontal component of the acceleration vector
 should rotate at a rate equal to 
\begin_inset Formula $\dot{\psi}$
\end_inset

, so this provides a test of the calibration of the rotation rate provided
 by the gyros.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:hrot-comparison"

\end_inset

 shows the comparison of rotation rates obtained in these two independent
 ways.
 There is a small but significant difference between the two turn directions,
 which suggests that a calibration representing both would be 
\begin_inset Formula $\dot{\psi}_{cal}=a_{0}+a_{1}\dot{\psi}$
\end_inset

 where 
\begin_inset Formula $a_{0}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfydot[1], 3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}\mathrm{s^{-1}}$
\end_inset

 and 
\begin_inset Formula $a_{1}$
\end_inset

=
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfydot[2],3)}
\end_layout

\end_inset

.
 Because the cosine of the mean roll angle was steady at 0.89
\begin_inset Formula $_{4}$
\end_inset

, the corresponding calibration of BYAWR would use the first coefficient
 multiplied by 0.894; i.e., 
\begin_inset Formula $\mathrm{BYAWR}{}_{cal}=a_{0}^{*}+a_{1}\mathrm{BYAWR}$
\end_inset

 where 
\begin_inset Formula $a_{0}^{*}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfydot[1]*0.894,3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}\mathrm{s^{-1}}$
\end_inset

.
 This confirms that the offset in the measured rotation rate about the heading
 axis is small and the sensitivity coefficient is within about 1% of unity.
 However, even an offset of this small magnitude warrants correction because
 the offset accumulates with time and so would make a significant contribution
 during flights lasting several hours.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
turn direction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean, 
\begin_inset Formula $\left\langle \dot{\psi}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
std.
 dev.
 in 
\begin_inset Formula $\left\langle \dot{\psi}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mean, 
\begin_inset Formula $\left\langle \dot{\psi}^{*}\right\rangle $
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
std.
 dev.
 in 
\begin_inset Formula $\left\langle \dot{\psi}^{*}\right\rangle $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
left
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mdh1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdmh1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mda1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdma1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
right
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mdh2,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdmh2,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mda2,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdma2,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of the rate of change in heading (
\begin_inset Formula $\dot{\psi}$
\end_inset

) to the rate of change in the direction of the acceleration vector determined
 from differentiation of GPS-derived velocity components (
\begin_inset Formula $\dot{\psi}^{*}$
\end_inset

).
 All units are [
\begin_inset Formula $^{\circ}\mathrm{s}^{-1}]$
\end_inset

.
 The listed standard deviations are those estimated for the mean measurement.
\begin_inset CommandInset label
LatexCommand label
name "tab:hrot-comparison"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inertial effects are expected to be more significant for the pitch and roll
 angles, so similar tests applied to those angles are useful checks of the
 analytical formulas for the derivatives.
 To first order and without inertial corrections, the expected relationships
 are
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{eqnarray*}
\mathrm{BPITCHR} & = & \dot{\theta}+\dot{\psi}\sin\phi\\
\mathrm{BROLLR} & = & \dot{\phi}-\dot{\psi}\sin\theta
\end{eqnarray*}

\end_inset

where 
\begin_inset Formula $\theta,$
\end_inset

 
\begin_inset Formula $\phi$
\end_inset

 and 
\begin_inset Formula $\psi$
\end_inset

 are respectively the pitch, roll, and heading angles and dots over the
 symbols denote time derivatives.
 For roll, the sum of the left side for the counterclockwise turns is 
\begin_inset Formula $37.2^{\circ}$
\end_inset

, while the sum of the right side is 
\begin_inset Formula $37.5^{\circ}$
\end_inset

.
 For the clockwise turns, the corresponding sums are 
\begin_inset Formula $-36.3^{\circ}$
\end_inset

 and 
\begin_inset Formula $-35.9^{\circ}$
\end_inset

.
 The actual change in roll is near zero, but in the a-frame and with the
 aircraft pitched slightly upward during the turn the rate of rotation about
 the yaw axis has an effect on the measured rotation rate about the roll
 axis.
 Similarly, for pitch the sum of the left side for the counterclockwise
 turns is 
\begin_inset Formula $321.3^{\circ}$
\end_inset

, while the sum of the right side is 
\begin_inset Formula $322.9^{\circ}$
\end_inset

.
 For the clockwise turns, the corresponding sums are 
\begin_inset Formula $324.7^{\circ}$
\end_inset

 and 
\begin_inset Formula $325.0^{\circ}$
\end_inset

.
 As for roll, the actual change in pitch from start to end of the two periods
 of circular flight is near zero, but in the a-frame and with a significant
 roll angle the rotation about the yaw axis makes a contribution to the
 measured rotation rate about the pitch axis.
 In addition, the difference for clockwise vs counterclockwise turns is
 attributable to the need for corrections for inertial effects.
 
\end_layout

\begin_layout Standard
A critical test of the angle derivatives is to transform the measured derivative
s for pitch, roll, and heading to the a-frame, with appropriate correction
 for inertial effects, and check that the results match the measured rotation
 rates.
 The procedure is discussed in a following section (Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Rotations"

\end_inset

) because the procedure is also useful for obtaining substitutes for the
 body rotation rates in cases where they were not recorded or were not in
 the archive files.
 Plots and fits confirm that the transformed rotation rates obtained in
 this way match the measured rotation rates to within very small tolerances.
 For example, for the yaw rotation rate, a linear fit gives coefficients
 (-0.0003, 1.000001) for a fit of the transformed values to the measured values,
 with standard deviation smaller than 0.01
\begin_inset space ~
\end_inset


\begin_inset Formula $^{\circ}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and correlation coefficient 0.99997.
 For roll and pitch, similar agreement indicates that the accumulated difference
s found in the preceding paragraph are indeed the result of the need for
 inertial corrections and that, as formulated in the code of the present
 program, the inertial corrections match those applied by the INS during
 the original mechanization.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
with(Data[r,], {
\end_layout

\begin_layout Plain Layout
ggplotWAC (data.frame(Time, VEW, VEWX), lwd=c(1.2,0.8),
\end_layout

\begin_layout Plain Layout
                           col=c('blue', 'red', 'darkorange','black'),
\end_layout

\begin_layout Plain Layout
             lty=c(1,42), position=c(2,2), legend.position=c(0.2,0.91))
\end_layout

\begin_layout Plain Layout
# op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
  ggplotWAC (data.frame(Time, VNS, VNSX), lwd=c(1.2,0.8),
\end_layout

\begin_layout Plain Layout
                           col=c('blue', 'red', 'darkorange','black'),
\end_layout

\begin_layout Plain Layout
             lty=c(1,42), position=c(1,2), legend.position=c(0.2,0.91))
\end_layout

\begin_layout Plain Layout
})
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The preceding subsection tested the handling of the measurements of rotation
 rate and acceleration provided by the IRU and supported the validity of
 the transformation of those body measurements to the l-frame.
 However, as indicated in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:mech-procedures"

\end_inset

, integration using the calculated derivatives and comparison to the INS-produce
d solution is a critical test of the derivatives.
 Results from that calculation are presented in the next section and provide
 a critical test of the derivatives.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<find-rotation-correction, include=TRUE, cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$pdot <- c(0, diff(D1$PITCH)) *  Rate
\end_layout

\begin_layout Plain Layout

D1$rdot <- c(0, diff(D1$ROLL)) * Rate
\end_layout

\begin_layout Plain Layout

D1$hdot <- c(0, diff(D1$THDG))
\end_layout

\begin_layout Plain Layout

D1$hdot <- (D1$hdot + 540) %% 360 - 180
\end_layout

\begin_layout Plain Layout

D1$hdot <- D1$hdot * Rate
\end_layout

\begin_layout Plain Layout

## shift by 1/2 the time interval
\end_layout

\begin_layout Plain Layout

shift <- -500 / Rate    
\end_layout

\begin_layout Plain Layout

D1$pdot <- ShiftInTime(D1$pdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

D1$rdot <- ShiftInTime(D1$rdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

D1$hdot <- ShiftInTime(D1$hdot, Rate, shift)
\end_layout

\begin_layout Plain Layout

## the derivative of the transformation matrix in terms of hdot etc.
\end_layout

\begin_layout Plain Layout

with (D1, {
\end_layout

\begin_layout Plain Layout

  ch <- cos(THDG*Cradeg)
\end_layout

\begin_layout Plain Layout

  sh <- sin(THDG*Cradeg)
\end_layout

\begin_layout Plain Layout

  cp <- cos(PITCH*Cradeg)
\end_layout

\begin_layout Plain Layout

  sp <- sin(PITCH*Cradeg)
\end_layout

\begin_layout Plain Layout

  cr <- cos(ROLL*Cradeg)
\end_layout

\begin_layout Plain Layout

  sr <- sin(ROLL*Cradeg)
\end_layout

\begin_layout Plain Layout

  Rd <<- c(hdot*ch*cp-pdot*sh*sp,    ## note <<- assignment to get out of
 with() environment
\end_layout

\begin_layout Plain Layout

          hdot*(ch*sp*sr-sh*cr)  + pdot*sh*cp*sr    + rdot*(sh*sp*cr-ch*sr),
\end_layout

\begin_layout Plain Layout

          hdot*(-sh*sr-ch*sp*cr) + pdot*(-sh*cp*cr) + rdot*(ch*cr+sh*sp*sr),
\end_layout

\begin_layout Plain Layout

          hdot*(-sh*cp)          + pdot*(-ch*sp),
\end_layout

\begin_layout Plain Layout

          hdot*(-sh*sp*sr-ch*cr) + pdot*ch*cp*sr    + rdot*(ch*sp*cr+sh*sr),
\end_layout

\begin_layout Plain Layout

          hdot*(sh*sp*cr-ch*sr)  + pdot*(-ch*cp*cr) + rdot*(ch*sp*sr-sh*cr),
\end_layout

\begin_layout Plain Layout

                                 - pdot*cp,
\end_layout

\begin_layout Plain Layout

                                   pdot*(-sp*sr)    + rdot*cp*cr,
\end_layout

\begin_layout Plain Layout

                                   pdot*sp*cr       + rdot*cp*sr)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

RdM <- aperm (array (Rd, dim=c(nrow(D1),3,3)))
\end_layout

\begin_layout Plain Layout

OmegaA <- array (0, dim=c(nrow(D1),3,3))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(D1)) {
\end_layout

\begin_layout Plain Layout

  sv <- with(D1[i,], c(LAT, LON, ALT, VEW, VNS, VSPD, PITCH, ROLL, THDG,
 
\end_layout

\begin_layout Plain Layout

                       BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
\end_layout

\begin_layout Plain Layout

  rlm <- XformLA (D1[i, ])
\end_layout

\begin_layout Plain Layout

  sv[c(1:2,7:12)] <- sv[c(1:2, 7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  omega <- as.vector (c(-sv[5] / D1$Rm, 
\end_layout

\begin_layout Plain Layout

                        OmegaE*cos(sv[1])+sv[4]/(D1$Rn),
\end_layout

\begin_layout Plain Layout

                        OmegaE*sin(sv[1])+sv[4]*tan(sv[1])/D1$Rn), mode='numeric
')
\end_layout

\begin_layout Plain Layout

  ## signs account for b-frame to a-frame: reverse sign of 3
\end_layout

\begin_layout Plain Layout

  Oill <- aperm(matrix (c(0, omega[3], omega[2], -omega[3], 0, -omega[1],
 -omega[2], omega[1], 0), ncol=3))
\end_layout

\begin_layout Plain Layout

  Oilb <- Oill %*% rlm
\end_layout

\begin_layout Plain Layout

  OmegaA[i,,] <- t(rlm) %*% (RdM[,,i] + Oilb / Cradeg)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

D1$BP <- -OmegaA[,1,3]
\end_layout

\begin_layout Plain Layout

D1$BR <- OmegaA[,2,3]
\end_layout

\begin_layout Plain Layout

D1$BY <- -OmegaA[,1,2]
\end_layout

\begin_layout Plain Layout

D1$DBP <- SmoothInterp(D1$BPITCHR-D1$BP, .Length=60*Rate+1)
\end_layout

\begin_layout Plain Layout

D1$DBR <- SmoothInterp(D1$BROLLR-D1$BR, .Length=60*Rate+1)
\end_layout

\begin_layout Plain Layout

D1$DBY <- SmoothInterp(D1$BYAWR-D1$BY, .Length=60*Rate+1)
\end_layout

\begin_layout Plain Layout

D15 <- D1[2:nrow(D1),]  ## save it for plotting later, and modify it to
 avoid deletion
\end_layout

\begin_layout Plain Layout

# rm(D1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mechanization using the derivatives
\begin_inset CommandInset label
LatexCommand label
name "subsec:Mechanization"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-mechanization, include=TRUE, fig.height=c(7,5), fig.lp='fig:', fig.cap=c('Co
mparison of INS-provided and integration-derived attitude angles, labeled
 "original" and "new", the latter plotted as dashed lines.
 The differences are plotted as green lines.', 'Comparison of INS-provided
 and integration-derived components of the aircraft velocity, the latter
 plotted as dashed green lines.
 The former are {VEW, VNS} and the latter {VEWX, VNSX}, for respectively
 the northbound and eastbound components of the aircraft velocity.'), cache=FALSE
>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# r <- setRange (Data, 31000, 35500)
\end_layout

\begin_layout Plain Layout

Data$PITCHX <- SP$PITCH
\end_layout

\begin_layout Plain Layout

Data$ROLLX <- SP$ROLL
\end_layout

\begin_layout Plain Layout

Data$THDGX <- SP$THDG
\end_layout

\begin_layout Plain Layout

Data$DPITCH <- Data$PITCHX-Data$PITCH
\end_layout

\begin_layout Plain Layout

Data$DROLL <- (Data$ROLLX-Data$ROLL)
\end_layout

\begin_layout Plain Layout

Data$DTHDG <- (180+(Data$THDGX-Data$THDG)) %% 360 - 180
\end_layout

\begin_layout Plain Layout

Data$ZERO <- rep(0, nrow(Data))
\end_layout

\begin_layout Plain Layout

Data$PI <- rep(180, nrow(Data))
\end_layout

\begin_layout Plain Layout

#layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

#op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

r <- setRange(Data, 32000, 35500)
\end_layout

\begin_layout Plain Layout

d <- with(Data[r, ], data.frame(Time, PITCH, PITCHX, DPITCH, ROLL, ROLLX,
 DROLL,
\end_layout

\begin_layout Plain Layout

                               THDG, THDGX, DTHDG))
\end_layout

\begin_layout Plain Layout

ggplotWAC(d, col=c('blue', 'red', 'forestgreen'), 
\end_layout

\begin_layout Plain Layout

          ylab=expression(paste('attitude angles [',degree,']')),
\end_layout

\begin_layout Plain Layout

          lwd=c(1.4,0.8,1), lty=c(1,42,1), panels=3,
\end_layout

\begin_layout Plain Layout

          labelL=c('original', 'new', 'diff'),
\end_layout

\begin_layout Plain Layout

          labelP=c('pitch', 'roll', 'heading'),
\end_layout

\begin_layout Plain Layout

          legend.position=c(0.8, 0.97))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# grid.newpage()
\end_layout

\begin_layout Plain Layout

# with(Data[r,], {ggplotWAC (data.frame(Time, PITCH, PITCHX, DPITCH), 
\end_layout

\begin_layout Plain Layout

#                            col=c('blue', 'red', 'forestgreen','black'),
\end_layout

\begin_layout Plain Layout

#          lwd=c(1.2,0.8,0.8, 0.6), lty=c(1,42,1,3), ylim=c(-.5,5),
\end_layout

\begin_layout Plain Layout

# 		 lmargin=2.4,
\end_layout

\begin_layout Plain Layout

#          position=c(3,3), legend.position=c(0.5,0.86))
\end_layout

\begin_layout Plain Layout

# # abline (h=0, lty=2)
\end_layout

\begin_layout Plain Layout

# ggplotWAC(data.frame(Time, ROLL, ROLLX, DROLL), lwd=c(1.2,0.8,0.8,0.6),
\end_layout

\begin_layout Plain Layout

#                         col=c('blue', 'red', 'forestgreen','black'),
\end_layout

\begin_layout Plain Layout

# 						lmargin=1.35,
\end_layout

\begin_layout Plain Layout

#           lty=c(1,42,1,3), position=c(2,3), legend.position=c(0.30,0.86))
\end_layout

\begin_layout Plain Layout

# # abline (h=0, lty=2)
\end_layout

\begin_layout Plain Layout

# #op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# ggplotWAC(data.frame(Time, THDG, THDGX, DTHDG), ylim=c(0,360),
\end_layout

\begin_layout Plain Layout

#                            col=c('blue', 'red', 'forestgreen','black'),
\end_layout

\begin_layout Plain Layout

#         lwd=c(1.2,0.8,0.8,0.6), lty=c(1,42,1,3), position=c(1,3), legend.position=c
(0.235,0.85))
\end_layout

\begin_layout Plain Layout

# })
\end_layout

\begin_layout Plain Layout

# # abline (h=180, lty=2)
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

# layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Data$LATX <- SP$LAT
\end_layout

\begin_layout Plain Layout

# Data$LONX <- SP$LON
\end_layout

\begin_layout Plain Layout

# Data$ALTX <- SP$ALT
\end_layout

\begin_layout Plain Layout

# # plotWAC (Data[r, c('Time', 'LAT', 'LATX')])
\end_layout

\begin_layout Plain Layout

# # plotWAC (Data[r, c('Time', 'LON', 'LONX')])
\end_layout

\begin_layout Plain Layout

# # op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# # plotWAC (Data[r, c('Time', 'ALT', 'ALTX', 'GGALT')])
\end_layout

\begin_layout Plain Layout

# 
\end_layout

\begin_layout Plain Layout

Data$VEWX <- SP$VEW
\end_layout

\begin_layout Plain Layout

Data$VNSX <- SP$VNS
\end_layout

\begin_layout Plain Layout

Data$VSPDX <- SP$VSPD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

d <- with(Data[r,], data.frame(Time, VEW, VEWX, VNS, VNSX))
\end_layout

\begin_layout Plain Layout

ggplotWAC(d, col=c('blue', 'red'), lwd=c(1.4,0.8), lty=c(1.42),
\end_layout

\begin_layout Plain Layout

          ylab=expression(paste('velocity component [m ',s^-2,']')),
\end_layout

\begin_layout Plain Layout

          panels=2,
\end_layout

\begin_layout Plain Layout

          labelL=c('original', 'new'),
\end_layout

\begin_layout Plain Layout

          labelP=c('eastward', 'northward'),
\end_layout

\begin_layout Plain Layout

          legend.position=c(0.2, 0.97))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plotWAC (Data[r, c('Time', 'VSPD', 'VSPDX')])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

# SP <- SPR    ## restore to state before integration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The flight segment includes a period from 3:32:00 to 3:36:00 UTC where modest
 pitch changes were forced and then four circles, two flown counterclockwise
 and two flown clockwise.
 To produce the right values of the state vector through these maneuvers
 is therefore a good test of the mechanization.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mechanization1}
\end_layout

\end_inset

 shows that there is good agreement for heading and roll, and pitch tracks
 well through the pitch maneuver and the counterclockwise turns, but there
 are some small deviations between INS-produced values and the new values
 for pitch during the two clockwise turns.
 The direct measurements of rotation rates show steady values through all
 the turns, so the perturbations in pitch must arise from the inertial-correctio
n terms.
 Similar small perturbations in heading were evident in all turns., but after
 the turns all calculated attitude angles returned to values close to the
 INS-produced values.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-mechanization2}
\end_layout

\end_inset

 shows that the ground-speed components tracked the INS values fairly closely
 but also developed some small differences in turns.
 The remaining differences are not understood fully, but contributions may
 arise from higher-rate data available to the INS, time shifts among variables,
 cumulative effects of numerical rounding, or perhaps adjustments internal
 to the INS that are not known.
 However, the key result from this part of the study is that as implemented
 above the derivatives of components of the state vector are approximately
 correct and integrate to reasonable values.
 The function providing those derivatives is therefore a reasonable basis
 for the Kalman filter that follows.
\end_layout

\begin_layout Section
Ancillary topics
\end_layout

\begin_layout Subsection
A new variable for rate of climb
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<new-data, include=TRUE, cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "16" 			
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"     		
\end_layout

\begin_layout Plain Layout

ProjectDir <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%srf%s.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source ('chunks/AcquireData.R')
\end_layout

\begin_layout Plain Layout

## add ROC variable
\end_layout

\begin_layout Plain Layout

source ('chunks/ROC.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1 <- Data  ## make adjustments to a copy; avoid changing original
\end_layout

\begin_layout Plain Layout

## adjustments:
\end_layout

\begin_layout Plain Layout

source ('chunks/AdjustCal.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## transform to the a-frame for comparison to the IRU:
\end_layout

\begin_layout Plain Layout

VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
\end_layout

\begin_layout Plain Layout

LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - D1$Grav), ncol=3) + RotationCorr
ection (D1, VL)
\end_layout

\begin_layout Plain Layout

AA <- XformLA (D1, LA, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

AA[,3] <- AA[,3] - D1$Grav
\end_layout

\begin_layout Plain Layout

fa1 <- lm(D1$BLONGA ~ AA[, 1])
\end_layout

\begin_layout Plain Layout

fa2 <- lm(D1$BLATA ~ AA[, 2])
\end_layout

\begin_layout Plain Layout

fa3 <- lm(D1$BNORMA ~ AA[, 3])  
\end_layout

\begin_layout Plain Layout

fm1 <- lm (D1$vedot ~ D1$LACCX)
\end_layout

\begin_layout Plain Layout

fm2 <- lm (D1$vndot ~ D1$LACCY)
\end_layout

\begin_layout Plain Layout

fm3 <- lm (D1$vudot ~ D1$LACCZ)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The integration provided by the INS includes variables for rate of climb
 (VSPD) and altitude (ALT), but both are updated using a scheme that matches
 the altitude to the pressure altitude.
 This is not the variable needed for calculation of the vertical wind, and
 in baroclinic regions it is easy to detect the false variations that arise
 in rate of climb because of this updating scheme.
 The GPS-provided variable GGVSPD can be used instead, but it is likely
 that the INS can produce a better representation of the high-frequency
 component, so it is useful to consider another variable based on the INS
 measurements that can then be updated to GGVSPD via the Kalman filter.
 
\end_layout

\begin_layout Standard
The hydrostatic equation provides a basis for updating that is independent
 of the GPS: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\frac{dz}{dp}=-\frac{R_{a}T}{pg}\label{eq:hydrostatic-equation}
\end{equation}

\end_inset

where 
\begin_inset Formula $z$
\end_inset

 is the geometric altitude, 
\begin_inset Formula $p$
\end_inset

 the pressure, 
\begin_inset Formula $R_{a}$
\end_inset

 the gas constant for air, 
\begin_inset Formula $T$
\end_inset

 the absolute temperature, and 
\begin_inset Formula $g$
\end_inset

 the acceleration of gravity.
 Then 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
w_{p}=\frac{dz}{dt}=-\frac{R_{d}T}{pg}\frac{dp}{dt}\label{eq:w-hydro}
\end{equation}

\end_inset

is the rate of climb in terms of geometric altitude.
 The resolution in the pressure measurements makes this estimate too noisy
 to use directly, but it can be used to update the integrated vertical accelerat
ion from the INS.
 Define these variables: 
\begin_inset Formula $w_{p}^{\prime}$
\end_inset

 as provided by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:w-hydro"

\end_inset

) and 
\begin_inset Formula $w_{p}^{*}=\int_{0}^{t}a(t)dt$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

 is the vertical acceleration (ACINS) as provided by the INS.
 Define 
\begin_inset Formula $\Delta w_{p}=w_{p}^{\prime}-w_{p}^{*}$
\end_inset

 and 
\begin_inset Formula $\overline{\Delta w_{p}}$
\end_inset

 as a low-pass-filtered version of 
\begin_inset Formula $\Delta w_{p}$
\end_inset

.
 Then estimate the rate of climb of the aircraft from 
\begin_inset Formula $w_{p}=w_{p}^{*}+\overline{\Delta w_{p}}$
\end_inset

.
 The specific implementation of this uses a Butterworth filter to find 
\begin_inset Formula $\overline{\Delta w_{p}}$
\end_inset

, as follows:
\end_layout

\begin_layout LyX-Code
DIF <- WPPRIME - WPSTAR  ## WPPRIME from hydrostatic equation, 
\end_layout

\begin_layout LyX-Code
                         ## WPSTAR from integrating ACINS
\end_layout

\begin_layout LyX-Code
DIF <- zoo::na.approx (as.vector(DIF), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout LyX-Code
DIFW <- signal::filtfilt (signal::butter(3, 2/tau), DIF)
\end_layout

\begin_layout LyX-Code
ROC <- WPSTAR + DIFW
\end_layout

\begin_layout Standard
where the second statement removes missing values by interpolation and is
 needed to avoid an error return in the third statement.
 The period of the filter cut-off is tau, here selected after some exploration
 to be 300
\begin_inset space ~
\end_inset

s.
 The 
\begin_inset Quotes eld
\end_inset

filtfilt()
\begin_inset Quotes erd
\end_inset

 function filters by averaging two passes, forward and backward in time,
 to minimize phase-shift distortion of the filtered signal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ROC-plot, include=TRUE, fig.height=6, fig.cap='Comparison of new variable
 representing rate of climb (ROC) to the GPS-provided measurement (GGVSPD)
 and, in the bottom panel, the measurement provided by the INS (VSPD).
 The time covered in the bottom panel is a small segment from the time interval
 used for the top two panels.', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(width=1, height=0.6, x=0.5, y=0.7)
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(width=1, height=0.4, x=0.5, y=0.2)
\end_layout

\begin_layout Plain Layout

g1 <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

  with(D1[setRange(D1, 74000, 80000), ], 
\end_layout

\begin_layout Plain Layout

       data.frame (Time, ROC, GGVSPD, "DROC"=ROC-GGVSPD, 'SKIP'=ROC*0)),
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'red'), lwd=c(1.4,0.8,1,0), lty=c(1,42),
\end_layout

\begin_layout Plain Layout

       ylab=expression(paste('rate of climb [m ', s^-1, ']')),
\end_layout

\begin_layout Plain Layout

       panels=2,
\end_layout

\begin_layout Plain Layout

       labelL=c('ROC', 'GGVSPD'),
\end_layout

\begin_layout Plain Layout

       labelP=c('variables', 'difference'),
\end_layout

\begin_layout Plain Layout

       legend.position=c(0.8,0.94)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

print (g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

g2 <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

  with(D1[setRange(D1, 75500, 75900), ],
\end_layout

\begin_layout Plain Layout

       data.frame (Time, ROC, GGVSPD, VSPD)),
\end_layout

\begin_layout Plain Layout

  ylab=expression(paste('rate of climb [m ', s^-1, ']'))
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(axis.title.y=element_text(size=12),
\end_layout

\begin_layout Plain Layout

                 axis.text.y=element_text(size=12),
\end_layout

\begin_layout Plain Layout

                 axis.text.x=element_text(size=12),
\end_layout

\begin_layout Plain Layout

                 axis.title.x=element_text(size=12))
\end_layout

\begin_layout Plain Layout

print (g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

meanROC <- with(D1[setRange(D1, 70000, 122000), ], mean (ROC-GGVSPD, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdROC <- with(D1[setRange(D1, 70000, 122000), ], sd (ROC-GGVSPD, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting variable 
\begin_inset Quotes eld
\end_inset

ROC
\begin_inset Quotes erd
\end_inset

 is plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ROC-plot}
\end_layout

\end_inset

 for comparison to the GPS-provided variable GGVSPD.
 The bottom panel also shows the variable 
\begin_inset Quotes eld
\end_inset

VSPD
\begin_inset Quotes erd
\end_inset

 that is provided directly by the INS.
 The latter departs significantly from the other two measurements, so using
 ROC as input to the Kalman filter appears preferable to using VSPD.
 Indeed, The mean difference ROC
\begin_inset Formula $-$
\end_inset

GGVSPD is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanROC, 2)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdROC, 2)}
\end_layout

\end_inset

.
 ROC appears to vary more smoothly than GGVSPD, so Kalman-filter-updating
 of ROC to GGVSPD may provide a better representation of aircraft rate-of-climb
 than GGVSPD.
 This will be considered further in Sect.
\begin_inset space ~
\end_inset

XXX, where the wind measurements produced by the Kalman filter are discussed.
\end_layout

\begin_layout Subsection
Retrieving IRU measurements by differentiation
\end_layout

\begin_layout Subsubsection
Rotations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Rotations"

\end_inset


\end_layout

\begin_layout Standard
It is usually the case that the IRU variables for body rotation rate and
 body acceleration are not part of the data archives.
 Indeed, for all except recent projects and for all C-130 projects, these
 variables from the IRU were not even recorded in the original data tapes.
 Mechanization as in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Mechanization"

\end_inset

 needs high-rate files, but the Kalman filter developed in the next section
 provides a slow update to the error state vector and therefore works adequately
 with low-rate data files.
 Therefore, it is useful to be able to retrieve the accelerations and rotation
 rates from the measured variables present in those files, by differentiating
 angles and velocities and then transforming them to the a-frame with correction
 for the inertial effects.
 Then the Kalman filter will be able to proceed as if the original measurements
 were available.
\end_layout

\begin_layout Standard
For the rotation rates, the process is as follows: (For additional detail,
 see the workflow document.
 The code is in R 
\begin_inset Quotes eld
\end_inset

chunk
\begin_inset Quotes erd
\end_inset

 find-rotation-correction.
 )
\end_layout

\begin_layout Enumerate
Calculate the derivative of the transformation matrix in terms of attitude
 angles and express it in terms of 
\begin_inset Formula $\dot{\theta}$
\end_inset

, 
\begin_inset Formula $\dot{\phi}$
\end_inset

, and 
\begin_inset Formula $\dot{\psi}$
\end_inset

, the time derivatives of the attitude angles.
\end_layout

\begin_layout Enumerate
Use sequential increments of the attitude angles to find values for these
 time derivatives.
 Use these with the analytical expressions for the derivatives from step
 1 to find the derivative of the rotation matrix from the a-frame to the
 l-frame.
 Transpose the resulting matrix to obtain the derivative of the inverse
 transformation (from the l-frame to the a-frame).
\end_layout

\begin_layout Enumerate
Calculate the (minor) correction for inertial effects and 
\emph on
subtract
\emph default
 it from the derivative matrix of the transformation from the l-frame to
 the a-frame.
 (Normally this is added during the forward transformation.)
\end_layout

\begin_layout Enumerate
Multiply the result by the l-frame-to-a-frame transformation matrix.
 The result is the skew-symmetric representation of the measured rotation
 rates.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-retrieved-rotations, include=TRUE, fig.cap='Comparison of measured
 body rotation rates and those determined by differentiating the attitude
 angles.
 The red lines denoted as "delta*10" show the difference between the two
 rates after multiplication by 10 to make the small differences visible.
 The measurements are from DEEPWAVE flight 15, from a period that included,
 chronologically in the plot, maneuvers with rapid pitch variations, a speed
 run with slow pitch variations, a maneuver with rapid changes in sideslip,
 and a full circle.', cache=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

suppressWarnings (print (    ## this avoids printed warning about attribute
 differences
\end_layout

\begin_layout Plain Layout

ggplotWAC (with(D15[setRange(D15, 31200, 34630),], 
\end_layout

\begin_layout Plain Layout

                data.frame(Time, BPITCHR, BP, 10*DBP, BROLLR, BR, 10*DBR,
\end_layout

\begin_layout Plain Layout

                                BYAWR, BY, 10*DBY)),
\end_layout

\begin_layout Plain Layout

           ylab=expression(paste('rotation rate [',degree,' ',s^-1,']')),
\end_layout

\begin_layout Plain Layout

           lwd=c(0.7,0.5,1), lty=c(1,93,1),
\end_layout

\begin_layout Plain Layout

           panels=3,
\end_layout

\begin_layout Plain Layout

           labelL=c('measured', 'from differentiation', 'delta*100'),
\end_layout

\begin_layout Plain Layout

           labelP=c('pitch', 'roll', 'yaw'),
\end_layout

\begin_layout Plain Layout

           legend.position=c(0.5,0.96)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# + geom_label(mapping=aes(x=D15$Time[getIndex(D15,31300)], y=0.2, label='maneuve
rs:'), 
\end_layout

\begin_layout Plain Layout

#              show.legend=FALSE, color='black')
\end_layout

\begin_layout Plain Layout

# layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D15, plotWAC(data.frame(Time, BPITCHR, BP, 10*DBP), ylim=c(-2,2)))
\end_layout

\begin_layout Plain Layout

# with(D15, plotWAC(data.frame(Time, BROLLR, BR, 10*DBR)))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D15, plotWAC(data.frame(Time, BYAWR, BY, 10*DBY), ylim=c(-2,2)))
\end_layout

\begin_layout Plain Layout

# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

# rm(D15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-retrieved-rotations}
\end_layout

\end_inset

 shows the resulting transformed derivative, as the green lines, and the
 measured rotation rates as blue lines.
 They are mostly indistinguishable in these plots, and statistically they
 are nearly identical as characterized at the end of Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Checking-the-rotation"

\end_inset

, so the transformed derivatives are valid estimates of the original rotation
 rates and should be suitable for use in the Kalman filter discussed in
 the next section.
\end_layout

\begin_layout Subsubsection
Accelerations
\end_layout

\begin_layout Standard
The retrieval of accelerations is similar: Differentiate the l-frame velocity
 components {VEW, VNS, VSPD} to find the l-frame accelerations, apply the
 correction for inertial effects with opposite sign vs.
\begin_inset space ~
\end_inset

that used for the a-frame-to-l-frame transformation, then transform the
 results from the l-frame to the a-frame using the inverse of the transformation
 matrix used for the opposite transformation.
 See the workflow document for more detail, and refer to the code in the
 R chunk 
\begin_inset Quotes eld
\end_inset

checking-accelerations
\begin_inset Quotes erd
\end_inset

 for detailed R statements.
 This is the same procedure that was used in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Checking-accelerations"

\end_inset

 to check the calibration of the accelerometers.
\end_layout

\begin_layout Subsection
Simpler algorithms
\end_layout

\begin_layout Subsubsection
Reasons for considering alternate algorithms
\end_layout

\begin_layout Standard
The Kalman filter discussed in the next section will produce estimated errors
 for the attitude angles, but it is possible to calculate a simpler estimate
 with some assumptions about the source of the error.
 Such an estimate was developed in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

, Sect.
\begin_inset space ~
\end_inset

6.4; cf.
\begin_inset space ~
\end_inset

Eqs.
\begin_inset space ~
\end_inset

57.
 The intent of this section is to provide alternative corrections for all
 three attitude angles on the basis of relatively simple comparisons between
 measurements available from the combination of an INS and a GPS receiver.
 These corrections can be applied to archived data and so can lead to improvemen
ts in datasets collected in past as well as future projects, and they provide
 valuable comparisons to the results that will be obtained from the Kalman
 filter.
 
\end_layout

\begin_layout Standard
In the case of pitch and roll, the solution relies on observation of the
 derivatives in the errors in ground-speed components and position, which
 arise primarily from errors in those angles.
 For heading, the accelerations measured by the INS are compared to those
 determined by differentiating the GPS-provided ground-speed components.
 This difference is dependent on the error in heading because the accelerations
 are measured in the body frame of the aircraft (here called
\emph on
 
\emph default
the 
\begin_inset Formula $a$
\end_inset

-frame), and translation to an Earth-reference frame (or 
\emph on
l
\emph default
-frame) involves the heading.
 An error in heading results in a difference between the two sets of measured
 accelerations, and that difference can be used to estimate the error in
 heading.
 As developed here, all three corrections are applied to measurements after
 acquisition, not during recording, to be able to use algorithms that smooth
 measurements over centered intervals.
 This also makes it possible to correct archived data as long as the full
 set of INS measurements including accelerations and measurements of ground-spee
d by both an INS and a GPS receiver are available.
\end_layout

\begin_layout Subsubsection
Correcting the pitch and roll
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-pitch"

\end_inset


\end_layout

\begin_layout Standard
An inertial system aligns during initialization to detect the local vertical
 direction and then calculates the new vertical direction as the aircraft
 moves (changing the local vertical direction) and accelerates (which can
 cause gyros to precess).
 Any misalignment present at initialization persists but also will oscillate
 and will cause errors in roll and pitch to mix as the aircraft changes
 flight direction.
 For the inertial system used on the NSF/NCAR GV, the standard uncertainty
 associated with this measurement is 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 in both roll and pitch for flight duration of a few hours, and the error
 often increases during the flight as heading errors and accelerometer biases
 affect the results.
 
\end_layout

\begin_layout Standard
The work of Schuler (
\begin_inset CommandInset citation
LatexCommand cite
key "Schuler1923"

\end_inset

) showed that coupling among some of these error sources leads to limits
 on the growth of errors and to simultaneous oscillations in some of the
 measurement errors.
 In particular, an error in pitch leads to an error in horizontal acceleration
 because gravity is resolved to have a horizontal component, and integration
 of that error in horizontal acceleration leads to a position error that
 grows so as to compensate for the false component of acceleration arising
 from the original error in pitch.
 However, when the error in pitch is reduced to zero, errors in position
 and velocity have been accumulated and those lead to growth of the error
 in pitch in the direction opposite to the original error.
 The result is a Schuler oscillation having a period of 
\begin_inset Formula $T_{Sch}=(R_{e}/g)^{0.5}/(2\pi)\approx5064\thinspace s$
\end_inset

 or 84.4
\begin_inset space \thinspace{}
\end_inset

min, where 
\begin_inset Formula $R_{e}$
\end_inset

 is the radius of the Earth and 
\begin_inset Formula $g$
\end_inset

 the acceleration of gravity.
 
\end_layout

\begin_layout Standard
The existence of this coupling allows estimation of the pitch error if the
 error in horizontal acceleration is known or is negligible That is the
 case if, in addition to the INS, there is a GPS receiver that can provide
 high-quality measurements of Earth-relative velocity.
 Modern GPS receivers, especially if they incorporate differential-GPS correctio
ns or ionospheric corrections, produce velocity measurements that have remarkabl
y low uncertainty, often a few cm/s, so these can be considered a standard
 against which to compare the corresponding IRS-measured velocities.
 The difference between ground-speed components from the two systems thus
 determines the error in INS-measured velocity and, after differentiation,
 the error in horizontal acceleration.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $a_{n}=a_{n}^{*}+\delta a_{n}$
\end_inset

 where 
\begin_inset Formula $a_{n}^{*}$
\end_inset

 is the true northward acceleration of the aircraft and 
\begin_inset Formula $\delta a_{n}$
\end_inset

 is the erroneous acceleration that results from pitch and displacement
 errors, then the error in acceleration is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\delta a_{n}^{(l)}=-g\delta\theta^{(l)}\,\,\,.\label{eq:delta-an}
\end{equation}

\end_inset

where 
\begin_inset Formula $\delta\theta^{(l)}$
\end_inset

 is the error in pitch.
 The superscripts 
\begin_inset Formula $(l)$
\end_inset

 denote that these pitch and acceleration errors are those present in an
 Earth reference frame or 
\begin_inset Formula $l$
\end_inset

-frame, often called the ENU frame, where the axes are respectively east,
 north, and up.
 Then the error in measured northward acceleration provides a direct measure
 of the error in pitch:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\theta^{(l)}=-\frac{1}{g}\frac{d(\delta v_{n}^{(l)})}{dt}\,\,\,.\label{eq:full-delta-pitch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Because 
\begin_inset Formula $\delta v_{n}$
\end_inset

 is measurable by comparison to measurements from a GPS receiver, the error
 in pitch can be found from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) and the analogous equation for the 
\begin_inset Formula $l$
\end_inset

-frame error in roll, 
\begin_inset Formula $\delta\phi^{(l)}$
\end_inset

:
\begin_inset Foot
status open

\begin_layout Plain Layout
The different signs arise from the different definitions of the angles,
 where a positive pitch error represents a rotation of the platform axis
 in the negative 
\begin_inset Formula $y$
\end_inset

-axis direction but a positive roll error corresponds to a platform rotation
 in the positive 
\begin_inset Formula $x$
\end_inset

-axis direction.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\delta\phi^{(l)} & = & \frac{1}{g}\frac{d(\delta v_{e}^{(l)})}{dt}\,\,\,.\label{eq:delta-phi}
\end{eqnarray}

\end_inset

The differentiated errors in the components of the aircraft ground-speed
 and the errors in position thus provide estimates for corrections to be
 applied to the measurements of pitch and roll.
 Because this correction relies on the observable effects of the errors
 on velocity, it is not sensitive to the source of the error, whether it
 arises from misalignment before flight, bias errors in the INS gyros, or
 other sources except for these exceptions: (i) an error in measured acceleratio
n from the accelerometers that contributes to the velocity errors in a way
 not dependent on the pitch or roll errors; and (ii) a minor dependence
 on error in heading that arises when the pitch and roll errors in the Earth-rel
ative 
\begin_inset Formula $l$
\end_inset

-frame are transformed to the reference frame of the aircraft.
 The latter is negligible for normal heading errors, but the former can
 cause increasing amplitude or drift of the velocity errors.
 Plots of the observed errors in ground-speed components, shown later in
 this document, suggest relatively small changes in the amplitude of the
 Schuler oscillation during most flights, as would be expected if the accelerome
ter errors make only small contributions to the velocity errors.
\end_layout

\begin_layout Standard
In general an additional transformation of angles is needed to obtain the
 pitch and roll errors in the aircraft reference frame, which will here
 be called the 
\begin_inset Formula $a$
\end_inset

-frame.
 The 
\begin_inset Formula $a$
\end_inset

-frame differs from the 
\begin_inset Formula $b$
\end_inset

-frame or body frame often discussed in the inertial-navigation literature
 by having 
\begin_inset Formula $\hat{x}$
\end_inset

 and 
\begin_inset Formula $\hat{y}$
\end_inset

 axes interchanged and the 
\begin_inset Formula $\hat{z}$
\end_inset

 axis reversed to be downward, as is conventional for aircraft.
\end_layout

\begin_layout Standard
This correction procedure has been incorporated into a function 
\begin_inset Quotes eld
\end_inset

CorrectPitch ()
\begin_inset Quotes erd
\end_inset

 that is part of the 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 package.
 Given a data.frame containing appropriate measurements from a flight (in
 particular, VNS, VEW, GGVNS, GGVEW, LAT or LATC, GGALT, THDG, PITCH, ROLL,
 representing respectively the eastward and northward velocity components
 of the aircraft as measured by the INS and the GPS, the latitude, the altitude
 from the GPS, and the heading, pitch, and roll angle), the routine returns
 estimates of the errors in pitch and roll.
 The workflow document accompanying this technical note provides additional
 detail on the algorithm used, and the R code is available in the routine
 
\begin_inset Quotes eld
\end_inset

PitchCorrection.R
\begin_inset Quotes erd
\end_inset

 in the Ranadu package, available at this URL: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/Ranadu.git
\end_layout

\end_inset

, subdirectory 
\begin_inset Quotes eld
\end_inset

R
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Correcting the heading
\end_layout

\begin_layout Standard
A procedure related to that used for pitch is developed here for estimating
 the error in heading.
 The basis for the correction is that an error in heading results in an
 error in how the measured body-relative components of the acceleration
 are transformed to the ENU or 
\emph on
l
\emph default
-frame (in the terminology of the previous discussion of the correction
 for pitch).
 These errors can be detected by comparing the actual acceleration of the
 aircraft (determined from derivatives of the GPS-measured ground-speed
 components, as in the preceding section) to the measurements of acceleration
 after transformation to the 
\emph on
l
\emph default
-frame.
\begin_inset Foot
status open

\begin_layout Plain Layout
Some additional considerations arising from rotation of the earth and rotation
 of the 
\begin_inset Formula $l$
\end_inset

-frame in an inertial frame are discussed in the workflow document.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The accelerations measured by a strap-down inertial system like the Honeywell
 systems on the NCAR/NSF GV are the accelerations in the reference frame
 of the aircraft, here called the 
\begin_inset Formula $a$
\end_inset

-frame.
 To transform these to the 
\emph on
l
\emph default
-frame, the transformation by conventional definition of the attitude angles
 involves a rotation about the roll axis to level the wings, a rotation
 about the pitch axis to level the longitudinal axis of the aircraft, and
 a rotation about the vertical axis as required to point the aircraft to
 the north.
 However, if there is an error in the heading (
\begin_inset Formula $\delta\psi$
\end_inset

) the last rotation will give final components 
\begin_inset Formula $a_{x,y,z}^{(l)}$
\end_inset

 that have respective errors of 
\begin_inset Formula $\delta a_{x}^{(l)}=a_{x}^{(l)}(1-\cos\delta\psi)-a_{y}^{(l)}\sin\delta\psi$
\end_inset

, 
\begin_inset Formula $\delta a_{y}^{(l)}=a_{y}^{(l)}(1-\cos\delta\psi)+a_{x}^{(l)}\sin\delta\psi$
\end_inset

, and 
\begin_inset Formula $\delta a_{z}^{(l)}=0$
\end_inset

 or, for small angles,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\left[\begin{array}{c}
\delta a_{x}^{(l)}\\
\delta a_{y}^{(l)}\\
\delta a_{z}^{(l)}
\end{array}\right] & =\left[\begin{array}{ccc}
0 & -\delta\psi & 0\\
\delta\psi & 0 & 0\\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{c}
a_{x}^{(l)}\\
a_{y}^{(l)}\\
a_{z}^{(l)}
\end{array}\right]\label{eq:heading-error-equation}\\
\delta a_{x}^{(l)} & =-a_{y}^{(l)}\delta\psi\label{eq:ax-error}\\
\delta a_{y}^{(l)} & =a_{x}^{(l)}\delta\psi\label{eq:ay-error}\\
\delta\psi & =\frac{a_{x}^{(l)}\delta a_{y}^{(l)}-a_{y}^{(l)}\delta a_{x}^{(l)}}{(a_{x}^{(l)})^{2}+(a_{y}^{(l)})^{2}}\label{eq:estimator-equation}
\end{align}

\end_inset

The last equation is obtained
\begin_inset Foot
status open

\begin_layout Plain Layout
If the error measure to be minimized is 
\begin_inset Formula $\chi^{2}=(\delta a_{x}+a_{y}\delta\psi)^{2}+(\delta a_{y}-a_{x}\delta\psi)^{2}$
\end_inset

, differentiating 
\begin_inset Formula $\chi^{2}$
\end_inset

 with respect to 
\begin_inset Formula $\delta\psi$
\end_inset

 and setting the result equal to zero gives (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

).
\end_layout

\end_inset

 by minimizing the errors between the values of 
\begin_inset Formula $\delta a_{i}^{(l)}$
\end_inset

 given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax-error"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ay-error"

\end_inset

) and the measured error given by 
\begin_inset Formula $(a_{i}^{*}-a_{i}^{(l)})$
\end_inset

.
 This then gives an estimate of the rotation 
\begin_inset Formula $-\delta\psi$
\end_inset

 that gives the best match between the measured accelerations and those
 determined from the derivatives of the GPS-provided ground-speed components.
 The resulting value of 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) is then an estimate of the error in heading.
\end_layout

\begin_layout Standard
To use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

), the acceleration vector 
\begin_inset Formula $\mathbf{a^{*}}$
\end_inset

 must be determined by differentiation of the GPS-measured velocity components.
 As in the pitch-correction algorithm, the choice made here is to estimate
 the derivatives using Savitzky-Golay polynomials, but now with a 31
\begin_inset space \thinspace{}
\end_inset

s span to avoid excessive distortion in 3-min turns.
 However, this choice affects the uncertainty of the estimate, as follows.
 It was previously estimated that the uncertainty in a measurement of accelerati
on from GPS is at least 0.01
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

/
\begin_inset Formula $\tau$
\end_inset

 where 
\begin_inset Formula $\tau$
\end_inset

 is the time over which the average is calculated.
 For 31-s polynomial fits, the effective averaging time is about 20
\begin_inset space \thinspace{}
\end_inset

s, leading to a minimum uncertainty of about 0.0005
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) indicates that, for an uncertainty in the heading correction of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

 or about 0.002
\begin_inset space ~
\end_inset

radians, the total horizontal acceleration should then be at least 0.0005/0.002=0.2
5
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
\end_layout

\begin_layout Standard
Typical horizontal accelerations in turns exceed 4
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 in the 
\begin_inset Formula $l$
\end_inset

-frame, but horizontal accelerations exceeding 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 are seldom encountered outside of turns.
 The algorithm developed here only provides a valid correction if there
 are regular turns during the flight.
 In the following, heading corrections will be calculated only for periods
 when the horizontal acceleration exceeds 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 to avoid excessive noise and uncertainty.
 It is significant, though, that for a flight that transits in a straight
 line from start to finish, attempts to use these estimates are unlikely
 to be useful.
 Fortunately, in most research flights there are many turns, e.g., as the
 aircraft flies back and forth over a mountain range or flies fixed raster
 patterns for mapping.
 Each turn can provide significant horizontal accelerations that give estimates
 of the heading error, but these estimates are only sporadic and must be
 linked by an extrapolation procedure to obtain valid corrections spanning
 periods without significant acceleration.
 The heading correction therefore has a higher uncertainty than the pitch
 correction and, unlike the pitch correction, depends on particular flight
 maneuvers for successful operation.
 In addition, unlike the pitch error, the heading error is not coupled to
 other errors in ways that limit its growth, so implementing some correction
 procedure is important not only to provide corrections but also to determine
 the estimated magnitude of the uncorrected error.
\end_layout

\begin_layout Standard
Some additional information, especially the details of the transformation
 from the a-frame to the l-frame, are included in the workflow document
 accompanying this technical note.
 The requirements for valid results from this algorithm are as follows:
\end_layout

\begin_layout Itemize
The flight pattern must include maneuvers that provide horizontal accelerations,
 usually turns of at least 30
\begin_inset space \thinspace{}
\end_inset

s duration 
\emph on
in each direction.

\emph default
 The reason is that it is difficult to correct for timing errors in the
 measurements of heading relative to the measured ground-speed components
 from a GPS receiver, and even a delay of 50
\begin_inset space \thinspace{}
\end_inset

ms will, for a turn rate corresponding to a three-minute turn through 360
\begin_inset Formula $^{\circ}$
\end_inset

, lead to a 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 false indication of a heading error.
 However, the error reverses sign with the direction of the turn, so averaging
 the results from left turns and from right turns will correct for this
 false indication of a heading error.
 Course-reversal maneuvers like 
\begin_inset Quotes eld
\end_inset

90-270
\begin_inset Quotes erd
\end_inset

 turns (90
\begin_inset Formula $^{\circ}$
\end_inset

 one direction followed by 270
\begin_inset Formula $^{\circ}$
\end_inset

 the other direction) provide good data for this algorithm, as do 
\begin_inset Quotes eld
\end_inset

60-300-60
\begin_inset Quotes erd
\end_inset

 teardrop turns that are a faster means of returning to the starting point.
 If wind measurements are critical to the research, it may be useful to
 include patterns like 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 turns periodically, with 30
\begin_inset space \thinspace{}
\end_inset

s turns in opposite directions, to provide the needed accelerations.
\end_layout

\begin_layout Itemize
To the extent possible, sampled time series should be corrected for sampling
 delays.
 The most important such correction is the timing of the heading measurement
 from the INS relative to the ground-speed measurements from the GPS.
 In the examples shown in this note, the differences between different turn
 directions were minimized by shifting the heading forward in time by 140
\begin_inset space \thinspace{}
\end_inset

ms.
 The averaging provided by the first item above helps reduce errors from
 timing, but it is still preferable to keep those errors small.
 Full-circle patterns flown in each turn direction provide a sensitive test
 of timing errors.
\end_layout

\begin_layout Standard
Many research flights and research data sets meet these requirements, and
 where wind measurement is important they can be incorporated into flight
 plans for future projects.
 The algorithm implemented here, for which specific R code is available
 in the 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 package (cf.
\begin_inset space ~
\end_inset


\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/WilliamCooper/Ranadu.git
\end_layout

\end_inset

, directory 
\begin_inset Quotes eld
\end_inset

R
\begin_inset Quotes erd
\end_inset

, script 
\begin_inset Quotes eld
\end_inset

HeadingCorrection.R
\begin_inset Quotes erd
\end_inset

), follows these steps:
\end_layout

\begin_layout Enumerate

\emph on
Shift the timing of the heading measurement as needed to match the GPS-receiver
 measurements of ground velocity.
 
\emph default
The result of this procedure is very sensitive to differences in timing
 of measurements from the IRS and GPS, because in turns any lag appears
 as an offset in the accelerations that mimics a heading error.
\end_layout

\begin_layout Enumerate

\emph on
Optionally, apply pitch and roll corrections using the algorithm developed
 in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-pitch"

\end_inset

.
 
\emph default
The measurements of pitch and, to a lesser extent, roll affect the transformatio
n of the accelerations from the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame, but only have a very small effect, so omission of this step normally
 makes no detectable difference in the final heading correction.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Although the correction developed here depends only weakly on the correction
 to pitch and roll, inclusion of this step may protect against or at least
 identify anomalously large errors in pitch.
 Reciprocally, the pitch correction depends on the measured heading, but
 the effect of heading errors are insignificant.
 Omission of this step normally makes no detectable difference.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Differentiate the ground-speed measurements provided by a GPS receiver,
\emph default
 using third-order Savitzky-Golay polynomials spanning 21
\begin_inset space \thinspace{}
\end_inset

s, to obtain reference measurements of horizontal accelerations in the 
\begin_inset Formula $l$
\end_inset

-frame.
 
\end_layout

\begin_layout Enumerate

\emph on
Transform the accelerations measured by the INS in the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame
\emph default
.
 Filter these results also using Savitzky-Golay polynomials of the same
 order and span so that they are smoothed in the same way as the ground-speed
 derivatives.
\end_layout

\begin_layout Enumerate

\emph on
Use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) to obtain estimates of the heading error 
\begin_inset Formula $\delta\psi$
\end_inset

 at each time.

\emph default
 However, apply data restrictions to avoid cases of high uncertainty.
 The most important restriction used here was to require that the total
 horizontal acceleration in the 
\begin_inset Formula $l$
\end_inset

-frame be larger than 
\begin_inset Formula $1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\emph on
Use a search algorithm to identify flight segments with turns
\emph default
 (specifically, magnitude of roll larger than 10
\begin_inset Formula $^{\circ}$
\end_inset

) continuously except for possible gaps of 5
\begin_inset space \thinspace{}
\end_inset

min.
 Require that these flight segments have both right and left turns, with
 at least 25
\begin_inset space \thinspace{}
\end_inset

s of each.
\end_layout

\begin_layout Enumerate

\emph on
For each such segment, calculate the mean correction
\emph default
 and its standard deviation and the mean time for each turn direction.
\end_layout

\begin_layout Enumerate

\emph on
Use cubic spline interpolation
\emph default
 to represent the variation in heading correction over the course of the
 flight.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Two possible choices are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

; of these, the smoother choice is incorporated into the algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Subtract the result given by this interpolation from the measured heading
 to obtain the corrected heading.
\end_layout

\begin_layout Subsubsection
Results from the simple correction algorithms
\end_layout

\begin_layout Standard
Results will be presented later in comparison to the results from the Kalman
 filter.
 See Figs.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:a-frame-errors"

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading}
\end_layout

\end_inset

.
 There are some additional supplemental results in the workflow document.
\end_layout

\begin_layout Subsection
Angle of attack
\end_layout

\begin_layout Standard
As described in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

, the standard empirical representtion of angle of attack has been
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\alpha=c_{0}+\frac{\Delta p_{\alpha}}{q}\left(c_{1}+c_{2}M\right)\label{eq:old-AKRD}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Delta p_{\alpha}$
\end_inset

 is the pressure difference measured on the radome between top and bottom
 ports, 
\begin_inset Formula $q$
\end_inset

 is the dynamic pressure and 
\begin_inset Formula $M$
\end_inset

 is the Mach number calculated from the dynamic and static pressure before
 static-defect corrections are applied.
 The coefficients were found by fitting that formula to a reference that
 assumes there is zero vertical wind:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\alpha^{*}=\theta-\frac{w_{p}}{V}\label{eq:AOAREF}
\end{equation}

\end_inset

where 
\begin_inset Formula $\theta$
\end_inset

 is the pitch angle, 
\begin_inset Formula $w_{p}$
\end_inset

 the rate of climb of the aircraft and 
\begin_inset Formula $V$
\end_inset

 the airspeed.
\end_layout

\begin_layout Standard
An alternate approach is developed here.
 The reference value as given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:AOAREF"

\end_inset

) is split into two components, 
\begin_inset Formula $\alpha^{*}=\alpha_{f}^{*}+\alpha_{s}^{*}$
\end_inset

 that result from applying a Butterworth low-pass filter to 
\begin_inset Formula $\alpha^{*}$
\end_inset

 (in the code, the variable AOAREF) to obtain 
\begin_inset Formula $\alpha_{s}^{*}$
\end_inset

 and then finding 
\begin_inset Formula $\alpha_{f}^{*}$
\end_inset

from 
\begin_inset Formula $\alpha_{f}^{*}=\alpha^{*}-\alpha_{s}^{*}$
\end_inset

, where the 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 subscripts represent the high-pass and low-pass components after filtering.
 These components are then represented by separate fits:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\alpha_{f}=c_{1}\left(\frac{\Delta p_{\alpha}}{q}\right)_{f}=c_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{f}\label{eq:alpha-fast}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\alpha_{s}=d_{0}+d_{1}\left(\frac{\Delta p_{\alpha}}{q}\right)_{s}+d_{2}q_{s}=d_{0}+d_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{s}+d_{2}\mathrm{\{QCF\}}_{s}\label{eq:alpha-slow}
\end{equation}

\end_inset

 where the second equalities represent the standard variable names used
 in normal netCDF archives to represent the corresponding quantities in
 the first equality.
 More complicated representations were tested in both cases, but these appear
 to provide adequate fits without additional terms.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<read-sensitivity-coef>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# load (file='~/RStudio/Reprocessing/AKRD-fit-coef.Rdata')
\end_layout

\begin_layout Plain Layout

cffn <- 19.70547
\end_layout

\begin_layout Plain Layout

cff <- 21.481
\end_layout

\begin_layout Plain Layout

cfs <- c(4.525341674, 19.933222011, -0.001960992)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This approach has a substantial advantage over the approach in standard
 use.
 The important sensitivity to fluctuations is not compromised by efforts
 to represent the slowly varying zero level for angle of attack, and the
 slowly varying zero reference can be represented by more complex equations
 without having those added factors influence the high-frequency response.
 The result is an empirical representation that is appropriate for all recent
 GV projects and that does not need to be changed for each project, as has
 been the case for many recent projects that use the standard representation.
 
\end_layout

\begin_layout Standard
To find the coefficients in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

), a composite data set was constructed from most flights from three recent
 projects, ORCAS, CSET, and DEEPWAVE.
\begin_inset Foot
status open

\begin_layout Plain Layout
For descriptions of these projects, see the descriptions of projects on
 the EOL web site, at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/recent-projects-and-deployments"

\end_inset

.
\end_layout

\end_inset

 A full description of how these coefficients were determined is contained
 in 
\begin_inset CommandInset href
LatexCommand href
name "this document"
target "https://drive.google.com/open?id=0B1kIUH45ca5AUmR1UkNUUVdBRFE"

\end_inset

, and the coefficients from that analysis are used here.
 They are 
\begin_inset Formula $c_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cff,4)}
\end_layout

\end_inset

 and {
\begin_inset Formula $d$
\end_inset

} = {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[2], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[3], 6)}
\end_layout

\end_inset

}.
 Then the variables entering the fits in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

) were obtained by using a low-pass Butterworth forward-and-backward filter
 to find the slowly varying components 
\begin_inset Formula $(\Delta p_{\alpha}/q)_{s}$
\end_inset

 and 
\begin_inset Formula $q_{s}$
\end_inset

, and the first was subtracted from the unfiltered variable to find 
\begin_inset Formula $(\Delta p_{\alpha}/q)_{f}$
\end_inset

.
 The new angle-of-attack variable was then calculated from 
\begin_inset Formula $\alpha=\alpha_{f}+\alpha_{s}$
\end_inset

.
\end_layout

\begin_layout Standard
This calculation gave much less variation from project to project and within
 projects and seemed to provide a standard representation applicable to
 all recent GV projects since a change was made to the radome.
 
\end_layout

\begin_layout Section
The Kalman filter
\end_layout

\begin_layout Subsection
The algorithm used
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Mechanization"

\end_inset

 verified that at least an approximate calculation of the derivatives of
 the state variables is available.
 On that basis, an error-state Kalman filter can be developed, as follows:
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Before presenting that development, however, it is necessary to discuss
 two aspects of the Kalman filter developed here: 
\end_layout

\begin_layout Enumerate
Errors in the pitch and roll angles represent errors in the calculated level
 position of the IRU.
 For a fixed orientation error, when the aircraft turns, the errors in pitch
 and roll intermix, with for example a pitch error during northbound flight
 becoming a roll error during eastbound flight while the roll error becomes
 a pitch error.
 If a Kalman filter is implemented with error terms for pitch and roll in
 the a-frame, there will be large transient errors arising from course changes
 that must be corrected via the Kalman filter, whereas if the filter is
 implemented with errors in the l-frame the respective north and east components
 of the attitude-angle errors remain approximately constant.
 For this reason, it is preferable to implement the filter using attitude-angle
 errors as they appear in the l-frame.
 The correction terms developed by the Kalman filter must then be transformed
 back to the a-frame before they are applied to the measurements of pitch
 and roll.
 
\end_layout

\begin_layout Enumerate
Conventional implementations of Kalman-filter updating use the measurements
 of position and velocity from the GPS receiver as the external measurements
 to which the INS measurements are compared.
 This works well for all but the heading measurement.
 A heading error results in erroneous resolution of measured accelerations
 into l-frame components and so to errors in velocity, but the feedback
 of these errors to heading is slow and noisy.
 Therefore, a more direct method of coupling GPS-derived measurements to
 heading errors will be used by differentiating the GPS-measured valocities
 to obtain independent measurements of acceleration and then using these
 measured l-frame accelerations as additional measurements to be compared
 to the INS solution.
 If there is an error in heading, these accelerations will lead to a difference
 between the GPS-derived direction of l-frame acceleration and the INS-derived
 direction, and this can be considered a direct measurement of heading error.
 Except in turns, the measured l-frame acceleration is too small and noisy
 for this to be effective, but turns produce strong signals and consequent
 constraints on the heading error.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The Kalman filter is then constructed as follows:
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The first step is to initialize an error-state-vector 
\begin_inset Formula $\delta\mathbf{x}$
\end_inset

 from initial measurements of the differences between the INS and GPS values
 of position and velocity.
 Other errors in components of the state vector are unknown at the start
 of the integration and so will be initialized as zero.
 The 15-component vector used here contains the respective errors in latitude,
 longitude, altitude, eastward ground speed, northward ground speed, rate
 of climb, pitch, roll, heading, pitch-axis rotation rate, roll-axis rotation
 rate, yaw-axis rotation rate, lateral component of acceleration, longitudinal
 component of acceleration, and normal component of acceleration.
\end_layout

\begin_layout Enumerate
The covariance matrix 
\begin_inset Formula $\mathbf{V}$
\end_inset

 characterizing the errors in the error-state-vector is also needed.
 This is here initialized to have rather large components because it is
 expected that the GPS measurements will have much lower unceertainty than
 these INS-provided components and that will constrain the covariance matrix
 during the calculation.
 
\begin_inset Formula $\mathbf{V}$
\end_inset

 is initialized as a 15x15 diagonal matrix where the diagonal elements are
 the squares of these values: {2000/
\begin_inset Formula $R_{m}$
\end_inset

, 2000/(
\begin_inset Formula $R_{n}$
\end_inset

cos
\begin_inset Formula $\lambda$
\end_inset

), 500, 2, 2, 2, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 0.3
\begin_inset Formula $^{\circ}$
\end_inset

, 1
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}s^{-1}$
\end_inset

, 0.0005, 0.0005, 0.0005}.
 All entries are in SI units except those labeled as 
\begin_inset Formula $^{\circ}$
\end_inset

, in which case the values are converted to radians before use.
 The variables 
\begin_inset Formula $R_{m}$
\end_inset

 and 
\begin_inset Formula $R_{n}$
\end_inset

 are appropriate radii of the Earth and 
\begin_inset Formula $\lambda$
\end_inset

 is the latitude.
 (See the code) 
\end_layout

\begin_layout Enumerate
The function STMFV() was verified above and so provides at least an approximate
 calculation of the derivatives of the state vector.
 For an error-state Kalman filter, the propagation of the error state can
 be found from the Jacobian of that function of the state vector, so the
 error-state transition matrix 
\begin_inset Formula $\mathbf{T}$
\end_inset

 is the sum of that Jacobian (multiplied by the time step) and the 15-element
 diagonal matrix:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\mathbf{X}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
The noise-covariance matrix 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 represents the noise in the solution.
 This is initialized as indicated in the code, via function GCF.
 The results can be sensitively dependent on these values, and the choices
 made here are the result of tuning to find a set of values that provides
 reasonable results.
 The 15 values used are the squares of the following: {30/
\begin_inset Formula $R_{m}$
\end_inset

, 30/
\begin_inset Formula $(R_{n}\cos\lambda$
\end_inset

), 150, 0.3, 0.3, 0.3, 0.005
\begin_inset Formula $^{\circ}$
\end_inset

, 0.005
\begin_inset Formula $^{\circ}$
\end_inset

, 0.05
\begin_inset Formula $^{\circ}$
\end_inset

, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.003
\begin_inset Formula $^{\circ}$
\end_inset

/s, 0.00002
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

}.
 All units are SI units except for those labeled as degrees, and in those
 cases the values are converted to radians before use.
 These values are used with a 5-s time step, and they may need adjustment
 if a different time step is used.
 The very low value representing noise in the measured accelerations had
 a significant effect on the results.
 Larger values tended to degrade the results for the attitude angles, presumably
 because errors could be attributed to errors in measured accelerations.
 The results from this particular filter will then rely on the assumption
 that, for the most part, errors in acceleration are not significant.
\end_layout

\begin_layout Enumerate
Once 
\begin_inset Formula $\mathbf{T}$
\end_inset

 and 
\begin_inset Formula $\mathbf{Q}$
\end_inset

 are known, the covariance matrix can be updated each time step via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}
\]

\end_inset


\end_layout

\begin_layout Enumerate
The Kalman gain is then given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}
\]

\end_inset

where 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a 15X6 diagonal matrix representing how the six measured differences
 (GPS-INS) correspond to the error-state vector.
 
\begin_inset Formula $\mathbf{R}$
\end_inset

 is the measurement-noise-covariance matrix representing the GPS noise,
 a 6x6 matrix having diagonal elements that are the squares of these components:
 {50/
\begin_inset Formula $R_{m}$
\end_inset

, 50/(
\begin_inset Formula $R_{n}\cos\Phi$
\end_inset

, 100, 0.1, 0.1, 0.1}.
\begin_inset Foot
status open

\begin_layout Plain Layout
Four additional measurements were explored for inclusion, the three measurements
 of acceleration determined by differentiating the measurements of velocity
 components from the GPS receiver and a representation of heading error
 derived from the difference between the angle determined by transforming
 measured accelerations to the l-frame and the corresponding angle determined
 from the GPS-derived horizontal components of the acceleration.
 These complicate the tuning and will not be discussed in this report.
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
Define 
\series bold

\begin_inset Formula $\delta\mathbf{z}$
\end_inset

 
\series default
as the set of nine measurements consisting of the differences between GPS
 and INS positions and velocities.
 The error-state vector is then further updated as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the covariance matrix is updated further according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}
\]

\end_inset


\end_layout

\begin_layout Standard
To apply these equations, it is not necessary to use a high-rate file and
 update at high rate because it is expected that the errors vary slowly.
 However, turns and other maneuvers can introduce spurious effects if time
 delays are not adjusted well.
 For these reasons, a 1-Hz data file will be used for the following example,
 and the measurements of components of the velocity and of the attitude
 angles as well as the rotation rates and accelerations will be shifted
 in time where needed and then smoothed before applying the Kalman filter.
 DEEPWAVE flight 16 was selected, and the measurements were filtered with
 11-s smoothing of accelerations and 301-s smoothing of measured velocity
 components and attitude angles.
 A 5
\begin_inset space ~
\end_inset

s update interval was used for the example that follows.
\end_layout

\begin_layout Standard
The associated program (
\begin_inset Quotes eld
\end_inset

KalmanFilterTechNote.Rnw
\begin_inset Quotes erd
\end_inset

) loads R chunks from a directory called 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 when it runs, so this directory is archived along with the program itself.
 The reason is that a separate program designed to support interactive runs,
 with specification of the archive file to be used and with options to change
 time shifts and calibrations but which omits generation of the text and
 plots in this technical report, can use those same chunks.
 That program is called 
\begin_inset Quotes eld
\end_inset

KalmanFilter.R
\begin_inset Quotes erd
\end_inset

, and the workflow document includes detailed instructions on its use.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
As a check on the uncertainty associated with the accelerometers, the GPS
 measurements of velocity components were differentiated and the resulting
 accelerations transformed to the a-frame and compared to the measured accelerat
ions from the IRU (with correction for the Earth's rotation and the motion
 of the l-frame relative to an inertial frame).
 For the longitudinal acceleration (along the aircraft axis), the linear
 regression of the measured acceleration vs the GPS-derived acceleration
 had offset 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[1], 4)}
\end_layout

\end_inset

 and slope 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa1)[2], 4)}
\end_layout

\end_inset

., with a residual standard error of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa1)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 For the normal component of acceleration, the corresponding values are
 respectively 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(coef(fa3)[2], 4)}
\end_layout

\end_inset

., and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fa3)$sigma, 4)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 These then can be considered calibrations for the accelerometers as well
 as indications of their uncertainty.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
The lateral accelerations were too noisy for a similar calibration because
 lateral accelerations are usually small and short-term except during periods
 with significant slip, which were not present on this flight.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The differentiated measurements of velocity components from the GPS can
 be considered as additional measurements corresponding to the measured
 accelerations.
 This is discussed further in the following sections.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Detecting the error in heading
\begin_inset CommandInset label
LatexCommand label
name "subsec:heading-error"

\end_inset


\end_layout

\begin_layout Standard
Most of the components of the state vector have good feedback from GPS-derived
 measurements, but an exception is the measurement of heading.
 For position and velocity, there is direct correspondence between INS-
 and GPS-derived measurements.
 For pitch and roll, there is strong coupling to errors in the eastward
 and northward components of aircraft velocity.
 However, the coupling of INS-measured heading to GPS observations is not
 a case of strong coupling (to which the Schuler oscillation applies), and
 it is more difficult to update via measurements from the GPS receiver.
 
\end_layout

\begin_layout Standard
As specified above, the differentiated GPS velocities provide an l-frame
 measurement of acceleration, and these can be transformed back to the a-frame
 to provide measurements that correspond to BLATA, BLONGA, and BNORMA.
 However, a difference in a-frame accelerations from the two sources can
 arise not only from errors in the measured accelerations but also (and
 more likely) from an error in heading, which would cause incorrect translation
 between l-frame and a-frame components.
 The source of coupling between GPS-derived measurements and heading is
 via the aircraft-velocity components, because an error in heading causes
 the IRU-measured accelerations to be resolved into the 
\emph on
l-
\emph default
frame incorrectly and so introduces errors in the aircraft-velocity components
 that can be detected via comparison to GPS-provided velocity components.
 Unfortunately, in most cases the measured accelerations are small, resulting
 in large uncertainties in any correction term except during turns.
 
\end_layout

\begin_layout Standard
For these reasons, it is useful to treat heading differently.
 Most of the evidence from filghts that have been examined suggests that
 the heading error is small and changes little during the flight.
 However, the Kalman filter often leads to significant variations (often
 0.2
\begin_inset Formula $^{\circ}$
\end_inset

 or more) accompanied by large variances (of similar magnitude or larger)
 that call the varying result into question.
 The only periods when the heading error is constrained well is during turns,
 when there are significant horizontal accelerations.
 With strong accelerations, the direction of the acceleration is determined
 well and an error in heading leads to errors in how those accelerations
 are translated into the l-frame where they affect the ground-speed vector,
 leading to errors in that vector that can be detected by the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are three possible approaches, all of which have been tried in this
 study:
\end_layout

\begin_layout Enumerate
The Kalman-filter structure as described above will use the errors in velocity
 to correct the state vector.
 Via the derivative coefficient matrix, the horizontal-velocity errors are
 dependent on errors in horizontal-acceleration as well as on attitude-angle
 errors, esp.
\begin_inset space ~
\end_inset

via strong coupling to the errors in roll and pitch.
 The coupling to heading is typically an order of magnitude weaker.
 Without special attention, the coupling to heading potentially can be obscured
 by the other sensitivities, through which the errors in velocity can be
 attributed to error-state components in horizontal acceleration and in
 roll and pitch.
 In turn, an error in heading is dependent mostly on errors in the gyro
 rotation rates.
 These sensitivities make it difficult to obtain a reliable adjustment of
 heading in the standard approach, although an estimate can be obtained.
\end_layout

\begin_layout Enumerate
The 
\emph on
l-
\emph default
frame accelerations measured by differentiating the GPS-derived horizontal
 velocity components can be used as additional components of the observation
 vector, complementing the position and velocity measurements from GPS.
 These accelerations can then be used as independent measurements of acceleratio
n.
 While this provides some additional adjustable parameters for the filter
 associated with the covariances of the GPS-derived accelerations, the errors
 in acceleration can still be attributed to errors in the measured accelerations.
 This seems to add little to the sensitivity, and indeed in tests this led
 to changes in pitch and roll corrections that appeared to produce degraded
 results.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To illustrate the problem, consider the measured horizontal-acceleration
 vector obtained by transforming the measured 
\emph on
a-
\emph default
frame accelerations to the 
\emph on
l-
\emph default
frame.
 If there is no heading error, the azimuth angle corresponding to this l-frame
 vector acceleration should be the same as the azimuth angle of the vector
 acceleration determined by differentiating the GPS-measured components
 of horizontal velocity.
 The difference is a measure of the heading error: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\arctan\left(\frac{a_{e}^{(l)}}{a_{n}^{(l)}}\right)-\arctan\left(\frac{\dot{v}_{e}}{\dot{v}_{n}}\right)\label{eq:Hcorr}
\end{equation}

\end_inset

where 
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

 and 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

 are the 
\emph on
l-
\emph default
frame accelerations obtained by transforming the IRU-measured accelerations
 from the 
\emph on
a-
\emph default
frame to the 
\emph on
l-
\emph default
frame and 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

 are the eastward and northward components of the acceleration obtained
 from the time-derivatives of the GPS-measured eastward and northward velocity
 components 
\begin_inset Formula $v_{e}$
\end_inset

 and 
\begin_inset Formula $v_{n}$
\end_inset

.
 The assumption made when using this formula is that the errors in the INS-produ
ced accelerations in the 
\emph on
l-
\emph default
frame arise from the heading error with negligible contribution from errors
 in the accelerometers themselves.
 If this is the case, it would be possible to base the heading correction
 on this formula alone, but the more general case needs to consider how
 this might be influenced by errors in accelerations.
 Appropriately incorporating this measurement of heading error into the
 Kalman filter would allow for the possibility that measured accelerations
 as well as the heading need to be adjusted.
\end_layout

\begin_layout Standard
Because significant horizontal accelerations occur mostly in turns when
 both angles in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) are changing rapidly, it is very important to have correct relative timing
 between the INS measurement of heading and the GPS measurement of velocity.
\begin_inset Foot
status open

\begin_layout Plain Layout
As an illustration, a 50-ms delay in heading during a 3-min turn causes
 a shift in heading relative to the correct time of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

, so adjustment to at least this uncertainty is desirable.
 
\end_layout

\end_inset

 The GPS measurements are assigned correct times by the GPS receiver and
 represent a standard clock against which to compare other measurements.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that the relative timing between the IRU and the GPS can drift
 enough during some flights to introduce significant errors.
\end_layout

\end_inset

 If the GPS-vs-INS time shift is not removed, a bias will be introduced
 into the heading correction that varies with turn direction.
 Therefore the following procedure will be followed to remove this time
 shift:
\end_layout

\begin_layout Enumerate
Differentiate the GPS-provided measurements to obtain 
\begin_inset Formula $\dot{v}_{e}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Transform the unshifted body accelerations to the 
\emph on
l-
\emph default
frame, with rotation corrections, to obtain the eastward and northward component
s of acceleration (
\begin_inset Formula $a_{e}^{(l)}$
\end_inset

, 
\begin_inset Formula $a_{n}^{(l)}$
\end_inset

) in the local-level frame.
 
\end_layout

\begin_layout Enumerate
Find the heading correction for unshifted measurements by calculating 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

).
\end_layout

\begin_layout Enumerate
Calculate the running-standard-deviation of 
\begin_inset Formula $\delta\psi$
\end_inset

 spanning 30 seconds.
 Select the subset of 
\begin_inset Formula $\delta\psi$
\end_inset

 for which that standard deviation is less than 0.2
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Fit the subset to find the slope 
\begin_inset Formula $b$
\end_inset

 in the relationship 
\begin_inset Formula $\delta\psi=a+b\thinspace\tan\phi$
\end_inset

 where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle.
 The rate of turn 
\begin_inset Formula $R$
\end_inset

 is related to the roll angle 
\begin_inset Formula $\phi$
\end_inset

 according to the relationship 
\begin_inset Formula $R=g\thinspace\tan\phi/V$
\end_inset

 where 
\begin_inset Formula $V$
\end_inset

 is the airspeed, so 
\begin_inset Formula $\tan\phi=RV/g$
\end_inset

 and 
\begin_inset Formula $\delta\psi=a+bRV/g$
\end_inset

.
 A time delay of 
\begin_inset Formula $\delta t$
\end_inset

 produces a heading error of 
\begin_inset Formula $-R\delta t$
\end_inset

, so 
\begin_inset Formula $-R\delta t=a+bRV/g$
\end_inset

 and the time shift can be estimated from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta t=-b\frac{V}{g}\,\,\,\,.\label{eq:deltaT}
\end{equation}

\end_inset

For example, for DEEPWAVE flight 16, 
\begin_inset Formula $b=0.2146^{\circ}$
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 = 0.003745
\begin_inset space \thinspace{}
\end_inset

rad
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and 
\begin_inset Formula $V\simeq240$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, so (with g=9.8
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

) 
\begin_inset Formula $\delta t=$
\end_inset

-0.092
\begin_inset space ~
\end_inset

s.
 The negative sign indicates that the INS-derived measurement of heading
 appears to be shifted backward (earlier) in time by 92
\begin_inset space \thinspace{}
\end_inset

ms relative to the GPS-derived measurements of aircraft velocity.
 The standard error from the fit indicates that this shift was determined
 with an uncertainty of about 3
\begin_inset space \thinspace{}
\end_inset

ms, so this is a very sensitive way to determine the time shift.
 Note that the result is not influenced by a real error in heading.
\end_layout

\begin_layout Enumerate
Apply this time shift to the measurements of ground speed from the GPS (GGVEW
 and GGVNS), in this case shifting them backward (earlier) in time by 92
\begin_inset space ~
\end_inset

ms while leaving the heading unshifted.
\begin_inset Foot
status open

\begin_layout Plain Layout
The reason that it is preferable to shift GGVEW and GGVNS rather than THDG
 is that it is common in processed files for heading to already be shifted.
 In the case discussed here, heading was already shifted by 
\begin_inset Formula $-80$
\end_inset


\begin_inset space ~
\end_inset

ms.
 However, this was done after processing by the INS, so measurements like
 VEW and VNS have been determined with the heading as used inteernally by
 the INS, not as shifted during subsequent processing.
 The feedback provided by the Kalman filter then relies on the heading before
 shifting, and subsequent shifting of the heading has no effect on those
 measurements.
 It does affect the recalculated transformation from a-frame to l-frame,
 so there would be an inconsistency between (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) and other estimates of the heading error arising from the Kalman filter.
\end_layout

\end_inset

 For a file containing measurements at 1
\begin_inset space ~
\end_inset

Hz, this requires creating an interpolated high-rate vector of measurements,
 shifting that vector, and then extracting a shifted 1-Hz vector from the
 shifted measurements.
 The Ranadu function ShiftInTime() accomplishes this by interpolating to
 a 125-Hz variable.
 The result can be checked by repeating step 5 using the shifted measurements;
 for this case, the deduced shift needed for the shifted time series was
 only 1
\begin_inset space ~
\end_inset

ms.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
It may be useful to incorporate in addition a time dependence, either to
 the time shift or to the correction factor.
 Preliminary study of this indicates that a time dependence is significant,
 as represented for example via he~tan(ROLL)+Ts where Ts=as.vector(Data$Time-Data
$Time[1]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After an appropriate time shift is introduced, (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is an appropriate measurement of heading error to include in the error-measure
ment vector 
\begin_inset Formula $\delta\mathbf{z}$
\end_inset

.
 Here, that is accomplished by adding a seventh component to the measurement
 vector and a seventh row to
\begin_inset Formula $\mathbf{H}$
\end_inset

, where a matrix element 1 then appears in row 7, column 9.
 should have contributions from rows 7 and 8.
 Formulated in this way, the dependence is complex and non-linear, so it
 is simpler to add a 10th component to the measurement vector with value
 given by 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) and associate that directly (with coefficient 1 after appropriate conversion
 from radians to degrees) with column 9 of the information matrix 
\begin_inset Formula $\mathbf{H}$
\end_inset

, which then must have 10 rows and 15 columns.
\end_layout

\begin_layout Standard
Because typical horizontal accelerations in the l-frame are small, this
 estimate of the heading error is too noisy to be useful except in turns
 where the horizontal accelerations are significant, often about 3
\begin_inset space ~
\end_inset

m/s
\begin_inset Formula $^{2}$
\end_inset

.
 In normal straight flight, the standard deviation in the estimate obtained
 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) is around 15
\begin_inset Formula $^{\circ}$
\end_inset

, but in turns this standard deviation reduces to typically about 0.15
\begin_inset Formula $^{\circ}$
\end_inset

.
 This has two important consequences.
 First, flights without turns or other sources of horizontal acceleration
 will lack the information for adjusting the heading.
 so in flights where good wind measurements are important regular turns
 should be part of the flight plans.
 Second, when the GPS-based estimate of the heading error is used, an appropriat
e variance should be assigned to prevent excessive noise from affecting
 the result from the Kalman filter and it will be best to suppress updating
 to the GPS result except when horizontal accelerations are significant
 (perhaps >1
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

).
 For the flight being used as an example, the mean and standard deviation
 of the correction from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) for all cases where the horizontal accelerations exceed this criterion
 are 0.003
\begin_inset Formula $\pm0.15{}^{\circ}$
\end_inset

 for 4295 1-Hz measurements, and the mean error is determined to about 0.002
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\begin_layout Subsection
Smoothing the errors in pitch and roll
\begin_inset CommandInset label
LatexCommand label
name "subsec:Smoothing-the-errors"

\end_inset


\end_layout

\begin_layout Standard
Because the errors in pitch and roll are strongly coupled to the errors
 in velocity, good estimates of these errors should arise naturally from
 the Kalman filter.
 However, the errors so obtained are sometimes noisy in comparison to the
 direct measurements, so application of those corrections will introduce
 undesirable noise into the results from the filter.
 Because it i8s expected that the main source of error is reflected in the
 slowly varying Schuler oscillation, it is preferable to smooth the corrections
 before application to the original measurements to avoid the introduction
 of noise.
 As described above, the errors in pitch and roll are those that apply to
 the original measurements in the a-frame.
 However, if a major source of those errors is platform misalignment that
 varies slowly, the errors will vary smoothly in the l-frame, where l-frame
 pitch error refers to platform north-south tilt and l-frame roll error
 refers to platform east-west tilt.
 In the a-frame, each turn leads to mixing of the pitch and roll errors
 and to abrupt changes, so smoothing in the l-frame followed by transformation
 back to the a-frame produces a better result.
 This will be discussed further after the results from the Kalman filter
 are presented.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
, but this will not be part of this initial study because the accelerometers
 appear to have low uncertainty and because the effect of errors in acceleration
 would also appear as errors in velocity and so should be detected by the
 conventional 6-component measurement vector for Kalman filtering.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-filtered, include=FALSE, echo=FALSE, fig.cap=' ', eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VEW, VEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VNS, VNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, VSPD, VSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVEW, GGVEWF)))
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVNS, GGVNSF)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (subset(D1,, c(Time, GGVSPD, GGVSPDF)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-setup, include=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the chunk is 'sourced' here so the same code can be used in KalmanFilter.R
\end_layout

\begin_layout Plain Layout

# source ('chunks/Kalman-setup.R')
\end_layout

\begin_layout Plain Layout

## Kalman-setup
\end_layout

\begin_layout Plain Layout

## initialize matrices needed by the Kalman filter and load the starting-point
\end_layout

\begin_layout Plain Layout

## for the error-state vector.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initial values of the state vector and error-state vector:
\end_layout

\begin_layout Plain Layout

SV <- with(D1[1, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                               BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
\end_layout

\begin_layout Plain Layout

SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

## also need the corresponding noise vector:
\end_layout

\begin_layout Plain Layout

tau <- 60
\end_layout

\begin_layout Plain Layout

GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data
 record
\end_layout

\begin_layout Plain Layout

  gcf <- vector('numeric', length=15)
\end_layout

\begin_layout Plain Layout

  gcf[1] <- 30 / sp$Rm
\end_layout

\begin_layout Plain Layout

  gcf[2] <- 30 / (sp$Rn * cos (sv$LAT))
\end_layout

\begin_layout Plain Layout

  gcf[3] <- 150
\end_layout

\begin_layout Plain Layout

  gcf[4:6] <- 0.3    ## 0.3
\end_layout

\begin_layout Plain Layout

  gcf[7:8] <- 0.005*Cradeg  ## 0.005
\end_layout

\begin_layout Plain Layout

  gcf[9] <- 0.05*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[10:11] <- 0.003*Cradeg    ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[12] <- 0.003*Cradeg       ## 0.015
\end_layout

\begin_layout Plain Layout

  gcf[13:15] <- 0.00002
\end_layout

\begin_layout Plain Layout

  # gcf <- as.vector(gcf) * sqrt(2/tau)
\end_layout

\begin_layout Plain Layout

  return (gcf)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

gcf <- as.numeric (GCF (SV, D1[1, ]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The measurement model: calculate the measurements of acceleration from
 the GPS to add to the measurement vector
\end_layout

\begin_layout Plain Layout

GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
\end_layout

\begin_layout Plain Layout

DL <- nrow(D1)
\end_layout

\begin_layout Plain Layout

dim(GAEL) <- c(DL, 3)
\end_layout

\begin_layout Plain Layout

## transform to the a-frame
\end_layout

\begin_layout Plain Layout

GAE <- XformLA (D1, GAEL, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

## get rotation-rate corrections to apply to GPS measurements
\end_layout

\begin_layout Plain Layout

LR <- 4.42; LG <- -4.30
\end_layout

\begin_layout Plain Layout

Pdot <- c(0, diff (D1$PITCH*Cradeg)) * Rate  # diff does step-wise differentiati
on
\end_layout

\begin_layout Plain Layout

Hdot <- c(0, diff (D1$THDG*Cradeg))          # see Rate multiplication few
 lines down
\end_layout

\begin_layout Plain Layout

Hdot[is.na(Hdot)] <- 0
\end_layout

\begin_layout Plain Layout

Hdot[Hdot > pi] <- Hdot[Hdot > pi] - 2*pi
\end_layout

\begin_layout Plain Layout

Hdot[Hdot < -pi] <- Hdot[Hdot < -pi] + 2*pi
\end_layout

\begin_layout Plain Layout

Hdot <- Hdot * Rate
\end_layout

\begin_layout Plain Layout

cospsi <- cos (D1$THDG*Cradeg)
\end_layout

\begin_layout Plain Layout

sinpsi <- sin (D1$THDG*Cradeg)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DZ <- with(D1, c(LAT-GGLAT, LON-GGLON, ALT-GGALT, VEW-GGVEW + LG*Hdot*cospsi,
 
\end_layout

\begin_layout Plain Layout

                 VNS-GGVNS - LG*Hdot*sinpsi, ROC-D1[, VROC] + LG*Pdot))
\end_layout

\begin_layout Plain Layout

# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later?
\end_layout

\begin_layout Plain Layout

## The last three components provide direct feedback to measured acceleration
\end_layout

\begin_layout Plain Layout

## in the a-frame but also provide feedback to heading, as developed below
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 9)
\end_layout

\begin_layout Plain Layout

# dim(DZ) <- c(DL, 6)
\end_layout

\begin_layout Plain Layout

# DZ[,1:2] <- DZ[, 1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

## now add the pseudo-measurement of heading error found from the accelerations:
\end_layout

\begin_layout Plain Layout

D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
\end_layout

\begin_layout Plain Layout

D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
\end_layout

\begin_layout Plain Layout

D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the
 std dev
\end_layout

\begin_layout Plain Layout

## add the heading correction to the measurement vector
\end_layout

\begin_layout Plain Layout

DZ <- c(as.vector(DZ), D1$deltaPsi)
\end_layout

\begin_layout Plain Layout

dim(DZ) <- c(DL, 7)
\end_layout

\begin_layout Plain Layout

DZ[ ,1:2] <- DZ[ ,1:2] * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The observation matrix: (the first six and last three components of the
 state error 
\end_layout

\begin_layout Plain Layout

## vector are observable, the latter requiring transformation from l-frame
 to a-frame)
\end_layout

\begin_layout Plain Layout

## components 7-9 are connected to IRU-measured rotation rates via the transform
ation matrix l->a,
\end_layout

\begin_layout Plain Layout

## so matrix H must vary with aircraft attitude angles.
 This is addressed by the GAEL->GAE transform.
\end_layout

\begin_layout Plain Layout

# H <- diag(1, nrow=10, ncol=15)
\end_layout

\begin_layout Plain Layout

# for (k in 7:9) {
\end_layout

\begin_layout Plain Layout

#   H[k,k] <- 0
\end_layout

\begin_layout Plain Layout

#   H[k,k+6] <- 1
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

# H[10,9] <- 1
\end_layout

\begin_layout Plain Layout

H <- diag(1, nrow=7, ncol=15)
\end_layout

\begin_layout Plain Layout

H[7,7] <- 0
\end_layout

\begin_layout Plain Layout

H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component
 9
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## at any time step, assume the measurements are contaminated by noise:
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,100), ncol=10)
\end_layout

\begin_layout Plain Layout

RCV <- matrix (rep(0,49), ncol=7)
\end_layout

\begin_layout Plain Layout

RCV[1,1] <- (10/D1$Rm[1])^2  ## latitude
\end_layout

\begin_layout Plain Layout

RCV[2,2] <- (10/(D1$Rn[1]*cos(SV$LAT)))^2
\end_layout

\begin_layout Plain Layout

RCV[3,3] <- 100^2
\end_layout

\begin_layout Plain Layout

RCV[4,4] <- 0.3^2            ## ve
\end_layout

\begin_layout Plain Layout

RCV[5,5] <- 0.3^2
\end_layout

\begin_layout Plain Layout

RCV[6,6] <- 0.3^2
\end_layout

\begin_layout Plain Layout

# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measureme
nt.
\end_layout

\begin_layout Plain Layout

# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an
 error in heading, not
\end_layout

\begin_layout Plain Layout

# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration
 is used for that.
\end_layout

\begin_layout Plain Layout

# RCV[10,10] <- D1$sdPsi[1]^2
\end_layout

\begin_layout Plain Layout

# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
\end_layout

\begin_layout Plain Layout

# # RCV[10, 10] <- 1000  ## suppress effect
\end_layout

\begin_layout Plain Layout

RCV[7,7] <- 1000  ## but update this each time step
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## initialize covariance matrix with generous variances
\end_layout

\begin_layout Plain Layout

CV <- matrix (rep(0,225), ncol=15)
\end_layout

\begin_layout Plain Layout

CV[1,1] <- 2000^2 / D1$Rm[1]^2
\end_layout

\begin_layout Plain Layout

CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
\end_layout

\begin_layout Plain Layout

CV[3,3] <- 500^2
\end_layout

\begin_layout Plain Layout

CV[4,4] <- 4
\end_layout

\begin_layout Plain Layout

CV[5,5] <- 4
\end_layout

\begin_layout Plain Layout

CV[6,6] <- 4
\end_layout

\begin_layout Plain Layout

CV[7,7] <- (0.3*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[8,8] <- CV[7,7]
\end_layout

\begin_layout Plain Layout

CV[9,9] <- (1*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[12,12] <- (0.01*Cradeg)^2
\end_layout

\begin_layout Plain Layout

CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Q: (initial estimate):
\end_layout

\begin_layout Plain Layout

Q <- diag(gcf^2, 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Kalman-loop, include=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# source ('chunks/Kalman-loop.R')
\end_layout

\begin_layout Plain Layout

## Kalman-loop.R
\end_layout

\begin_layout Plain Layout

## The core of the Kalman-filter iteration
\end_layout

\begin_layout Plain Layout

## Note that all this is over-ridden by the 'code' statement in the header.
\end_layout

\begin_layout Plain Layout

## Make changes to that file instead of this, which is left here for reference.
\end_layout

\begin_layout Plain Layout

## The chunk is the code actually used!!!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Kalman-loop.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DL <- nrow (D1)
\end_layout

\begin_layout Plain Layout

NSTEP <- 5      ## update time
\end_layout

\begin_layout Plain Layout

SVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

CVEF <- array(dim=c(DL/NSTEP, 15))
\end_layout

\begin_layout Plain Layout

## initialize error state vector
\end_layout

\begin_layout Plain Layout

SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
\end_layout

\begin_layout Plain Layout

## (pitch,roll,thdg) (rot.
 rates) (accel components)
\end_layout

\begin_layout Plain Layout

SVE[1:6] <- DZ[1, 1:6]
\end_layout

\begin_layout Plain Layout

## pitch and roll errors are going to be those in the l-frame
\end_layout

\begin_layout Plain Layout

SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions
 here
\end_layout

\begin_layout Plain Layout

## start with zero for gyro and accelerometer errors
\end_layout

\begin_layout Plain Layout

SVEF[1, ] <- SVE
\end_layout

\begin_layout Plain Layout

CVEF[1, ] <- diag (CV)
\end_layout

\begin_layout Plain Layout

# RCV <- RCV * 1000; RCV[3,3] <- RCV[3,3]/100; RCV[6,6] <- RCV[6,6]/100
\end_layout

\begin_layout Plain Layout

# Q <- Q * 0.1; Q[3,3] <- Q[3,3] * 100; Q[6,6] <- Q[6,6] * 100
\end_layout

\begin_layout Plain Layout

pctL <- 0
\end_layout

\begin_layout Plain Layout

MH <- 0    ## 0 suppresses use of deltaPsi as error in heading
\end_layout

\begin_layout Plain Layout

for (i in seq(2*NSTEP, DL, by=NSTEP)) {
\end_layout

\begin_layout Plain Layout

  pct <- as.integer(100*i/DL)
\end_layout

\begin_layout Plain Layout

  # if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d',
 pct));pctL <- pct}
\end_layout

\begin_layout Plain Layout

  SV <- with(D1[i, ], data.frame(LAT, LON, ALT, VEW, VNS, ROC, PITCH, ROLL,
 THDG,
\end_layout

\begin_layout Plain Layout

                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA,
 BNORMA))
\end_layout

\begin_layout Plain Layout

  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
\end_layout

\begin_layout Plain Layout

  Rn <- D1$Rn[i]
\end_layout

\begin_layout Plain Layout

  Rm <- D1$Rm[i]
\end_layout

\begin_layout Plain Layout

  Grav <- D1$Grav[i]
\end_layout

\begin_layout Plain Layout

  sv <- as.vector (SV, mode='numeric')
\end_layout

\begin_layout Plain Layout

  # stmf <- STMFV (sv)
\end_layout

\begin_layout Plain Layout

  dcm <- jacobian (STMFV, sv, .aaframe='a') * dt * NSTEP + diag(15)
\end_layout

\begin_layout Plain Layout

  ## modify to include this?
\end_layout

\begin_layout Plain Layout

  ## modify this to include decaying error terms for the measurements:
\end_layout

\begin_layout Plain Layout

  # dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
\end_layout

\begin_layout Plain Layout

  # dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
\end_layout

\begin_layout Plain Layout

  ## predict the new error-state vector:
\end_layout

\begin_layout Plain Layout

  ## the pitch and roll error derivatives are now those in the a-frame,
 but
\end_layout

\begin_layout Plain Layout

  ##   the pitch/roll error state is in the l-frame.
 Save the l-frame error state:
\end_layout

\begin_layout Plain Layout

  #   SVEL <- SVEA <- SVE
\end_layout

\begin_layout Plain Layout

  #   ## Transform l-frame pitch/roll error state to a-frame
\end_layout

\begin_layout Plain Layout

  #   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

  #   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
\end_layout

\begin_layout Plain Layout

  #   ## apply derivatives to get a-frame change
\end_layout

\begin_layout Plain Layout

  #   SVEA <- dcm %*% SVEA
\end_layout

\begin_layout Plain Layout

  #   ## transform back to l-frame
\end_layout

\begin_layout Plain Layout

  #   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

  #   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  SVE <- dcm %*% SVE    ## take time step in error-state vector
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## update the covariance matrix:
\end_layout

\begin_layout Plain Layout

  CV <- dcm %*% (CV %*% t(dcm)) + Q
\end_layout

\begin_layout Plain Layout

  ## the Kalman gain:
\end_layout

\begin_layout Plain Layout

  if (is.na(D1$sdPsi[i]) || (sqrt(D1$LACCX[i]^2+D1$LACCY[i]^2) < 1)) {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- 0
\end_layout

\begin_layout Plain Layout

    # DZ[i, 7] <- NA
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    H[7,9] <- MH
\end_layout

\begin_layout Plain Layout

    RCV[7, 7] <- 10*D1$sdPsi[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Kb <- solve (H %*% CV %*% t(H) + RCV)
\end_layout

\begin_layout Plain Layout

  K <- CV %*% t(H) %*% Kb
\end_layout

\begin_layout Plain Layout

  DZZ <- DZ[i, ] - H %*% SVE
\end_layout

\begin_layout Plain Layout

  SVE <- SVE + K %*% DZZ
\end_layout

\begin_layout Plain Layout

  CV <- CV - K %*% H %*% CV
\end_layout

\begin_layout Plain Layout

  SVEF[i/NSTEP, ] <- SVE
\end_layout

\begin_layout Plain Layout

  CVEF[i/NSTEP, ] <- diag(CV)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## interpolate the results over the full data.frame:
\end_layout

\begin_layout Plain Layout

IntFilter <- function (X, inRate, outRate) {
\end_layout

\begin_layout Plain Layout

  if (inRate == outRate) {return (X)}
\end_layout

\begin_layout Plain Layout

  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
\end_layout

\begin_layout Plain Layout

  x <- 0:(length(X)-1)
\end_layout

\begin_layout Plain Layout

  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
\end_layout

\begin_layout Plain Layout

  T <- A$y
\end_layout

\begin_layout Plain Layout

  T <- signal::filter(signal::sgolay(4,75),T)
\end_layout

\begin_layout Plain Layout

  ## now shift to match 25-Hz:
\end_layout

\begin_layout Plain Layout

  n <- as.integer (ratio / 2)
\end_layout

\begin_layout Plain Layout

  NL = length(T)
\end_layout

\begin_layout Plain Layout

  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
\end_layout

\begin_layout Plain Layout

  return (T)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cor <- vector('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (Cor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

VCor <- vector ('numeric', DL*15)
\end_layout

\begin_layout Plain Layout

dim (VCor) <- c(DL, 15)
\end_layout

\begin_layout Plain Layout

X <- SVEF[, 1]
\end_layout

\begin_layout Plain Layout

for (j in 1:15) {
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
\end_layout

\begin_layout Plain Layout

  VCor[VCor[,j] < 0] <- 0 
\end_layout

\begin_layout Plain Layout

  if (j > 6) {next}
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- zoo::na.approx (as.vector (Cor[, j]), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  Cor[is.na(Cor[, j]), j] <- 0
\end_layout

\begin_layout Plain Layout

  Cor[, j] <- signal::filtfilt (signal::butter (3, 1/600), Cor[, j])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# Cor7 <- Cor[, 7]
\end_layout

\begin_layout Plain Layout

# VC7 <- VCor[, 7]
\end_layout

\begin_layout Plain Layout

# .hdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

# Cor[, 7] <- cos(.hdg) * Cor7 - sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# Cor[, 8] <- sin(.hdg) * Cor7 + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# VCor[, 7] <- cos(.hdg) * VC7 - sin(.hdg) * VCor[, 8]
\end_layout

\begin_layout Plain Layout

# VCor[, 8] <- sin(.hdg) * VC7 + cos(.hdg) * VCor[, 8]
\end_layout

\begin_layout Plain Layout

D1$LATKF <- D1$LAT - Cor[, 1]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$LONKF <- D1$LON - Cor[, 2]/Cradeg
\end_layout

\begin_layout Plain Layout

## filter the result to smooth the jumps arising from limited INS resolution:
\end_layout

\begin_layout Plain Layout

D1$LATKF <- zoo::na.approx (as.vector (D1$LATKF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$LONKF <- zoo::na.approx (as.vector (D1$LONKF), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

D1$LATKF[is.na(D1$LATKF)] <- 0
\end_layout

\begin_layout Plain Layout

D1$LONKF[is.na(D1$LONKF)] <- 0
\end_layout

\begin_layout Plain Layout

D1$LATKF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), D1$LATKF)
\end_layout

\begin_layout Plain Layout

D1$LONKF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), D1$LONKF)
\end_layout

\begin_layout Plain Layout

D1$ALTKF <- D1$ALT - Cor[, 3]
\end_layout

\begin_layout Plain Layout

D1$VEWKF <- D1$VEW - Cor[, 4]
\end_layout

\begin_layout Plain Layout

D1$VNSKF <- D1$VNS - Cor[, 5]
\end_layout

\begin_layout Plain Layout

D1$ROCKF <- D1$ROC - Cor[, 6]
\end_layout

\begin_layout Plain Layout

D1$PITCHKF <- D1$PITCH - Cor[, 7]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$ROLLKF <- D1$ROLL - Cor[, 8]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$THDGKF <- D1$THDG - Cor[, 9]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$BPITCHRKF <- D1$BPITCHR - Cor[, 10]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$BROLLRKF <- D1$BROLLR - Cor[, 11]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$BYAWRKF <- D1$BYAWR - Cor[, 12]/Cradeg
\end_layout

\begin_layout Plain Layout

D1$BLATAKF <- D1$BLATA - Cor[, 13]
\end_layout

\begin_layout Plain Layout

D1$BLONGAKF <- D1$BLONGA - Cor[, 14]
\end_layout

\begin_layout Plain Layout

D1$BNORMAKF <- D1$BNORMA - Cor[, 15]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$DLAT <- D1$LATKF-D1$GGLAT
\end_layout

\begin_layout Plain Layout

D1$DLATM <- D1$DLAT * .060 * StandardConstant ('Cmfromnmi')
\end_layout

\begin_layout Plain Layout

D1$CLAT <- -Cor[, 1] / Cradeg
\end_layout

\begin_layout Plain Layout

D1$CLATM <- D1$CLAT * .060 * StandardConstant ('Cmfromnmi')
\end_layout

\begin_layout Plain Layout

D1$DLON <- D1$LONKF-D1$GGLON
\end_layout

\begin_layout Plain Layout

D1$DLONM <- D1$DLON * .060 * StandardConstant ('Cmfromnmi') * cos (D1$GGLAT
 * Cradeg)
\end_layout

\begin_layout Plain Layout

D1$CLON <- -Cor[, 2] / Cradeg
\end_layout

\begin_layout Plain Layout

D1$CLONM <- D1$CLON * .060 * StandardConstant ('Cmfromnmi') * cos (D1$GGLAT
 * Cradeg)
\end_layout

\begin_layout Plain Layout

D1$DALT <- (D1$ALTKF-D1$GGALT)/1000
\end_layout

\begin_layout Plain Layout

D1$CALT <- -Cor[, 3]/1000
\end_layout

\begin_layout Plain Layout

D1$DVEW <- D1$VEWKF-D1$GGVEW
\end_layout

\begin_layout Plain Layout

D1$CVEW <- -Cor[, 4]
\end_layout

\begin_layout Plain Layout

D1$DVNS <- D1$VNSKF-D1$GGVNS
\end_layout

\begin_layout Plain Layout

D1$CVNS <- -Cor[, 5]
\end_layout

\begin_layout Plain Layout

D1$DROC <- D1$ROCKF-D1[, VROC]
\end_layout

\begin_layout Plain Layout

D1$CROC <- -Cor[, 6]
\end_layout

\begin_layout Plain Layout

D1$CPITCH <- -Cor[, 7] / Cradeg
\end_layout

\begin_layout Plain Layout

D1$CROLL <- -Cor[, 8] / Cradeg
\end_layout

\begin_layout Plain Layout

D1$CTHDG <- -Cor[, 9] / Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.hdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

D1$CPL <- (cos(.hdg)*Cor[,7]+sin(.hdg)*Cor[,8]) / Cradeg
\end_layout

\begin_layout Plain Layout

D1$CRL <- (-sin(.hdg)*Cor[,7]+cos(.hdg)*Cor[,8]) / Cradeg
\end_layout

\begin_layout Plain Layout

D1$SDCPL <- sqrt(cos(.hdg)^2*VCor[,7]+sin(.hdg)^2*VCor[,8]) / (Cradeg * 30)
\end_layout

\begin_layout Plain Layout

D1$SDCRL <- sqrt(sin(.hdg)^2*VCor[,7]+cos(.hdg)^2*VCor[,8]) / (Cradeg * 30)
\end_layout

\begin_layout Plain Layout

D1$SDCPA <- sqrt(cos(.hdg)^2*D1$SDCPL^2 + sin(.hdg)^2*D1$SDCRL^2)
\end_layout

\begin_layout Plain Layout

D1$SDCRA <- sqrt(sin(.hdg)^2*D1$SDCPL^2 + cos(.hdg)^2*D1$SDCRL^2)
\end_layout

\begin_layout Plain Layout

D1$CPLF <- signal::filtfilt (signal::butter (3, 1/900), D1$CPL)
\end_layout

\begin_layout Plain Layout

D1$CRLF <- signal::filtfilt (signal::butter (3, 1/900), D1$CRL)
\end_layout

\begin_layout Plain Layout

D1$CPAF <- cos(.hdg)*D1$CPLF - sin(.hdg)*D1$CRLF
\end_layout

\begin_layout Plain Layout

D1$CRAF <- sin(.hdg)*D1$CPLF + cos(.hdg)*D1$CRLF
\end_layout

\begin_layout Plain Layout

## save corrected values, obtained by subtracting the smoothed a-frame correctio
ns:
\end_layout

\begin_layout Plain Layout

D1$PITCHKF <- D1$PITCH - D1$CPAF
\end_layout

\begin_layout Plain Layout

D1$ROLLKF <- D1$ROLL - D1$CRAF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

HE <- VCor[,9]
\end_layout

\begin_layout Plain Layout

HE[HE < 0.00001] <- 0.00001
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], D1$THDG[r]/1000, col='brown', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time, D1$CTHDG-HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time, D1$CTHDG+HE, col='magenta', lwd=0.7)
\end_layout

\begin_layout Plain Layout

# D1$CTHDG <- SmoothInterp (D1$CTHDG, .Length=181)
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(D1$Time, D1$CTHDG, w=1/HE, spar=1.1)
\end_layout

\begin_layout Plain Layout

D1$HCS <- predict(SS, as.numeric(D1$Time))$y
\end_layout

\begin_layout Plain Layout

D1$THDGKF <- D1$THDG - D1$HCS    ## save the corrected heading
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
There are several tests that the corrected values should pass:
\end_layout

\begin_layout Enumerate
Because the GPS measurements of position and aircraft velocity have low
 uncertainty, the corrected values from the Kalman filter should match these
 in long-term average, perhaps with some high-frequency components not present
 in the GPS-provided measurements.
\end_layout

\begin_layout Enumerate
The pitch-correction algorithm developed in the Tech Note that describes
 wind uncertainty for the NSF/NCAR GV should give results in reasonable
 agreement with the corrected values of pitch and roll from the Kalman filter.
\end_layout

\begin_layout Enumerate
The heading-correction algorithm discussed in this memo should also produce
 results consistent with the Kalman-filter results.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Position
\end_layout

\begin_layout Standard
The KF (Kalman filter) results for position, for DEEPWAVE flight 16, are
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-position}
\end_layout

\end_inset

, after conversion to meters.
 The blue lines in the top two panels show that differences between the
 KF and GPS measurements (DLAT=LAT
\begin_inset Formula $-$
\end_inset

GGLAT+CLAT and DLON=LON
\begin_inset Formula $-$
\end_inset

GGLON+CLON where CLAT and CLON are the corrections produced by the Kalman
 filter) are neglibly small for latitude and longitude, at the resolution
 of these plots.
 (0.01
\begin_inset Formula $^{\circ}$
\end_inset

 in latitude corresponds approximately to 1 km.) This good agreement arises
 from the corrections CLAT and CLON shown as the green lines, which show
 a smoothly varying Schuler oscillation.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Before subtraction from the original measurement, this correction has been
 filtered using a three-pole low-pass Butterworth filter with cutoff frequency
 corresponding to a period of 600
\begin_inset space ~
\end_inset

s.
 This avoids the introduction of noise from the Kalman filter that otherwise
 would contaminate the high-frequency variance spectra.
\end_layout

\end_inset

 The offset in vertical position results from the difference between pressure
 altitude, used by the INS, and geometric altitude from the GPS.
 
\end_layout

\begin_layout Standard
At higher resolution, there are step-change features in the KF result that
 are not present in the GPS measurement, at a level of about 10
\begin_inset space ~
\end_inset

m.
 The reason is that this is the resolution at which the original measurements
 from the INS (variables LAT and LON) are recorded, so a smoothly varying
 correction as provided by the Kalman filter preserves these step changes.
 Because the true values of latitude and longitude are not expected to show
 high-frequency components at these frequencies, the results after correction
 are further filtered using a low-pass filter with a cutoff frequency correspond
ing to about 10
\begin_inset space ~
\end_inset

s.
 This effectively smooths the jumps arising from the original measurements
 from the INS and leads to agreement between the KF and GPS values corresponding
 to about 10
\begin_inset space ~
\end_inset

m standard deviation for the part of the flight track that excludes the
 initial climb and final descent.
 Some part of this standard deviation likely arises from minor time shifts
 between the measurements from the INS and GPS.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-position, include=TRUE, fig.cap='Comparison of the KF (Kalman
 filter), GPS, and INS values of position for DEEPWAVE flight 16.
 DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter
 result and GPS measurement, while CLAT, CLON, and CALT (green lines) are
 the corrections applied to the original INS values by the Kalman filter.',
 cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

r <- setRange (D1, 70000, 122000)
\end_layout

\begin_layout Plain Layout

ggplotWAC (with (D1[r, ],
\end_layout

\begin_layout Plain Layout

                 data.frame(Time, DLONM, CLONM, DLATM, CLATM, DALT, CALT)),
\end_layout

\begin_layout Plain Layout

           ylab=expression (paste ('difference in position [km]')),
\end_layout

\begin_layout Plain Layout

           panels=3, 
\end_layout

\begin_layout Plain Layout

           labelL=c('KF-GPS', 'correction'),
\end_layout

\begin_layout Plain Layout

           labelP=c('east', 'north', 'up'),
\end_layout

\begin_layout Plain Layout

           legend.position=c(0.2,0.68)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

sdZ <- sd(D1$DALT[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

sdvew <- sd(D1$GGVEW[r] - D1$VEWKF[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

sdvns <- sd(D1$GGVNS[r] - D1$VNSKF[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

meanvz <- mean(D1$ROCKF[r] - D1[r, VROC], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

sdvz <- sd(D1[r, VROC] - D1$ROCKF[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bottom panel in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-position}
\end_layout

\end_inset

 shows that a significant offset is required to correct the altitude, as
 expected because the INS-provided altitude is updated to the pressure altitude
 while the GPS provides geometric altitude above MSL.
 The repetitive pattern in the correction arises from the repeated portions
 of the flight track, which passed over the South Island of New Zealand
 in retracing patterns.
 The updating effectively adjusts the altitude to match the GPS-measured
 altitude, with a standard deviation in the central part of this flight
 track that was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(D1$DALT[r], na.rm=TRUE), 0)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m.
 
\end_layout

\begin_layout Standard
The result then is that the KF values are in agreement with the GPS-provided
 measurements of position to within about 10
\begin_inset space ~
\end_inset

m in each component of the position vector.
 The uncertainty arising from the calculated covariance matrix also indicates
 uncertainty for individual measurements of latitude or longitude corresponding
 to about 10
\begin_inset space ~
\end_inset

m.
\end_layout

\begin_layout Subsubsection
Ground-speed components
\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-velocity}
\end_layout

\end_inset

 shows the corresponding differences between the aircraft-velocity components
 and the GPS-provided measurements, for the same flight as that shown in
 the preceding figure.
 For the two horizontal components of ground speed, the mean difference
 between KF and GPS results is negligible (
\begin_inset Formula $<0.00001$
\end_inset


\begin_inset space ~
\end_inset

m/s) and the standard deviation of this difference is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdvns, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s, mostly arising in turns and likely the result of small timing differences
 between INS-provided and GPS-provided measurements.
 There does not appear to be a problem with resolution for the INS variables
 (VEW and VNS) as there was for position, so no further smoothing of these
 results is needed.
 Indeed, plots of the KF and GPS variables for short time periods indicate
 that there is more noise in the GPS-provided variables (GGVEW and GGVNS)
 than in the KF variables, so using these variables in the calculation of
 horizontal wind may lead to better high-frequency spectral characteristics
 than those obtained using the GPS-provided variables.
 This will be explored further in Sect.
\begin_inset space ~
\end_inset

XXX [later section discussing the impact of the KF on wind measurements).
\end_layout

\begin_layout Standard
The difference between the KF and GPS variables for rate-of-climb of the
 aircraft, shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-velocity}
\end_layout

\end_inset

, is more significant and needs further discussion.
 This calculation was first done using the INS-provided variable VSPD as
 the vertical-motion component of the state variable.
 While the mean values were similar, the standard deviation in this difference
 was about 0.28
\begin_inset space ~
\end_inset

m/s, which is larger than expected or desirable.
 The difficulty likely arises from the INS variable VSPD, which is processed
 internally in the INS before being provided to the GV data system for recording.
 Studies of this variable indicate that it has been filtered and shifted
 in time, and the INS processing includes a baro-loop that updates to the
 pressure altitude.
 This memo (Recommendation161107f.pdf) argues that VSPD is a poor variable
 to use when calculating the vertical wind and that an alternative variable
 (ROC) would provide a better representation of the rate of climb of the
 aircraft.
 That new variable has been used in the present calculation instead of VSPD
 because it gives a better representation of the rate of climb while still
 being independent of the GPS measurements.
 The Kalman filter then updates that variable to the GPS measurement (GGVSPD),
 to produce the new variable ROCKF that is shown in this plot.
 The mean difference between the GPS value and the Kalman filter was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanvz,3)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s, with standard deviation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdvz, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s.
 Section
\begin_inset space ~
\end_inset

XXX explores the characteristics of the new variable (ROCKF) as it would
 influence calculation of the vertical wind.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-velocity, include=TRUE, fig.cap="Comparison of the KF, GPS,
 and INS values of aircraft-velocity components for DEEPWAVE flight 16.
 Blue lines show the differences between the Kalman-filter results and the
 corresponding GPS-provided values, while the green lines (red line in the
 bottom panel) show the corrections applied to the original INS values by
 the Kalman filter.", cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ggplotWAC (with (D1[r, ],
\end_layout

\begin_layout Plain Layout

                 data.frame(Time, DVEW, CVEW, DVNS, CVNS, DROC, CROC)),
\end_layout

\begin_layout Plain Layout

           ylab=expression (paste ('velocity component [m ',s^-1,']')),
\end_layout

\begin_layout Plain Layout

           panels=3, 
\end_layout

\begin_layout Plain Layout

           labelL=c('KF-GPS', 'correction'),
\end_layout

\begin_layout Plain Layout

           labelP=c('east', 'north', 'up'),
\end_layout

\begin_layout Plain Layout

           legend.position=c(0.2, 0.97)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Fig7.png
	width 98text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Errors in pitch and roll after transformation to the l-frame (blue lines).
 The red lines result from the application of a centered low-pass third-order
 Butterworth filter to the errors, where the filter cutoff frequency corresponds
 to a period of 900 s.
 The shaded ribbon shows the estimated standard uncertainty.
\begin_inset CommandInset label
LatexCommand label
name "fig:Errors-in-pitch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Roll and pitch
\end_layout

\begin_layout Standard
The primary value of the Kalman-filter solution is that it can improving
 the measurements of attitude angles.
 Measurements of position and velocity with good quality are already available
 from the GPS, so the results in this sub-section are the primary reason
 for considering use of this Kalman filter to improve the measurements of
 wind.
 As discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Smoothing-the-errors"

\end_inset

, it is expected that the errors in pitch and roll will vary more smoothly
 in the l-frame than in the a-frame because each turn changes how any platform
 misalignment is resolved into pitch and roll errors.
 It is therefore useful to transform the pitch and roll errors to the l-frame
 for smoothing by averaging or filtering.
 The transformation is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{eqnarray}
\delta\theta^{(l)} & = & \cos\psi\thinspace\delta\theta^{(a)}+\sin\psi\thinspace\delta\phi^{(a)}\label{eq:lpitch}
\end{eqnarray}

\end_inset


\begin_inset Formula 
\begin{eqnarray}
\delta\phi^{(l)} & = & -\sin\psi\thinspace\delta\theta^{(a)}+\cos\psi\thinspace\delta\phi^{(a)}\label{eq:lroll}
\end{eqnarray}

\end_inset

where 
\begin_inset Formula $\theta$
\end_inset

 is pitch, 
\begin_inset Formula $\phi$
\end_inset

 is roll, 
\begin_inset Formula $\psi$
\end_inset

 is heading, and the superscripts indicate the reference frame.
 After this transformation is applied to the error-state vector produced
 by the Kalman filter, the pitch and roll errors in the l-frame are as shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Errors-in-pitch"

\end_inset

.
 The Schuler oscillation is evident in both, with some departures that are
 mostly associated with turns.
 Also shown in this plot is the result of applying a low-pass third-order
 Butterworth filter with 900
\begin_inset space ~
\end_inset

s cutoff period to the errors.
 The result is a smoothly varying error signal dominated by the Schuler
 oscillation that eliminates much of the apparent noise introduced by the
 Kalman filter.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:a-frame-errors"

\end_inset

 shows the result of transforming the smoothed error signal back to the
 a-frame.
 These estimated errors are then subtracted from the original measurements
 to obtain the results from the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Fig9.png
	width 98text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Errors in pitch and roll (blue lines) that result from transforming the
 filtered result in the previous figure back from the l-frame to the a-frame.
 The corrections needed to these variables when calculating the wind are
 to subtract these values from the measurements produced by the INS.
 The red lines show the result of the separate pitch-correction function
 discussed in the text.
 The shaded ribbon shows the estimated standard uncertainty in the Kalman-filter
 result.
\begin_inset CommandInset label
LatexCommand label
name "fig:a-frame-errors"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variances associated with l-frame pitch and roll can be found by appropriate
 derivation from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lpitch"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:lroll"

\end_inset

).
 The resulting variances correspond to a standard deviation of typically
 about 0.2
\begin_inset Formula $^{\circ}$
\end_inset

, but that then is reduced by an appropriate factor representing the reduction
 in standard deviation from averaging many points, as was done with the
 low-pass filter with 900
\begin_inset space ~
\end_inset

s cutoff.
 Averaging 900 points would reduce the expected standard deviation by a
 factor of 1/30, so this seems an appropriate factor to use when representing
 the smoothed-correction uncertainty.
 The gray ribbon in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Errors-in-pitch"

\end_inset

 shows the resulting standard uncertainty in pitch and roll in the l-frame,
 and this then leads to similar standard uncertainty in the a-frame for
 the smoothed error estimates, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:a-frame-errors"

\end_inset

.
 The mean standard deviation obtained in this way is 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 for both pitch and roll in either the a-frame or l-frame, so this is reasonable
 estimate of the uncertainty after correction using the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout
with(D1[r, ], plotWAC(data.frame(Time, CPL, CPLF), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout
                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame pitch
 error'))
\end_layout

\begin_layout Plain Layout
for (k in seq(1, length(r), 120)) {lines(c(D1$Time[r[k]], D1$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout
        c(D1$CPLF[r[k]]+D1$SDCPL[r[k]], D1$CPLF[r[k]]-D1$SDCPL[r[k]]), 
\end_layout

\begin_layout Plain Layout
        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout
op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
with(D1[r, ], plotWAC(data.frame(Time, CRL, CRLF), col=c('blue', 'red'),
 
\end_layout

\begin_layout Plain Layout
                        lwd=c(1,2), ylim=c(-0.05,0.05), ylab='l-frame roll
 error'))
\end_layout

\begin_layout Plain Layout
for (k in seq(10, length(r), 120)) {lines(c(D1$Time[r[k]], D1$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout
        c(D1$CRLF[r[k]]+D1$SDCRL[r[k]], D1$CRLF[r[k]]-D1$SDCRL[r[k]]), 
\end_layout

\begin_layout Plain Layout
        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
PC <- CorrectPitch(D1, .span=901)
\end_layout

\begin_layout Plain Layout
D1$PC <- PC[, 1]
\end_layout

\begin_layout Plain Layout
D1$RC <- PC[, 2]
\end_layout

\begin_layout Plain Layout
op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
with(D1[r, ], plotWAC(data.frame(Time, CPAF, PC), col=c('blue', 'red'), 
\end_layout

\begin_layout Plain Layout
                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame
 pitch error'))
\end_layout

\begin_layout Plain Layout
for (k in seq(10, length(r), 120)) {lines(c(D1$Time[r[k]], D1$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout
        c(D1$CPAF[r[k]]+D1$SDCPA[r[k]], D1$CPAF[r[k]]-D1$SDCPA[r[k]]), 
\end_layout

\begin_layout Plain Layout
        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout
op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout
with(D1[r, ], plotWAC(data.frame(Time, CRAF, RC), col=c('blue', 'red'), 
\end_layout

\begin_layout Plain Layout
                        lwd=c(1,2), lty=c(1,2), ylim=c(-0.05,0.05), ylab='a-frame
 roll error'))
\end_layout

\begin_layout Plain Layout
for (k in seq(10, length(r), 120)) {lines(c(D1$Time[r[k]], D1$Time[r[k]]),
 
\end_layout

\begin_layout Plain Layout
        c(D1$CRAF[r[k]]+D1$SDCRA[r[k]], D1$CRAF[r[k]]-D1$SDCRA[r[k]]), 
\end_layout

\begin_layout Plain Layout
        lwd=0.7, col='black')}
\end_layout

\begin_layout Plain Layout
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
# VC7 <- (cos(.hdg)^2*VCor[, 7] + sin (.hdg)^2*VCor[,8])
\end_layout

\begin_layout Plain Layout
# VC7[VC7 < 0.000006] <- 0.000006
\end_layout

\begin_layout Plain Layout
# SP <- smooth.spline(D1$Time[r], D1$CPL[r], w=1/VC7[r], spar=0.7)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-angles, include=TRUE, fig.cap=c("The result of transforming
 the filtered result shown in the previous figure back to the a-frame, for
 pitch and roll errors.
 Also shown as red lines are the results from the Ranadu routine CorrectPitch()."
), dev='cairo_pdf', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# with(D1[r, ],
\end_layout

\begin_layout Plain Layout

#      ggplotWAC (data.frame(Time, CPL, CPLF, CRL, CRLF),
\end_layout

\begin_layout Plain Layout

#                 col=c('blue', 'red'), lwd=c(1.4, 0.8), lty=c(1,1),
\end_layout

\begin_layout Plain Layout

#                 ylab=expression (paste ('l-frame error [',degree,']')),
\end_layout

\begin_layout Plain Layout

#                 panels=2, labelL=c('KF value', 'smoothed'),
\end_layout

\begin_layout Plain Layout

#                 labelP=c('pitch', 'roll')
\end_layout

\begin_layout Plain Layout

#      )
\end_layout

\begin_layout Plain Layout

# )
\end_layout

\begin_layout Plain Layout

## must construct using many of the elements of ggplotWAC but in this order:
\end_layout

\begin_layout Plain Layout

d1 <- with(D1[r,], data.frame(Time, CPL, CPLF, CRL, CRLF))
\end_layout

\begin_layout Plain Layout

lines_per_panel <- 2; panels <- 2
\end_layout

\begin_layout Plain Layout

labelL=c('KF value', 'smoothed')
\end_layout

\begin_layout Plain Layout

labelP=c('pitch', 'roll')
\end_layout

\begin_layout Plain Layout

DL <- nrow(d1)
\end_layout

\begin_layout Plain Layout

VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
\end_layout

\begin_layout Plain Layout

PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
\end_layout

\begin_layout Plain Layout

dd <- data.frame(reshape2::melt(d1, 1), VarGroup, PanelGroup)
\end_layout

\begin_layout Plain Layout

lvl <- levels(dd$VarGroup)
\end_layout

\begin_layout Plain Layout

d2 <- with(D1[r,], data.frame(Time, "plo"=CPLF-SDCPL, "rlo"=CRLF-SDCRL,
\end_layout

\begin_layout Plain Layout

                             "phi"=CPLF+SDCPL, "rhi"=CRLF+SDCRL))
\end_layout

\begin_layout Plain Layout

## note the required order below:
\end_layout

\begin_layout Plain Layout

de <- data.frame (reshape2::melt(d2, 1, c(2,4,3,5)), VarGroup, PanelGroup)
\end_layout

\begin_layout Plain Layout

g7 <- ggplot(dd, aes(x=Time)) + facet_grid(PanelGroup ~ .) 
\end_layout

\begin_layout Plain Layout

g7 <- g7 + geom_ribbon(aes(x=Time, ymin=value, ymax=value), data=de, alpha=0.25)
 
\end_layout

\begin_layout Plain Layout

g7 <- g7 + geom_line(aes(x=Time, y=value, colour=VarGroup, linetype=VarGroup),
 data=dd)
\end_layout

\begin_layout Plain Layout

g7 <- g7 + ylim(-0.05,0.05)
\end_layout

\begin_layout Plain Layout

g7 <- g7 + scale_linetype_manual ('', labels=lvl, breaks=lvl, values = c(1,1))
\end_layout

\begin_layout Plain Layout

g7 <- g7 + scale_colour_manual('', labels = lvl, breaks=lvl, values = c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

g7 <- g7 + theme_WAC() + theme (legend.position=c(0.5,0.95))
\end_layout

\begin_layout Plain Layout

g7 <- g7 + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)))
\end_layout

\begin_layout Plain Layout

g7 <- g7 + theme(axis.title.x = element_text (size=12))
\end_layout

\begin_layout Plain Layout

g7 <- g7 + labs (x='Time [UTC]', y=expression (paste ('l-frame error [',degree,'
]')))
\end_layout

\begin_layout Plain Layout

## I'm not sure why this is necessary; printing g7 in the usual way did
 not leave
\end_layout

\begin_layout Plain Layout

## the ribbon visible, apparently because the resulting pdf file did not
 include it.
\end_layout

\begin_layout Plain Layout

## Now the plot is generated here, but placed in the document in the LaTeX
 code
\end_layout

\begin_layout Plain Layout

## preceding this chunk.
 This out-of-order sequence requires run
\end_layout

\begin_layout Plain Layout

png (filename='Fig7.png', width=600, height=480, res=150)
\end_layout

\begin_layout Plain Layout

print (g7)
\end_layout

\begin_layout Plain Layout

invisible (dev.off())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PC <- CorrectPitch(D1, .span=901)
\end_layout

\begin_layout Plain Layout

D1$PC <- PC[, 1]
\end_layout

\begin_layout Plain Layout

D1$RC <- PC[, 2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# with(D1[r, ],
\end_layout

\begin_layout Plain Layout

#      ggplotWAC (data.frame(Time, CPAF, PC, CRAF, RC),
\end_layout

\begin_layout Plain Layout

#                 col=c('blue', 'red'), lwd=c(1.4, 0.8), lty=c(1,1),
\end_layout

\begin_layout Plain Layout

#                 ylab=expression (paste ('a-frame error [',degree,']')),
\end_layout

\begin_layout Plain Layout

#                 panels=2, labelL=c('KF smoothed', 'CorrectPitch'),
\end_layout

\begin_layout Plain Layout

#                 labelP=c('pitch', 'roll')
\end_layout

\begin_layout Plain Layout

#      )
\end_layout

\begin_layout Plain Layout

# )
\end_layout

\begin_layout Plain Layout

d1 <- with(D1[r,], data.frame(Time, CPAF, PC, CRAF, RC))
\end_layout

\begin_layout Plain Layout

lines_per_panel <- 2; panels <- 2
\end_layout

\begin_layout Plain Layout

labelL=c('smoothed KF value', 'PC')
\end_layout

\begin_layout Plain Layout

labelP=c('pitch', 'roll')
\end_layout

\begin_layout Plain Layout

DL <- nrow(d1)
\end_layout

\begin_layout Plain Layout

VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
\end_layout

\begin_layout Plain Layout

PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
\end_layout

\begin_layout Plain Layout

dd <- data.frame(reshape2::melt(d1, 1), VarGroup, PanelGroup)
\end_layout

\begin_layout Plain Layout

lvl <- levels(dd$VarGroup)
\end_layout

\begin_layout Plain Layout

d2 <- with(D1[r,], data.frame(Time, "plo"=CPAF-SDCPA, "rlo"=CRAF-SDCRA,
\end_layout

\begin_layout Plain Layout

                             "phi"=CPAF+SDCPA, "rhi"=CRAF+SDCRA))
\end_layout

\begin_layout Plain Layout

## note the required order below:
\end_layout

\begin_layout Plain Layout

de <- data.frame (reshape2::melt(d2, 1, c(2,4,3,5)), VarGroup, PanelGroup)
\end_layout

\begin_layout Plain Layout

g9 <- ggplot(dd, aes(x=Time)) + facet_grid(PanelGroup ~ .) 
\end_layout

\begin_layout Plain Layout

g9 <- g9 + geom_ribbon(aes(x=Time, ymin=value, ymax=value), data=de, alpha=0.25)
 
\end_layout

\begin_layout Plain Layout

g9 <- g9 + geom_line(aes(x=Time, y=value, colour=VarGroup, linetype=VarGroup),
 data=dd)
\end_layout

\begin_layout Plain Layout

g9 <- g9 + ylim(-0.05,0.05)
\end_layout

\begin_layout Plain Layout

g9 <- g9 + scale_linetype_manual ('', labels=lvl, breaks=lvl, values = c(1,1))
\end_layout

\begin_layout Plain Layout

g9 <- g9 + scale_colour_manual('', labels = lvl, breaks=lvl, values = c('blue',
 'red'))
\end_layout

\begin_layout Plain Layout

g9 <- g9 + theme_WAC() + theme (legend.position=c(0.5,0.95))
\end_layout

\begin_layout Plain Layout

g9 <- g9 + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)))
\end_layout

\begin_layout Plain Layout

g9 <- g9 + theme(axis.title.x = element_text (size=12))
\end_layout

\begin_layout Plain Layout

g9 <- g9 + labs (x='Time [UTC]', y=expression (paste ('a-frame error [',degree,'
]')))
\end_layout

\begin_layout Plain Layout

## I'm not sure why this is necessary; printing g9 in the usual way did
 not leave
\end_layout

\begin_layout Plain Layout

## the ribbon visible, apparently because the resulting pdf file did not
 include it.
\end_layout

\begin_layout Plain Layout

## Now the plot is generated here, but placed in the document in the LaTeX
 code
\end_layout

\begin_layout Plain Layout

## preceding this chunk.
 This out-of-order sequence requires run
\end_layout

\begin_layout Plain Layout

png (filename='Fig9.png', width=600, height=480, res=150)
\end_layout

\begin_layout Plain Layout

print (g9)
\end_layout

\begin_layout Plain Layout

invisible (dev.off())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## translate pitch/roll corrections to the a-frame:
\end_layout

\begin_layout Plain Layout

.hdg <- D1$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

C7 <- SmoothInterp (Cor[, 7], .Length=181)
\end_layout

\begin_layout Plain Layout

C8 <- SmoothInterp (Cor[, 8], .Length=181)
\end_layout

\begin_layout Plain Layout

# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
\end_layout

\begin_layout Plain Layout

# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
\end_layout

\begin_layout Plain Layout

# D1$CPITCH <- CPITCH / Cradeg
\end_layout

\begin_layout Plain Layout

# D1$CROLL <- CROLL / Cradeg
\end_layout

\begin_layout Plain Layout

# D1$CPITCH <- SmoothInterp (D1$CPITCH, .Length=181)
\end_layout

\begin_layout Plain Layout

# D1$CROLL <- SmoothInterp (D1$CROLL, .Length=181)
\end_layout

\begin_layout Plain Layout

# D1$CTHDG <- SmoothInterp (D1$CTHDG, .Length=181)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$HC <- -CorrectHeading (D1, .plotfile='./HCPlot.pdf')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plotWAC(subset(D1[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH
 CORRECTION',' [',degree,']')), 
\end_layout

\begin_layout Plain Layout

#         ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position=
'topright')
\end_layout

\begin_layout Plain Layout

# CCPITCH <- D1$CPITCH
\end_layout

\begin_layout Plain Layout

# PCC <- D1$PC
\end_layout

\begin_layout Plain Layout

# ival <- abs(D1$ROLL) > 4
\end_layout

\begin_layout Plain Layout

# CCPITCH[ival] <- NA
\end_layout

\begin_layout Plain Layout

# PCC[ival] <- NA
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], CCPITCH[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], PCC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

# abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# with(D1[r,], plotWAC(data.frame(Time, CPL)))
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], predict(SP, as.numeric(D1$Time))$y[r], col='red')
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], sqrt(VC7[r])+predict(SP, as.numeric(D1$Time))$y[r],
 col='darkgreen')
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], -sqrt(VC7[r])+predict(SP, as.numeric(D1$Time))$y[r],
 col='darkgreen')
\end_layout

\begin_layout Plain Layout

# Y <- predict(SP, as.numeric(D1$Time))$y[r]
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(D1$Time[r], Y, Y+sqrt(VC7[r]), Y-sqrt(VC7[r]), D1$CPL[r]),
 
\end_layout

\begin_layout Plain Layout

#         col=c('blue', 'darkgreen', 'darkgreen', 'red'), lty=c(1,2,2,1))
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(D1[r,],,c(Time, CROLL, RC)), 
\end_layout

\begin_layout Plain Layout

#       ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
\end_layout

\begin_layout Plain Layout

#       ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='to
pright')
\end_layout

\begin_layout Plain Layout

# D1$CROLL[ival] <- NA
\end_layout

\begin_layout Plain Layout

# D1$RC[ival] <- NA
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], D1$CROLL[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], D1$RC[r], lwd=3, col='red')
\end_layout

\begin_layout Plain Layout

# abline(h=0, col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$dP <- D1$deltaPsi/Cradeg
\end_layout

\begin_layout Plain Layout

HA <- with(D1, sqrt(LACCX^2+LACCY^2))
\end_layout

\begin_layout Plain Layout

D1$dP[HA < 1] <- NA
\end_layout

\begin_layout Plain Layout

sddP <- sd(D1$dP[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Heading
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<flight-track, include=TRUE, fig.height=3, fig.width=4, fig.cap="The flight
 track of about 7 h duration for DEEPWAVE flight 16, 4 July 2012.
 In the Kalman filter, the many turns provide constraints on the heading.
 The dashed-line topography shows the South Island of New Zealand.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plotTrack(getNetCDF(fname), .Spacing=NA)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-Kalman-heading, include=TRUE, fig.height=6, fig.cap="(top) Heading
 error estimated from (7), for only those periods of DEEPWAVE flight 16
 where the horizontal acceleration is larger than 1
\backslash

\backslash
 m
\backslash

\backslash
,s$^{-2}$.
 (bottom) Heading correction from the Kalman filter and from Ranadu::CorrectHead
ing (HC, green line).
 A spline representing the smoothed heading correction from the Kalman filter,
 using the estimated inverse variance as weight factor for the spline, is
 shown as the red line.
 Data from DEEPWAVE flight 16.", cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$dP <- D1$deltaPsi/Cradeg
\end_layout

\begin_layout Plain Layout

HA <- with(D1, sqrt(LACCX^2+LACCY^2))
\end_layout

\begin_layout Plain Layout

D1$dP[HA < 1] <- NA
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(D1[r,],,c(Time, dP)))
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

suppressWarnings (
\end_layout

\begin_layout Plain Layout

  with(D1[r, ],
\end_layout

\begin_layout Plain Layout

       ggplotWAC (data.frame(Time, dP),
\end_layout

\begin_layout Plain Layout

                  ylab=expression (paste ('error in heading [',degree,']')),
\end_layout

\begin_layout Plain Layout

                  legend.position=NA, position=c(2,2)
\end_layout

\begin_layout Plain Layout

       )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# sddP <- sd(D1$dP[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

D1$CCTHDG <- SmoothInterp (D1$CTHDG, .Length=181)
\end_layout

\begin_layout Plain Layout

suppressWarnings (
\end_layout

\begin_layout Plain Layout

  with (D1[r, ],
\end_layout

\begin_layout Plain Layout

    ggplotWAC(data.frame(Time, 'Kalman'=CCTHDG, 'Ranadu'=HC, 'spline'=HCS),
 
\end_layout

\begin_layout Plain Layout

      ylim=c(-0.4,0.4), 
\end_layout

\begin_layout Plain Layout

      ylab=expression (paste ('error in heading [',degree,']')),
\end_layout

\begin_layout Plain Layout

      col=c('blue', 'forestgreen', 'red'), position=c(1,2),
\end_layout

\begin_layout Plain Layout

      legend.position=c(0.5,0.95)
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# plotWAC(subset(D1[r, ],, c(Time, CCTHDG, HC)), ylim=c(-0.4,0.4), 
\end_layout

\begin_layout Plain Layout

#         lwd=0.7, legend.position='topright')
\end_layout

\begin_layout Plain Layout

# iv <- HE > 0.0012    # 0.0025
\end_layout

\begin_layout Plain Layout

# D1$CCTHDG[iv] <- NA
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], D1$CCTHDG[r], lwd=3, col='blue')
\end_layout

\begin_layout Plain Layout

# lineWAC(D1$Time[r], D1$HCS[r], col='red')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The heading angle is more difficult to handle because, for most flight condition
s, the heading is poorly constrained and some unrealistic errors with large
 uncertainty are produced by the Kalman filter.
 The flight pattern for the particular flight used for this example included
 frequent changes in flight direction, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:flight-track}
\end_layout

\end_inset

, so those turns result in accelerations that can constrain the heading
 periodically during the flight.
 In Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:heading-error"

\end_inset

, it was argued that (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) provides an estimate of the error in heading.
 However, for the full flight (excluding initial climb and final descent)
 the mean value provided by this formula was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(D1$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 but the standard deviation of the correction provided by this equation
 was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(D1$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so using this correction throughout the flight will likely introduce correctio
ns with large uncertainty.
 To avoid the noise and uncertainty this would introduce, it is useful to
 limit the correction to those times when horizontal accelerations are large.
 The top panel in Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading}
\end_layout

\end_inset

 shows the values from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:Hcorr"

\end_inset

) for those times when the horizontal acceleration was more than 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 The mean value of 
\begin_inset Formula $\delta\psi$
\end_inset

 for these periods was smaller than 0.001
\begin_inset Formula $^{\circ}$
\end_inset

 and the standard deviation of the 4295 values was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sddP, 2)}
\end_layout

\end_inset

.
 This indicates that the uncertainty in the average error in heading is
 smaller than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 when the average is calculated for the entire flight.
 
\end_layout

\begin_layout Standard
The result for the heading error from the Kalman filter is shown as the
 blue line in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading}
\end_layout

\end_inset

.
 The varying correction often has large uncertainty.
 As in the top panel, the regions of low uncertainty are confined to the
 turns where horizontal accelerations are significant.
 A smoothing spline
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Quotes eld
\end_inset

smooth.spline()
\begin_inset Quotes erd
\end_inset

 function provided by the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package in R was used, in parameter 
\begin_inset Quotes eld
\end_inset

spar=1.1
\begin_inset Quotes erd
\end_inset

 to give strong smoothing.
\end_layout

\end_inset

 that uses weight factors inversely proportional to the covariance leads
 to the red line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-Kalman-heading}
\end_layout

\end_inset

, for which the mean error is 
\begin_inset Formula $<0.002^{\circ}$
\end_inset

 and the standard deviation for individual measurements is about 0.02
\begin_inset Formula $^{\circ}$
\end_inset

.
 Another check on the heading error is provided by the correction algorithm
 
\begin_inset Quotes eld
\end_inset

Ranadu::CorrectHeading()
\begin_inset Quotes erd
\end_inset

, which leads to the green line in the figure.
 which has mean and standard deviation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(D1$HC[r], na.rm=TRUE),3)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(D1$HC[r], na.rm=TRUE),3)}
\end_layout

\end_inset

.
 Perhaps the best interpretation for this flight is that, within about 0.02
\begin_inset Formula $^{\circ}$
\end_inset

 uncertainty, there is no heading error.
 However, in general the spline fit represented by the red line may be the
 preferable result to use as a correction to the heading.
\end_layout

\begin_layout Standard
When applying the Kalman filter to the measurements from the INS, it is
 important to recognize that the results reported by the INS are those that
 have been used during its internal mechanization to find, for example,
 the ground-speed vector and the l-frame accelerations.
 In processed data sets, it has been common to introduce adjustments to
 the heading or, less often, the pitch to improve the performance of wind
 measurements during calibration maneuvers.
 It is particularly common to find an offset in heading that was introduced
 to give better agreement for winds during reverse-course maneuvers.
 However, it is difficult to separate an offset in sideslip from an offset
 in heading, as discussed in the NCAR Technical Note on uncertainty in wind
 measurements.
 It now appears that the offset often introduced to heading should have
 instead been an offset in sideslip.
 Because these offsets are introduced after the INS has performed its internal
 calculations, the Kalman filter has no mechanism for detecting that an
 offset has been introduced and will still produce estimates of heading
 error applicable to the original measurements.
 It is therefore important to remove any special adjustments that have been
 introduced to heading or other INS-provided variables before processing
 via the Kalman filter.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Section
New variables for wind
\end_layout

\begin_layout Subsection
Calculating the wind
\end_layout

\begin_layout Subsubsection
The vertical wind
\end_layout

\begin_layout Standard
The result of the Kalman filter is that new corrected variables {LATKF,
 LONKF, ALTKF, VEWKF, VNSKF, ROCKF, PITCHKF, ROLLKF, and THDGKF} are available.
 These and the variables {TASX, ATTACK, SSLIP} can be used in a new calculation
 of the vector wind.
 For the vertical wind, the new variable PITCHKF should be superior to the
 original variable PITCH and should lead to some improvement.
 The other cricital measurement used to calculate vertical wind is the rate-of-c
limb of the aircraft, for which there are two options: ROCKF and GGVSPD.
 The former uses the accelerations from the INS and so should have the best
 high-frequency performance, although GPS receivers provide very good measuremen
ts now even at high frequency.
 The other difference between these two choices is that if GGVSPD is used
 then a correction is needed for the about-4
\begin_inset space ~
\end_inset

m displacement of the GPS antenna from the INS.
 ROCKF is based on measurements from the INS, with slow updating to the
 GPS value, so it does not need such a correction.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<wind-calculation, include=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# source ('chunks/wind-calculation.R')
\end_layout

\begin_layout Plain Layout

## wind-calculation.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## get the wind variables:
\end_layout

\begin_layout Plain Layout

DataW <- D1
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW)
\end_layout

\begin_layout Plain Layout

D1$WICC <- DataN$WIN
\end_layout

\begin_layout Plain Layout

D1$WDCC <- DataN$WDN
\end_layout

\begin_layout Plain Layout

D1$WSCC <- DataN$WSN
\end_layout

\begin_layout Plain Layout

DataW$PITCH <- D1$PITCHKF
\end_layout

\begin_layout Plain Layout

DataW$ROLL <- D1$ROLLKF
\end_layout

\begin_layout Plain Layout

DataW$THDG <- D1$THDGKF
\end_layout

\begin_layout Plain Layout

DataW$VEW <- D1$VEWKF
\end_layout

\begin_layout Plain Layout

DataW$VNS <- D1$VNSKF
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- D1$ROCKF
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor(DataW, LG=0, CompF=FALSE)    ## suppress comp filter
 and GPS lever arm)
\end_layout

\begin_layout Plain Layout

D1$WDKF <- DataN$WDN
\end_layout

\begin_layout Plain Layout

D1$WSKF <- DataN$WSN
\end_layout

\begin_layout Plain Layout

D1$WIKF <- DataN$WIN
\end_layout

\begin_layout Plain Layout

## add longitudinal and lateral components analogous to UXC and VYC:
\end_layout

\begin_layout Plain Layout

.hdg <- D1$THDGKF * Cradeg
\end_layout

\begin_layout Plain Layout

.wd <- D1$WDKF * Cradeg + pi
\end_layout

\begin_layout Plain Layout

D1$UXKF <- D1$WSKF * (sin(.hdg)*sin(.wd) + cos(.hdg)*cos(.wd))
\end_layout

\begin_layout Plain Layout

.hdg <- .hdg - pi/2
\end_layout

\begin_layout Plain Layout

D1$VYKF <- D1$WSKF * (sin(.hdg)*sin(.wd) + cos(.hdg)*cos(.wd))
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- D1[, VROC]
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor(DataW, CompF=FALSE)    ## suppress comp filter and
 GPS lever arm)
\end_layout

\begin_layout Plain Layout

D1$WIKFG <- DataN$WIN
\end_layout

\begin_layout Plain Layout

sdWIdif <- sd(D1$WIKF[r]-D1$WICC[r], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following figure (Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Variance-spectra-ROC"

\end_inset

) shows a comparison of the variance spectra from the GPS-receiver value
 (GGVSPD) and the Kalman-filter value (ROCKF).
 The spectra are nearly identical, but GGVSPD appears to have some high-frequenc
y noise not present in ROCKF.
 At these high frequencies, both have contributions to the wind that are
 insignificant in comparison to that from the relative wind, so it will
 make little difference which is used in wind calculations, but it appears
 at least in this case that ROCKF contributes less false high-frequency
 noise than GGVSPD so it is the preferred choice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ROCGGVSPDMEMPlot.png
	lyxscale 50
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Variance spectra for the rate-of-climb measurements from the GPS receiver
 (GGVSPD) and the INS integrated acceleration adjusted to match the rate
 of climb required by the hydrostatic equation (ROCKF).
 The thin red line shows the unsmoothed spectrum for ROCKF; other lines
 have been smoothed in 50 bins in the logarithm of frequency.
 Data from a period of strong waves encountered during DEEPWAVE flight 16
 on 4 July 2014 over New Zealand.
\begin_inset CommandInset label
LatexCommand label
name "fig:Variance-spectra-ROC"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variance spectra for the measurement of vertical wind for the same flight
 segment are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Variance-spectra-WI"

\end_inset

.
 The small differences between these spectra do not arise from using ROCKF
 instead of GGVSPD or from the corrections applied to pitch, but rather
 from the time shift applied to GGVSPD but not to ROCKF (or equivalently
 ACINS).
 A comparison of the two measurements of vertical wind is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-WIC}
\end_layout

\end_inset

.
 While the two represent almost the same signal, the differences at any
 given time can be significant, as emphasized by the bottom panel in the
 figure.
 The standard deviation of the difference between measurements for the period
 shown in this figure is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sd(D1$WIKF[r]-D1$WICC[r], na.rm=TRUE), 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m/s
\begin_inset Note Note
status open

\begin_layout Plain Layout
, a value that can be reduced slightly (
\begin_inset Formula $<10$
\end_inset

%) by shifting the measurements in time.
 XXX
\end_layout

\end_inset

, so the difference is significant in comparison to the claimed uncertainty
 in measuring vertical wind.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename WIKFWICMEMPlot.png
	lyxscale 50
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Variance spectra for two measurements of the vertical wind, WIKF from the
 Kalman-filter processing and WIC from conventional processing.
 The thin red line shows the unsmoothed spectrum for WIKF; other lines hae
 been smoothed in 50 logarithmic frequency bins.
 Measurements from a period where strong waves were encounted during DEEPWAVE
 flight 16, 4 July 2014.
\begin_inset CommandInset label
LatexCommand label
name "fig:Variance-spectra-WI"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An aspect of the Kalman-filter-corrected vertical wind that needs further
 investigation is the relative timing of measurements entering the calculation,
 especially the INS-provided variables PITCH and ACINS as they might be
 offset from the vertical component of the relative wind as determined from
 the airspeed (TASX) and angle of attack (AKRD).
 [XXX consider pitch maneuvers and what minimizes the error.]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-WIC, include=TRUE, fig.cap='Vertical wind calculated using the results
 from the Kalman filter, compared to the original calculation before Kalman-filt
er correction.
 The difference is shown in the bottom panel.
 The result labeled "Kalman" is calculated using ROCKF and other results
 after correction by the Kalman filter, while WIC was calculated using GGVSPD
 from the GPS for the rate-of-climb of the aircraft.
 Data from a segment of DEEPWAVE flight 16 where strong waves were encountered.'>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D1[setRange(D1, 83400, 83800),], plotWAC (data.frame(Time, WIKF, WICC),
\end_layout

\begin_layout Plain Layout

#                                                    legend.position=NA))
\end_layout

\begin_layout Plain Layout

# legend ('bottomleft', legend=c('WIKF', 'WIC'), col=c('blue', 'darkgreen'),
 lwd=c(2,1), cex=0.8)
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D1[setRange(D1, 83400, 83800),], plotWAC (data.frame(Time, WIKF-WICC),
 ylab='WIKF-WIC'))
\end_layout

\begin_layout Plain Layout

# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

ggplotWAC(
\end_layout

\begin_layout Plain Layout

  with(D1[setRange(D1, 83400, 83800), ], 
\end_layout

\begin_layout Plain Layout

       data.frame (Time, 'Kalman'=WIKF, 'original'=WICC, "DWI"=WIKF-WICC,
 'SKIP'=WIKF*0)),
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'red'), lwd=c(1.4,0.8,1,0), lty=c(1,42),
\end_layout

\begin_layout Plain Layout

       ylab=expression(paste('vertical wind [m ', s^-1, ']')),
\end_layout

\begin_layout Plain Layout

       panels=2,
\end_layout

\begin_layout Plain Layout

       labelL=c('Kalman', 'original'),
\end_layout

\begin_layout Plain Layout

       labelP=c('variables', 'difference'),
\end_layout

\begin_layout Plain Layout

       legend.position=c(0.8,0.94)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The horizontal wind
\end_layout

\begin_layout Standard
The conventional measurements of horizontal wind, represented by the direction
 WDC and speed WSC, are based on the relative wind added to the ground-speed
 components VEWC and VNSC.
 These are adjusted to match the GPS measurements via a complementary filter
 that uses the slowly varying components from the GPS and the faster varying
 components from the INS.
 This therefore should produce results quite similar to the variables VEWKF
 and VNSKF from the Kalman filter.
 For the example flight being used (DEEPWAVE flight 16), the standard deviation
 of the difference is 0.1
\begin_inset space ~
\end_inset

m/s and the mean difference is 
\begin_inset Formula $<0.0001$
\end_inset


\begin_inset space ~
\end_inset

m/s, so these are in good agreement.
 The difference shows a component that varies with the Schuler oscillation,
 so the centered-filter result from the Kalman filter may be preferable
 to the recursive-filter result from the complementary filter.
 In addition, there are some perturbations in turns that likely arise from
 timing differences.
 The other result from the Kalman filter that affects the measured horizontal
 wind is the heading, but in this case the heading correction is small and
 slowly varying so it will have little effect on the results.
 The heading-change correction needed to account for the displacement between
 the INS and GPS antenna has little effect on the horizontal wind because
 both the Kalman filter and the complementary filter smooth any short-term
 effects on the GPS-provided measurements.
 For completeness, however, the GPS measurements GGVEW and GGVNS have been
 corrected for the effect of heading change before use in the Kalman filter
 or the complementary filter, so this does not introduce any change between
 the two measurements of horizontal wind.
 The resulting measurements of horizontal wind direction match with a standard
 deviation of 0.3
\begin_inset Formula $^{\circ}$
\end_inset

and the magnitudes of the horizontal winds match with a standard deviation
 of 0.1
\begin_inset space ~
\end_inset

m/s.
 These differences are plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:hw-plot}
\end_layout

\end_inset

.
 In both cases the differences show signs of a Schuler oscillation, indicating
 that the recursive-filter applied in the standard calculation likely leaves
 some residual error, and they show larger deviations in turns that likely
 point to timing differences among the components entering the calculation
 of the wind.
 Timing considerations are explored further in Sect.
\begin_inset space ~
\end_inset

XXX.
\end_layout

\begin_layout Standard
Despite these small differences, representative variance spectra for the
 longitudinal and lateral wind overlap in plots so well that the spectra
 are indistinguishable.
 An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Variance-spectra-UXVY"

\end_inset

.
 Although differences do not appear in the variance spectra for horizontal
 wind, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:hw-plot}
\end_layout

\end_inset

 and the standard deviations quoted above indicate that there are significant
 differences and some preference indicated for using the Kalman-filter results
 to reduce errors in individual measurements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GS-comparison, include=FALSE, eval=FALSE, fig.cap=''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- getNetCDF (fname, c('VEWC', 'VNSC'))
\end_layout

\begin_layout Plain Layout

D1$VEWC <- DT$VEWC
\end_layout

\begin_layout Plain Layout

D1$VNSC <- DT$VNSC
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(D1[r,], plotWAC (data.frame(Time, VEWKF-GGVEW)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(D1[r,], plotWAC (data.frame(Time, VNSKF-GGVNS)))
\end_layout

\begin_layout Plain Layout

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<hw-plot, include=TRUE, fig.cap='Differences between the conventional measuremen
ts of horizontal wind (variables WDC and WSC) and the results from the Kalman
 filter (variables WDKF and WSKF).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(2,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D1[r,], plotWAC (data.frame(Time, WDKF-WDCC), ylab='WDKF-WDC'))
\end_layout

\begin_layout Plain Layout

# op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

# with(D1[r,], plotWAC (data.frame(Time, WSKF-WSCC), ylab='WSKF-WSC'))
\end_layout

\begin_layout Plain Layout

# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
\end_layout

\begin_layout Plain Layout

ggplotWAC(
\end_layout

\begin_layout Plain Layout

  with(D1[r, ], 
\end_layout

\begin_layout Plain Layout

       data.frame (Time, 'direction'=WDKF-WDCC, 'speed'=WSKF-WSCC)),
\end_layout

\begin_layout Plain Layout

       ylab=expression(paste('KF correction [', degree, ' (top) or m ',
 s^-1, ' (bottom)]')),
\end_layout

\begin_layout Plain Layout

       panels=2,
\end_layout

\begin_layout Plain Layout

       labelL=c('Kalman correction'),
\end_layout

\begin_layout Plain Layout

       labelP=c('direction', 'speed'),
\end_layout

\begin_layout Plain Layout

       legend.position=c(0.8,0.94)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename UXVYMEMPlot.png
	lyxscale 50
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Variance spectra for the standard variables UXC and VYC, representing the
 longitudinal and lateral components of the horizontal wind relative to
 the orientation of the aircraft, and the corresponding results for the
 winds produced after the Kalman filter (UXKF and VYKF).
 The thin red line shows the unsmoothed spectrum for UXKF; the other lines
 have been smoothed in 50 logarithmic-spaced bins in frequency.
 Data are from DEEPWAVE flight 16, 4 July 2014, in waves over New Zealand.
\begin_inset CommandInset label
LatexCommand label
name "fig:Variance-spectra-UXVY"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<create-new-netcdf>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# source ('chunks/create-new-netcdf.R')
\end_layout

\begin_layout Plain Layout

## create-new-netcdf.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fnew <- sub ('.nc', 'KF.nc', fname)
\end_layout

\begin_layout Plain Layout

## beware: overwrites without warning!!
\end_layout

\begin_layout Plain Layout

Z <- file.copy (fname, fnew, overwrite=TRUE)  ## BEWARE: overwrites without
 warning!!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# function to copy attributes from old variable (e.g., PITCH) to new one (e.g.,
 PITCHKF)
\end_layout

\begin_layout Plain Layout

copy_attributes <- function (atv, v, nfile) {
\end_layout

\begin_layout Plain Layout

  for (i in 1:length(atv)) {
\end_layout

\begin_layout Plain Layout

    aname <- names(atv[i])
\end_layout

\begin_layout Plain Layout

    if (grepl ('name', aname)) {next}  # skips long and standard names
\end_layout

\begin_layout Plain Layout

    if (grepl ('units', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('Dependencies', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (grepl ('actual_range', aname)) {next}
\end_layout

\begin_layout Plain Layout

    if (is.numeric (atv[[i]])) {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.numeric(atv[[i]]))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      ncatt_put (nfile, v, attname=aname, attval=as.character (atv[[i]]))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adding the new variables to the netCDF file
\end_layout

\begin_layout Standard
The code shown in the box that follows adds one variable to an existing
 newCDF file, renaming the resulting file with a name like PROJECTrf01KF.nc
 if the original file was PROJECTrf01.nc.
 This can serve as a model for adding such variables.
 See the 
\begin_inset Quotes eld
\end_inset

.Rnw
\begin_inset Quotes erd
\end_inset

 file for the actual code, which has more steps to protect against missing
 variables or substitute variables when some are missing and to handle high-rate
 data files.
 This example is included to serve as a template for other routines that
 might want to add variables to a netCDF file.
\end_layout

\begin_layout Subsubsection*
Example of code to add a variable:
\end_layout

\begin_layout LyX-Code

\family typewriter
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code

\family typewriter
## get the old netCDF variables:
\end_layout

\begin_layout LyX-Code

\family typewriter
D <- getNetCDF (fname, VarList)    
\end_layout

\begin_layout LyX-Code

\family typewriter
## open the copy of the old file for writing:
\end_layout

\begin_layout LyX-Code

\family typewriter
netCDFfile <- nc_open (fnew, write=TRUE) 
\end_layout

\begin_layout LyX-Code

\family typewriter
Rate <- 1  ## the data rate of this file
\end_layout

\begin_layout LyX-Code

\family typewriter
## retrieve dimension info from the old file
\end_layout

\begin_layout LyX-Code

\family typewriter
Dimensions <- attr (D, "Dimensions")
\end_layout

\begin_layout LyX-Code

\family typewriter
Dim <- Dimensions[["Time"]]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\family typewriter
## variables to add to the netCDF file: (add more)
\end_layout

\begin_layout LyX-Code

\family typewriter
VarNew <- c('LATKF')   
\end_layout

\begin_layout LyX-Code

\family typewriter
VarOld <- c('LAT')
\end_layout

\begin_layout LyX-Code

\family typewriter
VarUnits <- c('degrees')
\end_layout

\begin_layout LyX-Code

\family typewriter
VarLongName <- c('latitude, KF')
\end_layout

\begin_layout LyX-Code

\family typewriter
VarStdName <- c('INS latitude, Kalman-filter-corrected')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\family typewriter
## create the new variables
\end_layout

\begin_layout LyX-Code

\family typewriter
varCDF <- list ()
\end_layout

\begin_layout LyX-Code

\family typewriter
for (i in 1:length(VarNew)) {  ## only one in this example
\end_layout

\begin_layout LyX-Code

\family typewriter
  ## create the new variable and add it to the netCDF file
\end_layout

\begin_layout LyX-Code

\family typewriter
  varCDF[[i]] <- ncvar_def (VarNew[i],  
\end_layout

\begin_layout LyX-Code

\family typewriter
                    units=VarUnits[i], 
\end_layout

\begin_layout LyX-Code

\family typewriter
                    dim=Dim, 
\end_layout

\begin_layout LyX-Code

\family typewriter
                    missval=as.single(-32767.), prec='float', 
\end_layout

\begin_layout LyX-Code

\family typewriter
                    longname=VarLongName[i])
\end_layout

\begin_layout LyX-Code

\family typewriter
  if (i == 1) {
\end_layout

\begin_layout LyX-Code

\family typewriter
    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
\end_layout

\begin_layout LyX-Code

\family typewriter
  } else {
\end_layout

\begin_layout LyX-Code

\family typewriter
    newfile <- ncvar_add (newfile, varCDF[[i]])
\end_layout

\begin_layout LyX-Code

\family typewriter
  }
\end_layout

\begin_layout LyX-Code

\family typewriter
  ## transfer attributes from the old variable and add new ones
\end_layout

\begin_layout LyX-Code

\family typewriter
  ATV <- ncatt_get (netCDFfile, VarOld[i])
\end_layout

\begin_layout LyX-Code

\family typewriter
  copy_attributes (ATV, VarNew[i], newfile)
\end_layout

\begin_layout LyX-Code

\family typewriter
  ncatt_put (newfile, VarNew[i], attname="standard_name", 
\end_layout

\begin_layout LyX-Code

\family typewriter
             attval=VarStdName[i])
\end_layout

\begin_layout LyX-Code

\family typewriter
  ## add the measurements for the new variable
\end_layout

\begin_layout LyX-Code

\family typewriter
  ncvar_put (newfile, varCDF[[i]], D1[, VarNew[i]])
\end_layout

\begin_layout LyX-Code

\family typewriter
}
\end_layout

\begin_layout LyX-Code

\family typewriter
## then close to write the new file
\end_layout

\begin_layout LyX-Code

\family typewriter
nc_close (newfile)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<modify-new-netcdf, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# source ('chunks/modify-new-netcdf.R')
\end_layout

\begin_layout Plain Layout

## modify-new-netcdf.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables needed for attributes and new wind calculation:
\end_layout

\begin_layout Plain Layout

VarList <- c('TASX', 'ATTACK', 'SSLIP', 'GGVEW', 'GGVNS', VROC, 'VEW', 'VNS',
 'THDG', 'ROLL', 'PITCH',
\end_layout

\begin_layout Plain Layout

             'LAT', 'LON', 'VSPD')
\end_layout

\begin_layout Plain Layout

VarListRef <- VarList
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo (fname)
\end_layout

\begin_layout Plain Layout

VarList <- VarListRef
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (!('GGVSPD' %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

  if ('GGVSPDB' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'GGVSPDB'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_A' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_A'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_G' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_G'
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    print ('ERROR: no VSPD variable found')
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (Var in VarList) {
\end_layout

\begin_layout Plain Layout

  if (!(Var %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

    print (sprintf (' required variable %s not found in file %s; skipping...',
 Var, fname))
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

netCDFfile <- nc_open (fnew, write=TRUE) 
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

Dimensions <- attr (D1, "Dimensions")
\end_layout

\begin_layout Plain Layout

Dim <- Dimensions[["Time"]]
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps25"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if ("sps50" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 50
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps50"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DATT <- D1  ## save to ensure that attributes are preserved
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables to add to the netCDF file:
\end_layout

\begin_layout Plain Layout

VarNew <- c('LATKF', 'LONKF', 'ALTKF', 'VEWKF', 'VNSKF', 'ROCKF', 'PITCHKF',
 'ROLLKF', 'THDGKF',
\end_layout

\begin_layout Plain Layout

            'WDKF', 'WSKF', 'WIKF', 'WIKFG', 'WICC', 'WDCC', 'WSCC', 'UXKF',
 'VYKF')
\end_layout

\begin_layout Plain Layout

VarOld <- c('LAT', 'LON', 'ALT', 'VEW', 'VNS', 'VSPD', 'PITCH', 'ROLL',
 'THDG', 
\end_layout

\begin_layout Plain Layout

            'WD', 'WS', 'WI', 'WIC', 'WIC', 'WDC', 'WSC', 'UXC', 'VYC')
\end_layout

\begin_layout Plain Layout

VarUnits <- c('degrees', 'degrees', 'm', 'm/s', 'm/s', 'm/s', 'degrees',
 'degrees', 'degrees',
\end_layout

\begin_layout Plain Layout

              'degrees', 'm/s', 'm/s', 'm/s', 'm/s', 'degrees', 'm/s', 'm/s',
 'm/s')
\end_layout

\begin_layout Plain Layout

VarLongName <- c('latitude, KF', 'longitude, KF', 'altitude MSL, KF',
\end_layout

\begin_layout Plain Layout

                 'eastward groundspeed, KF', 'northward groundspeed, KF',
 'rate of climb, KF',
\end_layout

\begin_layout Plain Layout

                 'pitch, KF', 'roll, KF', 'heading, KF',
\end_layout

\begin_layout Plain Layout

                 'wind direction, KF', 'wind speed, KF', 'vertical wind,
 KF', 
\end_layout

\begin_layout Plain Layout

                 'vertical wind, KF and GGVSPD', 'WIC recalc', 'WDC recalc',
 'WSC recalc',
\end_layout

\begin_layout Plain Layout

                 'longitudinal wind, KF', 'lateral wind, KF')
\end_layout

\begin_layout Plain Layout

VarStdName <- c('INS latitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS longitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS altitude, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS eastward ground speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS northward ground speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS rate of climb, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS aircraft pitch angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS aircraft roll angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'INS aircraft true heading angle, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'horizontal wind direction, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'horizontal wind speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'vertical wind speed, Kalman-filter-corrected',
\end_layout

\begin_layout Plain Layout

                'vertical wind speed, Kalman-filter-corrected but using
 GPS VSPD',
\end_layout

\begin_layout Plain Layout

                'original WIC, recalculated',
\end_layout

\begin_layout Plain Layout

                'original WDC, recalculated',
\end_layout

\begin_layout Plain Layout

                'original WSC, recalculated',
\end_layout

\begin_layout Plain Layout

                'longitudinal component of the horizontal wind, Kalman-filter-co
rrected',
\end_layout

\begin_layout Plain Layout

                'lateral component of the horizontal wind, Kalman-filter-correct
ed')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## create the new variables
\end_layout

\begin_layout Plain Layout

varCDF <- list ()
\end_layout

\begin_layout Plain Layout

for (i in 1:length(VarNew)) {
\end_layout

\begin_layout Plain Layout

  varCDF[[i]] <- ncvar_def (VarNew[i],  
\end_layout

\begin_layout Plain Layout

                            units=VarUnits[i], 
\end_layout

\begin_layout Plain Layout

                            dim=Dim, 
\end_layout

\begin_layout Plain Layout

                            missval=as.single(-32767.), prec='float', 
\end_layout

\begin_layout Plain Layout

                            longname=VarLongName[i])
\end_layout

\begin_layout Plain Layout

  if (i == 1) {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (newfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ATV <- ncatt_get (netCDFfile, VarOld[i])
\end_layout

\begin_layout Plain Layout

  copy_attributes (ATV, VarNew[i], newfile)
\end_layout

\begin_layout Plain Layout

  ncatt_put (newfile, VarNew[i], attname="standard_name", 
\end_layout

\begin_layout Plain Layout

             attval=VarStdName[i])
\end_layout

\begin_layout Plain Layout

  if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], D1[, VarNew[i]])
\end_layout

\begin_layout Plain Layout

  } else if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], D1[, VarNew[i]], count=c(25, nrow(D1)/25))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nc_close (newfile)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary and conclusions
\end_layout

\begin_layout Standard
An application of an error-state Kalman filter has been developed to improve
 the measurements of wind provided by the NSF/NCAR GV research aircraft.
 The primary advantage provided by the corrected measurements is reduction
 in the uncertainty associated with the measurements of pitch and heading,
 which without correction are the largest source of uncertainty in the measureme
nts (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

).
 
\end_layout

\begin_layout Section
\start_of_appendix
Reproducibility
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
reproducibility of this document
\end_layout

\end_inset

This document is constructed in ways that support duplication of the study.
 The processing programs are incorporated into the same file that generates
 this document, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"

\end_inset

 as implemented in the R package
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"

\end_inset

).
 The core program, 'WindUncertainty.Rnw', is archived on 'GitHub' 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

in the directory at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/WindUncertainty.git"

\end_inset

.
 There is some supplemental material in that directory, like the bibliography
 and many code segments saved in the 'chunks' subdirectory, so the full
 directory should be downloaded in order to run the program.
 The calculations use the programming language 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R!the programming language
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R!RStudio used with
\end_layout

\end_inset

R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

) and were run within RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this document.
\end_layout

\begin_layout Standard
A package named Ranadu,
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ranadu
\end_layout

\end_inset

 containing auxillary functions, is used extensively in the R code.
 It is available on GitHub as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset

.
 The specific version used for calculations in this report is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data files
\end_layout

\end_inset

data files used are also preserved in the NCAR High Performance Storage
 System (HPSS)
\begin_inset Index idx
status open

\begin_layout Plain Layout
HPSS archives
\end_layout

\end_inset

 in files that are available, and they can be provided via a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data!requesting
\end_layout

\end_inset

request to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

mailto:raf-dm@eol.ucar.edu
\end_layout

\end_inset

.
 The original files representing the data as produced by the NCAR Earth
 Observing Laboratory, Research Aviation Facility, were in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
netCDF format
\end_layout

\end_inset

netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"

\end_inset

), but in many cases special reprocessing was used and the files may change
 after reprocessing so a separate archive is maintained for this document.
 The data files in this archive represent 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R!data.frames
\end_layout

\end_inset

R data.frames and are preserved as binary-format 'Rdata' files via R 'save'
 commands.
 The code in the GitHub archive has appropriate 'load' commands to ingest
 these data files from a subdirectory named 'Data' but this is not part
 of the GitHub repository because it is too large to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from the NCAR HPSS to the 'Data' directory.
\end_layout

\begin_layout Standard
Extensive use has been made of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes of variables and data.frames
\end_layout

\end_inset

attributes assigned to the data.frames and the variables in those data.frames.
 All the attributes from the original netCDF files have been transferred,
 so there is a record of how the original data were processed, for example
 recording 
\begin_inset Index idx
status open

\begin_layout Plain Layout
calibration coefficients!as used in nimbus
\end_layout

\end_inset

calibration coefficients and processing chains for the variables.
 Once the data.frames are loaded into R, these attributes can be viewed and
 provide additional documentation of what data were used.
 Key information like the processing date, the program version, and the
 selection of primary variables is thus preserved.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WindUncertainty
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WindUncertainty.zip
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WindUncertainty.Rnw
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/scr/raf_data/HCRTEST/ 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
https://github.com/WilliamCooper/WindUncertainty.git
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

WindUncertainty.Rnw
\begin_inset Newline newline
\end_inset

WindUncertainty.pdf
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset Newline newline
\end_inset

Ranadu_2.1-15-3-8.tar.gz
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:acknowledgements"

\end_inset


\end_layout

\begin_layout Standard
The analyses reported here were mostly performed using R
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
R Core Team (2014).
 R: A language and environment for statistical computing.
 R Foundation for Statistical Computing, Vienna, Austria.
 URL http://www.R-project.org/.
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

, with RStudio
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
RStudio (2012).
 RStudio: Integrated development environment for R (Version 0.98.879) [Computer
 software].
 Boston, MA.
 Available from http://www.rstudio.org/
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

 and knitr
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Xie, Y.
 (2013), 
\begin_inset Quotes eld
\end_inset

knitr: A general-purpose package for dynamic report generation in R.
 R package version 1.3,
\begin_inset Quotes erd
\end_inset

 Version 1.6 was used for this work.
 See also Xie, Y (2014), 
\begin_inset Quotes eld
\end_inset

Dynamic documents with R and knitr,
\begin_inset Quotes erd
\end_inset

 CRC Press, Chapman and Hall, 190 pp.
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"

\end_inset

.
 Substantial use also was made of the ggplot2 package
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
H.
 Wickham.
 ggplot2: elegant graphics for data analysis.
 Springer, New York, 2009.
 
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"

\end_inset

 for R.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "WAC"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{References}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "lis"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{List of Symbols}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "var"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{netCDF Variable Names}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{Index}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{End}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
