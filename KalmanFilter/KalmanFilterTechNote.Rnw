%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,twoside,english,12pt,twoside,english]{article}
\usepackage{mathptmx}
\usepackage{helvet}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1.2in,rmargin=1in}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\definecolor{page_backgroundcolor}{rgb}{1, 1, 1}
\pagecolor{page_backgroundcolor}
\usepackage{babel}
\usepackage{calc}
\usepackage{url}
\usepackage{amsmath}
\usepackage{splitidx}
\makeindex
\usepackage{graphicx}
\usepackage{esint}
\usepackage[authoryear]{natbib}
\newindex[Index]{idx}
\newindex[Variable Names and Acronyms]{var}
\newindex[List of Symbols]{lis}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 0},pdfborderstyle={},backref=section,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={Technical Note: Kalman Filter},
 pdfauthor={William A. Cooper},
 pdfsubject={improvement of  wind measurements, GV},
 pdfkeywords={Kalman, wind,uncertainty, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF},
  linkcolor=blue, citecolor={blue}}
\usepackage{breakurl}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}

\makeatother

\begin{document}

\title{A Kalman Filter\\
to Improve Measurements of Wind\\
from NSF/NCAR Research Aircraft}

\author{William A. Cooper}

\date{\textcolor{red}{DRAFT} 3/6/2017\\
(title page to be replaced by NCAR library template)}

\maketitle
National Center for Atmospheric Research\\
Earth Observing Laboratory\\
Research Aviation Facility

\vfill{}
\cleardoublepage{} \pagenumbering{roman}\tableofcontents{} \vfill{}
\eject

%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.

%\phantomsection \addcontentsline{toc}{section}{List of Figures}

\listoffigures

\clearpage %\phantomsection \addcontentsline{toc}{section}{List of Tables}

\listoftables

\clearpage{}

\renewcommand{\abstractname}{Prefix and Abstract}\thispagestyle{plain}\begin{abstract}

To improve the measurements of wind made from NSF/NCAR aircraft, a
Kalman filter is developed and applied to archived data files from
research projects. The filter is an error-state Kalman filter, and
the emphasis is on improving the measurements of pitch and heading
because they are usually the dominating source of uncertainty in measured
wind. The NSF/NCAR Gulfstream V research aircraft is emphasized in
the development, but the filter as developed can be applied to data
from other present and past NCAR aircraft as well. So that the resulting
filter can be applied in cases where the primary measurements from
the inertial reference system were not recorded in the data file,
a method is developed for retrieving those measurements by differentiating
the recorded variables representing attitude angles and aircraft-velocity
components. In addition, some new algorithms are introduced for estimating
the rate of climb of the aircraft from the measured accelerations
and for estimating the angle of attack from pressure measurements
made at ports on the radome. In addition, simplified methods for estimating
the errors in pitch and heading without the full complexity and processing
requirements of the Kalman filter are documented. The result is that
standard uncertainties in pitch and heading are reduced to about 0.01$^{\circ}$,
so that they no longer dominate the uncertainty in the wind measurements.
Some examples illustrate the effects of the Kalman filter on measured
wind and on variance spectra. The processing technique is incorporated
into an R script that can add the improved variables to a standard
netCDF data archive so that they can be made available for community
use. Documents that are accessible via links in this technical document
provide information on the workflow that generated the document, the
details of the processing algorithms, and instructions for use and
modification of the processing script.

\end{abstract}

\clearpage{}

\section*{Acknowledgments}

\label{sec:acknowledgements}

The research aircraft discussed in this technical note, the NSF/NCAR
\index{aircraft!NSF/NCAR GV}Gulfstream V often called \textquotedbl{}HIAPER\textquotedbl{},
was the result of an extensive effort both within and outside of NCAR,
and at the National Science Foundation. Chris Webster's development
and maintenance of the software used for data processing was a very
important contribution to this effort. The technical staff of the
NCAR Earth Observing Laboratory were involved in all stages of the
development and operation of this research platform, and the project
management staff, operations staff, and computing and data management
groups of that Laboratory conducted the projects that produced the
data used in this document. Without all these contributions, the measurements
characterized in this document would not have been available to the
community. NCAR is sponsored by the National Science Foundation (NSF),
and the NSF also supported the experiments that collected the data
used in this technical note.

The data used in the examples presented are from the \sindex[var]{DEEPWAVE=Deep Propagating Gravity Wave Experiment}DEEPWAVE\index{DEEPWAVE research project}
project (Deep Propagating Gravity Wave Experiment over New Zealand),
described at\\
\href{https://www.eol.ucar.edu/field_projects/deepwave}{https://www.eol.ucar.edu/field\_{}projects/deepwave}.
{[}NEED A DATA CITATION HERE{]} Measurements were collected by the
DEEPWAVE experiment team, and flight operations and data acquisition
and processing were performed by the Research Aviation Facility, Earth
Observing Laboratory, National Center for Atmospheric Research (NCAR).
The analyses reported here were mostly performed using R\citet{Rlanguage},
with \index{RStudio}RStudio \citet{RStudio2012} and \index{knitr}knitr
\citet{Xie2014a,Xie2014b}. Substantial use also was made of the \index{ggplot2}\index{R language!package!ggplot2}ggplot2
package \citet{wickham2009} for R. The code used for the Kalman filter
relies on the Jacobian function\index{function!Jacobian} in the R
\index{R language!package!numDeriv}package ``numDeriv'' \index{Jacobian!numerical evaluation}version
2016.8-1; cf.~\citet{numDeriv}.

\thispagestyle{plain}\clearpage{}

\thispagestyle{empty}

\cleardoublepage{}

\pagenumbering{arabic}

\section{Introduction}

\subsection{Overview}

\index{overview!this document}A recent technical note (\citet{Cooper2016ncartn})
discussed the uncertainty\index{uncertainty!wind} associated with
\index{wind!measurement}measurements of wind from the NSF/NCAR Gulfstream
V\index{aircraft!NSF/NCAR GV}\sindex[var]{GV=NSF/NCAR Gulfstream V}
research aircraft, hereafter called the GV.\index{GV|see {aircraft!NSF/NCAR GV}}\index{NSF/NCAF GV|see {aircraft!NSF/NCAR GV}}
The aircraft is owned by the \sindex[var]{NSF=National Science Foundation}National
Science Foundation (NSF) and operated by the Research Aviation Facility\sindex[var]{RAF=Research Aviation Facility}
(RAF), Earth Observing Laboratory (EOL), National Center for Atmospheric
Research\sindex[var]{NCAR=National Center for Atmospheric Research}
(NCAR). \index{aircraft!NSF/NCAR GV} The components and algorithms\index{algorithm!wind}
that comprise the \index{wind!{*}{*}}wind-measuring system on the
GV\index{uncertainty!wind!technical note} were documented in that
reference, so that information will not be repeated here. The central
content of that technical note was a detailed analysis of uncertainty\index{uncertainty!analysis for wind}
for the wind measurements. The \index{uncertainty!standard}standard
uncertainty was estimated to be about 0.1~m\,s$^{-1}$ for vertical
wind\index{wind!vertical!{*}{*}}\index{wind!vertical!uncertainty}
and 0.4~m\,s$^{-1}$ for each component of the horizontal \index{wind!horizontal!uncertainty}wind.
These estimates\index{uncertainty!wind!estimate} were based on the
analyzed performance of the inertial navigation \index{navigation system!inertial}system,
and are lower than would be expected from direct specifications for
that system. The largest contributions to uncertainty\index{uncertainty!wind!largest sources}
were associated with the measurements\index{pitch} of pitch and \index{heading}heading,
for respectively the vertical and horizontal wind components. Improvement
in the measurements of these \index{angle, attitude|see {attitude angle}}\index{attitude angle}attitude
angles therefore is the indicated step toward improved measurements
of wind.

Two approaches are taken in the present technical note to improve
the \index{pitch}\index{heading}key measurements. The first uses
a simplified analysis of the strong coupling\index{coupling!strong}
represented by the Schuler oscillation\index{Schuler oscillation}
to evaluate errors in pitch\index{error!pitch}\index{error!heading}
and combines this with a related analysis to find the correction in
heading. The second implements a full error-state Kalman filter\index{Kalman filter!error-state}
to produce adjusted measurements of the attitude angles\index{attitude angle}
and also the ground-speed\index{ground speed} components\index{velocity}
and rate-of-climb of the aircraft. The agreement between these two
methods then supports the validity of each, while the first provides
a much simpler method for determining the corrections.

This introduction will discuss the steps involved in using an error-state
Kalman filter to update \index{measurement!from INS}measurements
from the inertial systems\index{navigation system!inertial}\index{INS|see {navigation system, inertial}}
on the aircraft\index{aircraft!instrumentation!INS} (which do not
have internal Kalman filters) using reference \index{measurement!from GPS}measurements
from a \index{GPS|see {navigation sysem, GPS}}\index{navigation system!GPS}Global
Positioning System\index{aircraft!instrumentation!GPS} (GPS) \sindex[var]{GPS=global positioning system}receiver.
The measurements from the GPS receiver are very good for aircraft
position and velocity, so the Kalman filter adds little to these measurements.
The primary value of the \index{Kalman filter!primary value}Kalman
filter presented here is that it improves the measurements of \index{pitch}pitch
and \index{heading}heading.\index{global positioning system|see {navigation system, GPS}}

Section~2 next will develop expressions for the derivatives\index{state vector!derivative}\index{derivative!state vector|see {state vector, derivative}}
of a nine-component ``state vector'' of \index{measurement!from INS}measurements\sindex[var]{INS=inertial navigation system}
from the inertial navigation \index{navigation system!inertial}system
(INS), representing aircraft position, velocity, and attitude, and
will show that these derivatives provide a reasonable basis for mechanization,\index{mechanization!definition}
i.e., calculating the history of the state vector\index{attitude angle}
of the aircraft from the basic \index{measurement!from IRU}measurements
provided by the inertial reference \sindex[var]{IRU=inertial reference unit}unit\index{inertial reference unit}\index{IRU|see {inertial reference unit}}
(IRU).\index{body acceleration|see {acceleration}}\index{body rotation rate!see {rotation rate of aircraft}}\footnote{In this document, IRU will refer to the portion of the instrument
that produces the basic measurements\index{measurement!from IRU}
of body acceleration and body rotation rate, while INS\index{navigation system!inertial}
will refer to the full system that uses those basic \index{measurement!from INS}measurements
to propagate the position, velocity, and attitude angles\index{attitude angle}
of the aircraft forward in time from an initial state determined during
alignment\index{alignment!INS} of the instrument.} Those basic measurements\index{measurement!from IRU}\index{aircraft!instrumentation!IRU}
are the vector rotation rate and vector acceleration\index{acceleration!measurement}
of the aircraft in an inertial \index{reference frame!inertial}frame,
so the test of the calculated derivatives\index{state vector!derivative}
is that the results for the sequence of state vectors\index{state vector!definition}
should be in reasonable agreement with the values provided by the
INS. The importance of this step is that the validated state-vector
derivative\index{state vector!derivative} then will be used in implementation
of the error-state Kalman \index{Kalman filter!error-state}filter.

Section~3 is a diversion from the main development of this technical
note. It discussed several ancillary topics:
\begin{enumerate}
\item[i.]  a new variable representing the \index{rate of climb}rate of climb
of the aircraft that is an improvement over the \index{rate of climb}measurement
provided by the INS; 
\item[ii.] a method for finding the \index{inertial reference unit}IRU-provided
\index{measurement!from IRU!surrogate for}measurements\index{inertial reference unit!surrogate for measurement}\index{IRU|see {inertial reference unit}}
of rotation and acceleration by differentiating the recorded attitude
angles;\index{attitude angle} 
\item[iii.] simplified algorithms\index{algorithm!correct pitch}\index{algorithm!correct heading}
for finding the errors\index{error!pitch}\index{error!heading} in
pitch and heading; and 
\item[iv.] a revised empirical representation of angle of attack\index{angle of attack!empirical representation}\index{attack|see {angle of attack}}. 
\end{enumerate}
The first is useful because the \index{navigation system!inertial!rate of climb}INS
internally updates the variable representing the vertical speed of
the aircraft by comparison\index{comparison!altitude} to the pressure\index{altitude of aircraft!pressure}
altitude, while the \index{wind!measurement}measurement of wind needs
a variable representing the rate of change in geometric\index{altitude of aircraft!geometric}
altitude. The second topic is needed because, for many of the early
research projects using the \index{aircraft!NSF/NCAR GV}GV, the body
rotation rates\index{rotation rate of aircraft!measurement} and body
accelerations\index{acceleration!measurement}\index{measurement!acceleration}\index{measurement!rotation rate}
 were not recorded, yet they are needed by the Kalman filter. Reconstructing
them makes it possible to process those older \index{processing from archives}projects
or to process from the standard data archives, \index{data!standard archive}which
normally do not include the body rotations\index{measurement!rotation rate}
even if they were present in the original recorded file. The third
topic provides a complementary approach to finding the same errors\index{error!attitude angle}
in attitude angles\index{attitude angle} that the Kalman filter will
produce. It will provide a useful test of the results from that filter.
Finally, Sect.~3.4 extends the discussion of \index{sensitivity coefficient|see {angle of attack, empirical representation}}sensitivity
coefficients\index{angle of attack!empirical representation}\index{angle of attack!empirical representation}
contained in \citet{Cooper2016ncartn} by presenting a new empirical
representation that has advantages over the method used previously.
Improved pitch \index{pitch}measurements lead to improved coefficients
used in this empirical representation, so that is an added benefit
of the Kalman filter. These will find important uses in the implementation
of the Kalman filter or the new calculation of \index{wind!measurement}\index{wind!{*}{*}}wind
that is based on the corrections it provides.

Section~4 then discusses the details of the \index{Kalman filter!processing script}Kalman
filter. A script based on the R programming language\index{R language}\index{R language!program}
has been developed to calculate the estimated errors\index{error!estimate from Kalman filter}
from the Kalman filter, apply the indicated corrections to the \index{measurement!corrected}measured
\index{state vector}state vector, and add those new variables to
the standard netCDF\index{netCDF!create new file} data \index{file!data}file.
This section includes discussion of the aspects of that code that
represent the \index{Kalman filter!coding}Kalman filter. The results
are shown and compared to reference results and to the alternate methods
of determining the pitch and heading corrections as discussed in Sect.~3. 

Section 5 shows examples of the measurements of wind\index{wind!corrected, Kalman filter}
based on the corrected state vector. The conclusion of this section
and the closing section summarize the value of the Kalman filter.
At the end, there is also a list of netCDF variable names referred
to in the text, with definitions, and an index.

A goal of this project has been to make this work internally documented
and \index{reproducibility}reproducible, as discussed in the Appendix.
The program\index{R language!interactive processing script} that
produces this document (via \index{LaTeX}\LaTeX), named KalmanFilterTechNote.Rnw,\index{program!file}
also performs all the calculations,\index{program!for calculations}
generates the quoted results and figures (with a few exceptions),
and produces the new archive\index{data!new archive} \index{netCDF!create new file}file,
so that program file contains everything needed to reproduce this
work. Subsets of the data \index{file!data}files are also preserved
and archived. Another document called the \index{workflow document}workflow
document (KalmanFilterWorkflow.pdf) accompanies this technical note
and the generating program file. It serves several purposes, primarily
to elaborate upon the material in the present document. Some of the
derivations\index{derivations!in workflow} are justified in more
detail, and \index{instructions!R script}\index{R language!interactive processing script!instructions}instructions
are provided for running the R script to add the corrected variables
to a \index{netCDF}netCDF\sindex[var]{netCDF=network common data format}
file. Some details of how that modification of an existing file is
done are included in the workflow document, and there is also some
discussion of methods that were explored but abandoned in the course
of this work. The workflow document\index{workflow document} should
provide valuable information to anyone wanting to modify the R script
or use it to process archival\index{data!standard archive} data \index{file!data}files. 

<<initialization, echo=FALSE,include=FALSE>>=

## This chunk loads some needed R packages, specifies the file used for the illustration
## of mechanization, specifies the variables needed from the archive file, and
## specifies some time shifts. The data file used here is not part of the standard
## archives. It was produced specially to provide high-rate values of the measured
## variables, and it is therefore preserved in .Rdata format so that file can be
## archived and re-used to ensure reproducibility.

library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
# note that fig.pos="center" gave errors, changed to fig.align
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
thisFileName <- "KalmanFilterTechNote"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(numDeriv)    ## needed for the jacobian() function
library(signal)      ## used for filtering
library(reshape2)    ## used with ggplot facet plots
library(grid)
options(stringsAsFactors=FALSE)

CACHE <- TRUE

## temporary; remove once Ranadu is updated
source ('~/RStudio/Ranadu/R/theme_WAC.R')
source ('~/RStudio/Ranadu/R/getNetCDF.R')

setwd ('~/RStudio/Ranadu/KalmanFilter')
Directory <- DataDirectory ()
Flight <- "rf15HR" 			
Project = "DWIRU"     		
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%s%s.nc", Directory, ProjectDir, Project, Flight)
VarList <- c('BLATA', 'BLONGA', 'BNORMA', 'BPITCHR', 'BROLLR', 'BYAWR')
VarList <- c(VarList, 'LAT', 'LON', 'ALT', 'GGLAT', 'GGLON', 'GGALT')
VarList <- c(VarList, 'VEW', 'VNS', 'VSPD', 'GGVEW', 'GGVNS', 'GGVSPD')
VarList <- c(VarList, 'PITCH', 'ROLL', 'THDG')
ReloadData <- FALSE
# ReloadData <- TRUE
SaveRData <- sprintf("%s.Rdata", thisFileName)
if (ReloadData) {
  Data <- getNetCDF (fname, VarList, Start=31000, End=40000)
  ## remove heading adjustments if added during initial processing
  Z <- data.frame(getAttributes(Data$THDG, .print=FALSE))
  if ('CalibrationCoefficients' %in% names(Z)) {
    THDGoffset <- Z$CalibrationCoefficients[1]
  } else {
    THDGoffset <- 0
  }
  ## re signs: assumed lag has been corrected, so use - sign to remove
  if ('TimeLag' %in% names(Z)) {
    Data$THDG <- ShiftInTime(Data$THDG, .rate=25, .shift=-Z$TimeLag[1])
  }
  Data$THDG <- (Data$THDG - THDGoffset) %% 360
  save (Data, file=SaveRData)
} else {
  load (file=SaveRData)
}
Cradeg <- pi/180
## Remove time lags imposed during processing:
for (V in VarList) {
  if (V == 'THDG') {next}
  Z <- data.frame(getAttributes(Data[, V], .print=FALSE))
  ## re signs: assumed lag has been corrected, so use - sign to remove
  if ('TimeLag' %in% names(Z)) {
    Data[, V] <- ShiftInTime(Data[, V], .rate=25, .shift=-Z$TimeLag[1])
  }
}

VV <- c('BLONGA', 'BLATA', 'BNORMA')
.shift <- c(-50,-50,-50)
names(.shift) <- VV
for (V in VV) {
  Data[, V] <- ShiftInTime (Data[, V], 25, .shift[V])
}
# Data[, 'VSPD'] <- ShiftInTime (Data[, 'VSPD'], 25, 40)
# Data[, 'VEW'] <- ShiftInTime (Data[, 'VEW'], 25, 60)
# Data[, 'VNS'] <- ShiftInTime (Data[, 'VNS'], 25, 60)
Data[, 'PITCH'] <- ShiftInTime (Data[, 'PITCH'], 25, 20)
Data[, 'ROLL'] <- ShiftInTime (Data[, 'ROLL'], 25, 20)
.shift = 60
## Get some derivatives used later (but better value are obtained later
## via Savitzky-Golay polynomials.)
Rate <- attr (Data, 'Rate')
Data$pdot <- c(0, diff (Data$PITCH)) * Rate
Data$rdot <- c(0, diff (Data$ROLL)) * Rate
Data$hdot <- c(0, diff (Data$THDG))
Data$hdot <- (Data$hdot + 540) %% 360 - 180
Data$hdot <- Data$hdot * Rate
shift <- -500 / Rate
Data$pdot <- ShiftInTime (Data$pdot, Rate, shift)
Data$rdot <- ShiftInTime (Data$rdot, Rate, shift)
Data$hdot <- ShiftInTime (Data$hdot, Rate, shift)

@

\subsection{Brief summary of the Kalman filter}

\index{overview!Kalman filter}A \index{Kalman filter!summary}Kalman
filter provides a means of updating a sequence of \index{state vector}state
vectors (consisting, in the present case, of INS-provided \index{measurement!from INS}measurements
of position, velocity, and attitude angles\index{attitude angle})
by comparison\index{comparison!INS to GPS} to an independent set
of measurements (e.g., \index{navigation system!GPS}GPS-based \index{measurement!from GPS}measurements
of position and velocity). The updated \index{state vector}state
vector obtained by this process consists of an appropriately weighted
combination of the state vector projected forward using normal mechanization\index{mechanization}
and the independent measurements from the GPS receiver. Because errors
in the state vector\index{state vector!error in}\index{error!state vector|see {state vector, error in}}
are coupled,\index{coupling!strong} the update procedure can estimate
errors in the attitude angles\index{error!attitude angle}\index{attitude angle!errors}
as well as in the components of the \index{state vector}state vector
that are measured directly by the GPS receiver. This \index{measurement!corrected}correction
to attitude angles\index{attitude angle!correction} is the primary
reason for using a Kalman filter to improve the wind measurements.

The weighting of the projected-forward state vs.~new \index{measurement!from GPS}measurements
from the \index{navigation system!GPS}GPS receiver depends on estimates
of the covariance\index{matrix!covariance} matrix\index{covariance|see {matrix, covariance}}
describing the \index{state vector}state vector as well as estimates
of the noise\index{noise} contaminating the measurements from the
GPS receiver and the accelerations and rotation rates from the IRU\@.
With proper weighting, the result should combine the good high-frequency
response of the INS\index{navigation system!inertial} with the good
long-term stability of the GPS-based measurements. The \index{matrix!covariance}covariance
matrix characterizing the state vector is updated as the \sindex[var]{KF=Kalman filter}filter
is applied, but appropriate weighting depends on reasonable estimation
of the other error terms.

The operation of the filter\index{Kalman filter!matrices} depends
on sequential use of a set of matrices, so it is useful to define
those as follows, where the variable names following the symbols are
the R variable\index{variable names!in R code} names used in the
R code:
\begin{lyxlist}{00.00.0000}
\item [{$\delta\mathbf{x}_{k}$~{[}SVE{]}}] The error-state vector\index{error-state vector}\index{state vector!error-|see {error-state vector}}
at time index $k$. In the present case, this consists of these 15
components:\index{measurement!estimated error} estimated errors in
position, aircraft velocity\index{velocity of aircraft!{*}{*}}, aircraft
attitude, \index{measurement!from IRU}\index{inertial reference unit}IRU-measured
rotation rate\index{measurement!rotation rate}, and IRU-measured
accelerations.\index{acceleration!measurement}\index{measurement!acceleration} 
\item [{$\mathbf{T}_{k|k-1}$~{[}dcm{]}}] The 15$\times$15 state transition
matrix\index{state transition matrix|see {matrix, state transition}}\index{matrix!state transition}
based on the derivatives used for INS mechanization\index{mechanization}\index{navigation system!inertial!mechanization},
for the change from time $k-1$ to time $k$. Then $\delta\mathbf{x}_{k}=\mathbf{T}_{k|k-1}\delta\mathbf{x}_{k-1}$
where $\mathbf{T}$ combines the unit diagonal matrix with the time
step\index{time step} multiplied by the derivative\index{state vector!derivative}
 matrix describing the state transition. As applied to the state vector,
a state transition vector would involve the derivatives used for normal
mechanization to advance the state vector and so would duplicate the
action of the internal INS data processing. As interpreted for an
error-state Kalman \index{Kalman filter!error-state}filter, the matrix
$\mathbf{T}$ is obtained by calculating the Jacobian of the \index{Jacobian!of derivative function}function\index{function!producing the derivative vector}
of the state vector\index{state vector} that produces that derivative\index{state vector!derivative}
vector, as a function of the error-state \index{error-state vector}components;
i.e., $T[i,\,j]$ is the derivative of the $i$ component of that
derivative function with respect to change in the $j$ component.
\item [{$\mathbf{V}$~{[}CV{]}}] The \index{matrix!covariance}15$\times$15
covariance matrix\index{matrix!covariance} that applies to the \index{state vector}state
vector $\delta\mathbf{x}$.
\item [{$\mathbf{K}$~{[}K{]}}] The \index{Kalman-gain matrix}Kalman-gain
matrix\index{matrix!Kalman gain} representing how the error-state
vector\index{error-state vector} is updated using the current error
state and the new \index{navigation system!GPS}GPS-based \index{measurement!from GPS}measurements.
\item [{$\delta\mathbf{z}$~{[}DZ{]}}] The 6-component error\index{error!measured INS-GPS}
vector containing the measured differences between the \index{navigation system!inertial}INS
and GPS-based \index{navigation system!GPS}measurements\index{measurement!from GPS}\index{measurement!from INS}
of position and velocity. 
\item [{$\mathbf{H}$~{[}H{]}}] The 15$\times$6-component observation
\index{matrix!observation}matrix representing how the measured differences
$\delta\mathbf{z}$ correspond to the \index{error-state vector}error-state
vector. 
\item [{$\mathbf{Q},\,\mathbf{R}$~{[}Q,~R{]}}] Matrices\index{matrix!noise}\index{matrix!measurement noise}
representing respectively the noise contributions (15$\times$15)
characterizing the forward propagation of the error-\index{error-state vector}state
vector and the \index{measurement!noise in}measurements from the
\index{navigation system!GPS}GPS receiver (6$\times$6).\index{noise!measurement}
\end{lyxlist}
The approach taken here will be to use the error-\index{error-state vector}state
vector that represents the difference between the best-estimate measurements
and those originally provided by the INS. The \index{measurement!from INS}INS
integration does not need to be duplicated; the reference integration
is already available. However, the Kalman filter does need the derivative
vector that leads to that forward \index{mechanization}integration,
so the first step in this analysis was to develop a function for the
derivative vector and validate it by comparing the mechanization that
uses it to the available INS\index{navigation system!inertial}-provided
variables, as described in Sect.~\ref{subsec:Mechanization}. The
Jacobian\index{Jacobian!of derivative function} of that derivative
\index{function!derivative}\index{derivative function}function,
evaluated at current values for the \index{state vector}state vector
including \index{measurement!from IRU}measurements from the \index{inertial reference unit}IRU,
then provides the \index{matrix!state transition}matrix $\mathbf{T}$
used in this filter. The implementation of the Kalman filter outlined
here then follows in Sect.~\ref{sec:The-Kalman-filter}.

<<utility-functions, include=TRUE>>=

## check the rate of the file
# ATT <- getAttributes(Data, .print=FALSE)
# Rate <- DataFileInfo (fname)$Rate  ## only rates 1 and 25 supported
dt <- 1/Rate               
DL <- nrow(Data)
OmegaE <- StandardConstant ('Omega')  ## Earth's rotation rate
OmegaE <- 15*Cradeg/3600              ## better match to INS?
Ree <- 6378137                        ## for radii of curvature
Ecc <- 0.08181919
Data$Grav <- Gravity (Data$LAT, Data$GGALT)

source ('chunks/RotationCorrection.R')
source ('chunks/STMFV.R')

@

<<INS-data, include=TRUE>>=

r <- setRange (Data, 31000, 35500)
Data <- Data[r,]

@

\section{The derivative of the state vector}

\subsection{The procedure to be used\label{subsec:mech-procedures}}

\index{state vector!derivative} The \index{state vector}state vector
used in this section will consist of the three components of position,
three components of aircraft velocity\index{velocity of aircraft!{*}{*}}
relative to the Earth, and three attitude angles (pitch, roll and
heading).\index{attitude angle} In later sections a different vector,
the error-state \index{error-state vector}vector, will be used for
the Kalman \index{Kalman filter}filter, and in that case three components
of \index{measurement!from IRU}measured rotation rate\index{rotation rate of aircraft!measurement}
and three components of measured acceleration\index{acceleration!measurement}
 will be added to the \index{state vector}state vector so that the
Kalman filter can treat the possibility of error in the latter six
components as well as the first nine. However, the purpose of this
section is to develop expressions for the derivatives of the nine-component
state vector in terms of the \index{inertial reference unit}IRU-measured
\index{measurement!rotation rate}rotation rates and accelerations
and to demonstrate that the calculated derivatives lead to a reasonable
mechanization\index{mechanization} that approximately duplicates
the original calculations from the INS. It is not necessary or expected
that this mechanization will produce an exact duplicate of the INS\index{navigation system!inertial!mechanization}
mechanization because the INS has high-rate data and timing information
not available to this new calculation. However, if the results are
reasonably close to those from the INS then that provides some evidence
that the derivatives being calculated are reasonably close to the
correct values. These derivatives will then be used in the implementation
of the Kalman filter, where the filter will adjust to compensate for
any errors remaining in these derivatives. 

The \index{mechanization!outline}procedure used to produce variables
corresponding to position, velocity, and attitude angles\index{attitude angle}
for this test is as follows:
\begin{enumerate}
\item Initialize a \index{state vector}state vector $\mathbf{x}$ having
these components:

\begin{enumerate}
\item \index{latitude}latitude, \index{longitude}longitude, altitude\index{altitude of aircraft}
in the \index{reference frame!l-frame@\emph{l-}frame!definition}\index{l-frame@\emph{l-}frame|see {reference frame, \emph{l-}frame}}\emph{l-}frame,
the local-level reference frame that rotates wiith the Earth and has
axes pointing east, north, and upward at the location of the aircraft;
. This reference frame, also called the local-level or ENU \index{reference frame!l-frame@\emph{l-}frame}reference
frame, has axes pointing \index{Earth!reference frame}east, north,
and upward at the location of the aircraft;
\item east, north, and upward velocity in the \emph{l-}frame
\item \index{pitch!{*}{*}}pitch, \index{roll!{*}{*}}roll, heading\index{heading!{*}{*}}
in the \index{a-frame@\emph{a-}frame|see {reference frame, \emph{a-}frame}}\emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame!definition}\index{reference frame!a-frame@\emph{a-}frame}\footnote{With appropriate transformations these calculations of attitude angles\index{attitude angle}
can be performed in the \emph{l-}frame instead, and there are some
advantages because the \emph{l-}frame values of errors\index{error!pitch}\index{error!roll}\index{error!l-frame@\emph{l-}frame}
in pitch and roll, respectively representing southward and westward
tilts of the virtual inertial platform, are not mixed together when
the heading changes as they are in the \emph{a-}frame. This was not
done in the calculations presented here.} (the reference frame of the aircraft; cf.~Sect.~\ref{subsec:deriv-array}
item 2).
\end{enumerate}
\item For each time increment:

\begin{enumerate}
\item Calculate the time derivative of the state vector.\index{state vector!derivative}
 In the case of the attitude angles,\index{attitude angle!derivative}
this is done by calculating the derivative\index{transformation matrix!derivative}
of the \index{transformation!beween reference frames|see {reference \\
frame, transformation}}\index{reference frame!transformation}transformation \index{matrix!coordinate transformation}matrix
from the \emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame}
to the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
and then using the definition of components of that matrix to find
the derivative of the attitude angles.
\item Use that derivative vector\index{state vector!derivative}  to increment
the state vector, compensating for possible wrap-around of the heading
at 0 and 360 deg so that values stay within that range.
\item save the nine components of the \index{state vector}state vector
in a new tabulation that represents an independent \index{mechanization}mechanization
of the IRU-provided \index{measurement!from IRU}measurements. These
new results should then be in reasonable agreement with the INS integration.
\end{enumerate}
\end{enumerate}

\subsection{Components of the derivative array\label{subsec:deriv-array}}

\index{state vector!derivative}The derivatives are calculated as
follows:
\begin{enumerate}
\item The position\index{position!derivative} derivatives are determined
from the components of the velocity, \{$v_{e},\,v_{n},\,v_{z}$\}.\index{velocity of aircraft}
The changes in latitude\index{latitude} and longitude\index{longitude}
depend on the normal and meridional \index{radius of curvature!normal}\index{radius of curvature!meridional}radii
of curvature of the Earth\index{Earth!radius|see {radius of curvature}},
respectively denoted $R_{n}$ and $R_{m}$. \citet{noureldin2013fundamentals},
pp.~47\textendash 48, provide definitions of these radii and a detailed
derivation. The derivatives of \index{latitude!symbol}latitude $\lambda$
and longitude\index{longitude!symbol} $\Phi$ are then\\
\begin{eqnarray}
\dot{\lambda} & = & \frac{v_{n}}{R_{m}+z}\label{eq:dlat}\\
\dot{\Phi} & = & \frac{v_{e}}{(R_{n}+z)\cos\lambda}\label{eq:dlong}
\end{eqnarray}
where $z$ is the altitude of the aircraft,\index{altitude of aircraft}
with the derivative\\
\begin{eqnarray}
\dot{z} & = & v_{z}\label{eq:dz}
\end{eqnarray}
where dots over quantities denote the time derivatives.\\
\item The velocity\index{velocity of aircraft!derivative} derivatives are
determined from the measured \index{measurement!acceleration}accelerations,\index{acceleration!measurement}
 but the accelerations are measured in the \index{reference frame!a-frame@\emph{a-}frame!definition}\emph{a-}frame,
with axes such that the unit coordinate vectors\index{reference frame!a-frame@\emph{a-}frame!unit vectors}
are $\hat{x}$ forward along the longitudinal axis of the aircraft,\index{aircraft!coordinate system}
$\hat{y}$ in the direction of the starboard wing, and $\hat{z}$
along the direction determined by their cross product and generally
downward. These measurements of acceleration must be \index{reference frame!transformation}transformed
to the \emph{l-}frame using the attitude angles\index{attitude angle}
for \index{pitch!{*}{*}}pitch, \index{roll!{*}{*}}roll, and \index{heading!{*}{*}}heading,
denoted \{$\theta,\,\phi,\,\psi$\}, because the components of velocity
are defined in that frame. In addition, because the accelerations
are measured in an inertial \index{reference frame!inertial}frame,
corrections must be made for the inertial forces\index{inertial corrections}
that arise because the \emph{l-}frame is moving relative to the Earth
and so is changing orientation, and because the rotation of the Earth\index{Earth!rotation rate}
introduces additional Coriolis\index{Coriolis|see {inertial corrections}}\index{acceleration!Coriolis|see {inertial corrections}}
accelerations relative to an inertial \index{reference frame!inertial}frame.\index{inertial corrections}
The coordinate\index{matrix!coordinate transformation} transformation
matrix that \index{reference frame!transformation}transforms a vector
from the \emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame}
to the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
will be denoted $\mathbf{R}_{a}^{l}$ and consists of four sequential
transformations, first a rotation by $\phi$ about the roll axis,
then a rotation by $\theta$ about the pitch axis, then a rotation
by $\psi$ about the resulting $\hat{z}$ axis, and finally exchange
of the $\hat{x}$ and $\hat{y}$ components and reversal of the sign
of the $\hat{z}$ component to change to the \emph{l-}frame reference\index{reference frame}
frame. The transformation was presented in detail by \citet{Bulletin23},
and is also specified and developed in the workflow document\index{workflow document}
that accompanies this technical note. The \emph{a-}frame measurements
of acceleration are \index{reference frame!transformation}transformed
to the \index{measurement!acceleration!l-frame@\emph{l-}frame}\emph{l-}frame
using this transformation \index{matrix!coordinate transformation}matrix
after the acceleration of gravity\index{gravity} is added to the
\index{acceleration!normal component}normal component because the
\index{inertial reference unit}IRU reports the \index{measurement!from IRU!normal acceleration}normal
component of gravity as that with the acceleration of gravity subtracted.
Then the transformed accelerations are corrected for apparent \index{inertial corrections}forces
generated by the inertial forces. \citet{noureldin2013fundamentals},
pp.~178\textendash 179, give the equations used, and these are repeated
in the workflow document.
\item Calculating the derivatives\index{attitude angle!derivative} of the
attitude angles\index{attitude angle!derivative} is more involved.
The attitude angles can be found if the \index{reference frame!transformation}transformation
matrix\index{matrix!coordinate transformation} $\mathbf{R}_{a}^{l}$
is known by using the definitions of the components of that matrix
in terms of the attitude angles. For example, the {[}3, 1{]} component
of that matrix is $-\sin\theta$, so $\theta=-\arcsin(R_{a}^{l}[3,1])$.
The \index{measurement!rotation rate!l-frame@\emph{l-}frame}measured
rotation rates, \index{reference frame!transformation}transformed
to the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
give the derivative of the transformation matrix,\index{matrix!coordinate transformation!derivative}
except that again corrections for inertial effects\index{inertial corrections}
arising from the Earth's \index{Earth!rotation rate}rotation and
the \index{reference frame!l-frame@\emph{l-}frame!motion of}motion
of the \emph{l-}frame are needed. \citet{noureldin2013fundamentals},
pp.~179\textendash 180, also provide the required correction for
the derivative of the transformation matrix, as documented further
in the workflow \index{workflow document}document and the code. These
corrections also are discussed in more detail in Sect.~\ref{subsec:Rotations},
equations (\ref{eq:Rla-dot})\textendash (\ref{eq:Omega2-iaa}).
\end{enumerate}
The \index{state vector!derivative!function}function ``STMFV''
returns these \index{state vector!derivative} derivatives, given
the \index{state vector}state vector and the \index{measurement!from IRU}measurements
from the \index{inertial reference unit}IRU\@. The algorithms and
code are complicated enough that validation is important, so several
tests are made of the results in the remainder of this section.

\subsection{Tests of the derivatives}

\subsubsection{Validating the transformed accelerations\label{subsec:Checking-accelerations} }

<<check-accelerations, include=TRUE, digits=4, cache=CACHE>>=

options(scipen = 1, digits = 4)

D1 <- Data  ## temporary; avoid making changes to the reference data.frame
D1$Rn <- Ree / (1 - (Ecc*sin(D1$GGLAT*Cradeg))^2)^0.5
D1$Rm <- D1$Rn * (1-Ecc^2) / (1-(Ecc*sin(D1$GGLAT*Cradeg))^2) + D1$GGALT
D1$Rn <- D1$Rn + D1$GGALT
D1$Grav <- Gravity (D1$LAT, D1$GGALT)
PC <- CorrectPitch (D1)
# D1$PITCH <- D1$PITCH - PC[, 1]
# D1$ROLL <- D1$ROLL - PC[, 2]

## adjust GPS velocity components for GPS antenna location
LG <- -4.30 
# D1$GGVEW <- D1$GGVEW - LG * D1$hdot * cos(D1$ROLL*Cradeg) * cos(D1$THDG*Cradeg) * Cradeg
# D1$GGVNS <- D1$GGVNS + LG * D1$hdot * cos(D1$ROLL*Cradeg) * sin(D1$THDG*Cradeg) * Cradeg
# D1$GGVSPD <- D1$GGVSPD - LG * (D1$pdot + D1$hdot * sin(D1$ROLL*Cradeg)) * Cradeg

#interpolate if necessary: otherwise later filters fail
MaxGap <- 1000
for (V in c('GGVNS', 'GGVEW', 'GGVSPD', 'VNS', 'VEW', 'VSPD')) {
  D1[, V] <- zoo::na.approx (as.vector (D1[, V]), maxgap=MaxGap, na.rm=FALSE)
}

## smooth the measurements when determining derivatives
.span <- 25    
## The following are accelerations determined from derivatives of the INS and GPS velocities.
## These should match the measured accelerations after transformation to the l-frame
## and application of the rotation correction:
D1$vndot <- signal::sgolayfilt (D1$GGVNS, 3, .span, m=1) * Rate  # m=1 for first deriv.
D1$vedot <- signal::sgolayfilt (D1$GGVEW, 3, .span, m=1) * Rate
D1$vudot <- signal::sgolayfilt (D1$GGVSPD, 3, .span, m=1) * Rate
D1$vndot2 <- signal::sgolayfilt (D1$VNS, 3, .span, m=1) * Rate  # m=1 for first deriv.
D1$vedot2 <- signal::sgolayfilt (D1$VEW, 3, .span, m=1) * Rate
D1$vudot2 <- signal::sgolayfilt (D1$VSPD, 3, .span, m=1) * Rate
## transform to the a-frame for comparison to the IRU:
G <- D1$Grav
VL <- matrix(c(D1$GGVEW, D1$GGVNS, D1$GGVSPD), ncol=3)
VL2 <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3)
LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - G), ncol=3) + RotationCorrection (D1, VL) 
LA2 <- matrix (c(D1$vedot2, D1$vndot2, -D1$vudot2 - G), ncol=3) + RotationCorrection (D1, VL2)
AA <- XformLA (D1, LA, .inverse=TRUE)
AA2 <- XformLA (D1, LA2, .inverse=TRUE)
AA[,3] <- AA[,3] - G
AA2[,3] <- AA2[,3] - G
fa1 <- lm(AA[, 1] ~ D1$BLONGA)
fa2 <- lm(AA[, 2] ~ D1$BLATA)
fa3 <- lm(AA[, 3] ~ D1$BNORMA)
fb1 <- lm(AA2[, 1] ~ D1$BLONGA)
fb2 <- lm(AA2[, 2] ~ D1$BLATA)
fb3 <- lm(AA2[, 3] ~ D1$BNORMA)
cfa1 <- coef(fa1); cfa2 <- coef(fa2); cfa3 <- coef(fa3)
D1$BLONGA <- cfa1[1] + cfa1[2] * Data$BLONGA
D1$BLATA  <- cfa2[1] + cfa2[2] * Data$BLATA
D1$BNORMA <- cfa3[1] + cfa3[2] * Data$BNORMA
AB <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #a-frame 
AL <- XformLA (D1, AB)                                    #l-frame
## now corrected for angular effects
## See Noureldin et al, 2013, Eq. (5.55)
RC <- RotationCorrection (D1, VL)
AL <- AL - RC  ##### note this sign and prev call above -- checked!
  
## the resulting l-frame accelerations
D1$LACCX <- AL[, 1]
D1$LACCY <- AL[, 2]
D1$LACCZ <- AL[, 3] + G
D1$LACCZ <- -D1$LACCZ
  
## smooth to match GPS-velocity derivatives
D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)

fm1 <- lm (D1$vedot ~ D1$LACCX)
fm2 <- lm (D1$vndot ~ D1$LACCY)
fm3 <- lm (D1$vudot ~ D1$LACCZ)
fn1 <- lm (D1$vedot2 ~ D1$LACCX)
fn2 <- lm (D1$vndot2 ~ D1$LACCY)
fn3 <- lm (D1$vudot2 ~ D1$LACCZ)
c01 <- summary(fm1)$coef[1]
c11 <- summary(fm1)$coef[2]
s1 <- summary(fm1)$sigma
r1 <- summary(fm1)$r.squared
c02 <- summary(fm2)$coef[1]
c12 <- summary(fm2)$coef[2]
s2 <- summary(fm2)$sigma
r2 <- summary(fm2)$r.squared
c03 <- summary(fm3)$coef[1]
c13 <- summary(fm3)$coef[2]
s3 <- summary(fm3)$sigma
r3 <- summary(fm3)$r.squared
c04 <- summary(fn1)$coef[1]
c14 <- summary(fn1)$coef[2]
s4 <- summary(fn1)$sigma
r4 <- summary(fn1)$r.squared
c05 <- summary(fn2)$coef[1]
c15 <- summary(fn2)$coef[2]
s5 <- summary(fn2)$sigma
r5 <- summary(fn2)$r.squared
c06 <- summary(fn3)$coef[1]
c16 <- summary(fn3)$coef[2]
s6 <- summary(fn3)$sigma
r6 <- summary(fn3)$r.squared
options(digits=5)

@

\index{reference frame!transformation}The components of acceleration\index{acceleration!measurement}
 expressed in the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
can be compared to the accelerations determined by differentiating
either the INS-provided or the \index{navigation system!GPS}GPS-based
measurements of aircraft velocity.\index{velocity of aircraft} The
former is a test of the calculation; the latter is a test of the calibration\index{calibration!accelerometer}
of the accelerometers. The derivatives of the velocity\index{velocity of aircraft!derivative}
were determined by taking differences between consecutive measurements,
although it was useful to \index{smoothing}smooth the result using
a Savitzky-Golay\index{polynomial!Savitzky-Golay}\index{filter!Savitzky-Golay}
third-order polynomial spanning 11 25-Hz samples to reduce noise arising
from the limited resolution of the differences. 

Relative timing among the \index{measurement!time lag}measurements
can influence these results. Many of the variables have corrections
applied for assumed time-lags during measurement, so in this test
of accelerations those lags\index{time lag} were first removed. Then
there were additional lags apparent among variables provided by the
\index{navigation system!inertial}INS, even when tagged with the
same times. To determine these lags, a pitch \index{maneuver!pitch}maneuver
(where the pilots induce rapid changes in pitch with associated climbs
and descents during straight flight) from DEEPWAVE\index{DEEPWAVE research project}\index{DEEPWAVE research project!full name}
(``Deep Propagating Gravity Wave Experiment over New Zealand'')
research flight 15, 3 July 2014, 3:16:00\textendash 3:18:00 UTC was
used. Shifting among the measurements from the INS was explored to
see what provided the best agreement between measured accelerations
(variables \sindex[var]{BLONGA: body-longitudinal acceleration}BLONGA,
\sindex[var]{BLATA: body-lateral acceleration}BLATA, \sindex[var]{BNORMA: body-normal acceleration}BNORMA)\index{file!data!variable|see {netCDF Variable Names}}\index{variable in data files|seealso { netCDF Variable Names}}\index{variable in data files!BLONGA}\index{variable in data files!BLATA}\index{variable in data files!BNORMA}
and the accelerations determined by differentiating the INS variables
for aircraft velocity\index{velocity of aircraft} (\sindex[var]{VEW: ground speed eastward, INS}VEW,
\sindex[var]{VNS: ground speed northward, INS}VNS, \sindex[var]{VSPD: rate of climb, INS}VSPD)\index{variable in data files!VEW}\index{variable in data files!VNS}\index{variable in data files!VSPD}
and then transforming\index{reference frame!transformation} the resulting
accelerations to the \emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame}
(where the \index{inertial reference unit}IRU \index{measurement!from IRU}measures
accelerations). That transformation must include correction for inertial
effects\index{inertial corrections}  as discussed in Sect.~\ref{subsec:deriv-array},
item 2. The standard deviation\index{deviation, standard!acceleration}\index{standard deviation|see {deviation, standard}}
of the difference between the measured acceleration and that determined
by differentiating the measured aircraft velocity was minimized if
the measurements of acceleration were moved 50~ms earlier in time,
the measurements of pitch and roll were shifted 20~ms later in time,
and no shift was applied to the measurements of aircraft velocity.\index{measurement!time lag}\index{time lag}\index{time lag}
These shifts are all important only in relation to each other; the
same result was obtained if the accelerations were moved earlier by
70~ms, measurements of velocity moved earlier by 20~ms, and measurements
of pitch and roll left unshifted. \index{measurement!time lag}According
to the specifications for the INS, there may be lags in the times
when variables are transmitted from the unit of up to about 70~ms
for accelerations and attitude angles\index{attitude angle!lag} and
up to 110~ms for velocity components, so these shifts are within
the approximate range expected. For the purpose of comparing accelerations,
the optimal shifts were applied to the measurements for this pitch
maneuver.\footnote{There is no assurance that these shifts will be constant.}
\begin{table}
\centering{}%
\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline 
\emph{fit} & $c_{0}$ {[}m\,s$^{-2}${]} & $c_{1}$ & $\sigma$ {[}m\,s$^{-2}${]} & $R^{2}$\tabularnewline
\hline 
\hline 
GPS east & \Sexpr{c01} & \Sexpr{c11} & \Sexpr{s1} & \Sexpr{r1}\tabularnewline
\hline 
GPS north & \Sexpr{c02} & \Sexpr{c12} & \Sexpr{s2} & \Sexpr{r2}\tabularnewline
\hline 
INS east & \Sexpr{c04} & \Sexpr{c14} & \Sexpr{s4} & \Sexpr{r4}\tabularnewline
\hline 
INS north & \Sexpr{c05} & \Sexpr{c15} & \Sexpr{s5} & \Sexpr{r5}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\caption{Results\index{navigation system!GPS}\index{navigation system!inertial}
of regression fitting the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
\index{measurement!from INS}\index{measurement!from GPS}acceleration\index{acceleration!measurement}
 as a function of the derivative\index{velocity of aircraft!derivative}
of the variable listed in the ``fit'' column. The coefficients\index{calibration!accelerometer!fit coefficients}
represent, for example, $\dot{v}_{e}\sim c_{0}+c_{1}a_{e}^{l}$ where
$a_{e}^{l}$ is the eastward component of acceleration after \index{reference frame!transformation}transformation
to the \emph{l-}frame. The residual standard deviation\index{deviation, standard!fit residual}
is tabulated as $\sigma,$ and the square of the correlation coefficient
is $R^{2}$.\label{tab:accel-fits}}
%
\end{minipage}}
\end{table}
\begin{table}
\centering{}%
\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\emph{Component} & $c_{0}$ {[}m~s$^{-2}$ {]} & $c_{1}$\tabularnewline
\hline 
\hline 
BLONGA\sindex[var]{BLONGA: body-longitudinal acceleration} & \Sexpr{summary(fa1)$coef[1]} & \Sexpr{summary(fa1)$coef[2]}\tabularnewline
\hline 
BLATA\sindex[var]{BLATA: body-lateral acceleration} & \Sexpr{summary(fa2)$coef[1]} & \Sexpr{summary(fa2)$coef[2]}\tabularnewline
\hline 
\sindex[var]{BNORMA: body-normal acceleration}BNORMA & \Sexpr{summary(fa3)$coef[1]} & \Sexpr{summary(fa3)$coef[2]}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\caption{Results like those in the preceding table but for \index{measurement!from IRU!calibration}accelerations\index{acceleration!measurement}
 in the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame.\label{tab:a-frame-fits}}
%
\end{minipage}}
\end{table}

Table \ref{tab:accel-fits} shows the results of linear \index{fit!regression!acceleration}fits
of the measured accelerations\index{acceleration!fits} after \index{reference frame!transformation}transformation
to the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
(with inertial corrections) to the derivatives\index{velocity of aircraft!derivative}\index{acceleration!from velocity derivative}
determined by differentiation. The GPS\index{navigation system!GPS}
measurements provide independent measurements of the accelerations,
so the first two fits can be considered tests of the calibrations\index{calibration!accelerometer}
of the accelerometers as well as a test of the algorithms and code.
They indicate only small offsets and near-unity slopes. The last
two fits compare only INS-provided values, so they test the validity
of the transformations and protect against any unknown calibration
adjustments that might have been applied by the INS without affecting
the reported accelerations. 

A better direct estimate of accelerometer \index{measurement!from IRU!calibration}calibration
can be obtained by \index{reference frame!transformation}transforming
the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
\index{acceleration!l-frame@\emph{l-}frame}accelerations determined
by differentiating the \index{navigation system!GPS}GPS-based velocity
to the \index{acceleration!a-frame@\emph{a-}frame}\index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame,
where they can be compared directly to the components of the measured
accelerations.\index{acceleration!fits} When this is done, the calibrations\index{calibration!accelerometer}\index{accelerometer!calibration|see {calibration, accelerometer}}
in Table~\ref{tab:a-frame-fits} result from linear fits. Lateral
accelerations\index{acceleration!lateral} are usually small, so the
second calibration is not as reliable as the other two, but all show
reasonable agreement between the calibrations in use and those indicated
by these fits. Although the small adjustments have little effect,
the calibrations indicated in this table will be applied to the measured
accelerations in the remainder of this technical note.

<<plot-acc, include=TRUE, fig.height=6, fig.scap="Comparison of IRU-measured accelerations  to the accelerations determined by differentiating the velocity components measured by the GPS receiver.", fig.cap='Comparison of measured accelerations (BLONGA, BLATA, BNORMA, blue lines) to the accelerations determined by differentiating the velocity components measured by the GPS receiver and then transforming these to the a-frame (dashed red lines), from a portion of DEEPWAVE flight 15 that included a pitch maneuver, a speed run and a yaw maneuver at the times corresponding to the plot annotations.', cache=CACHE>>=

# source ('chunks/multiplot.R')

# layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
# op <- par (mar=c(2,4,1,1)+0.1)
# r <- setRange(D1, 33330, 33515)

source ('~/RStudio/Ranadu/R/ggplotWAC.R')
# grid.newpage()
D1$AA1 <- AA[,1]
D1$AA2 <- AA[,2]
D1$AA3 <- AA[,3]
t1 <- D1$Time[getIndex(D1, 31700)]
t2 <- D1$Time[getIndex(D1, 32535)]
t3 <- D1$Time[getIndex(D1, 33320)]
PanelGroup <- gl (3, 3, labels=c('longitudinal', 'lateral', 'normal'))
label.df <- data.frame (t=c(t1,t2,t3), y=c(-0.4,1.7,0.3), 
                        PanelGroup, label=c('pitch', 'speed-run', 'yaw'))
d <- with (D1[setRange(D1, 31300, 33600), ], data.frame(Time, BLONGA, AA1, BLATA, AA2, BNORMA, AA3))
suppressWarnings (print (
ggplotWAC(d, col=c('blue', 'red'), lwd=c(0.8,0.6), lty=c(1,42), panels=3,
          ylab=expression(paste('acceleration [m ',s^2,']')),
          labelL=c('IRU', 'GPS'), labelP=c('longitudinal', 'lateral', 'normal'), 
          legend.position=c(0.8, 0.94), theme.version=1) 
        + geom_label (aes(x=t, y=y, label=label), data=label.df[4,], inherit.aes=FALSE)
        + geom_label (aes(x=t, y=y, label=label), data=label.df[2,], inherit.aes=FALSE)
        + geom_label (aes(x=t, y=y, label=label), data=label.df[6,], inherit.aes=FALSE)
))

## use the calibration determined by comparison to GPS:
cfa1 <- coef(fa1); cfa2 <- coef(fa2); cfa3 <- coef(fa3)
Data$BLONGA <- cfa1[1] + cfa1[2] * Data$BLONGA
Data$BLATA  <- cfa2[1] + cfa2[2] * Data$BLATA
Data$BNORMA <- cfa3[1] + cfa3[2] * Data$BNORMA

@

Figure \ref{fig:plot-acc}\index{acceleration!measurement}\index{comparison!acceleration}
 shows a short flight segment comparing the measured \index{measurement!from IRU!surrogate for}accelerations
and the accelerations determined by differentiating the \index{navigation system!GPS}GPS-based
velocity and \index{reference frame!transformation}transforming to
the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame.
There were three \index{maneuver}maneuvers that introduced accelerations:
(i) a pitch maneuver\index{maneuver!pitch} near 3:17:00 UTC where
pilots varied the pitch rapidly, causing periodic accelerations normal
to the aircraft; (ii) a speed run\index{maneuver!speed run} centered
near 3:25:00 UTC where the airspeed\index{airspeed} was varied through
the flight envelope of the \index{aircraft!NSF/NCAR GV}GV, producing
large changes in pitch and resulting resolution of the acceleration
of \index{gravity}gravity into varying contributions to the longitudinal
and normal components of acceleration; and (iii) a yaw maneuver\index{maneuver!yaw}
near 3:34:00 UTC where lateral accelerations\index{acceleration!lateral}
were induced by rudder action. The good agreement and the near-identity
calibrations tabulated above support that the accelerations are being
treated properly in the calculations and also that the calibrations
of the accelerometers\index{calibration!accelerometer} are good.

<<mechanization, include=TRUE, fig.lp='fig:', cache=CACHE>>=

## These very small adjustments prevent gradual ramping during the flight.
D1$BROLLR <- D1$BROLLR + 0.00026
D1$BPITCHR <- D1$BPITCHR + 0.00026
stm <- STMFV (D1, .components=9)  ## get the whole-flight derivative matrix
DXN <- c('VEW', 'VNS', 'VSPD', 'PITCH', 'ROLL', 'THDG')
CRF <- c(rep(1,3), rep(Cradeg,3))
for (j in 1:6) {
  D1[, gsub ('$', 'X', DXN[j])] <- CRF[j] * D1[1, DXN[j]] + dt * cumsum (stm[, j+3])
}
D1$THDGX <- (D1$THDGX + 10 * pi) %% (2*pi)
D1$PITCHX <- D1$PITCHX / Cradeg
D1$ROLLX <- D1$ROLLX / Cradeg
D1$THDGX <- D1$THDGX / Cradeg
DTHDG <- D1$THDG - D1$THDGX
DTHDG[DTHDG < -180] <- DTHDG[DTHDG < -180] + 360
DTHDG[DTHDG > 180] <- DTHDG[DTHDG > 180] - 360

## these are remnants of previous code, saved here temporarily as comments
## feedback coefficients for baro loop:
# C0 <- 0.15; C1 <- 0.0075; C2 <- 0.000125
# wp3F <- 0;
# hxF <- hxxF <- 0
# hi3F <- SP$GGALT[1]
# RK <- TRUE    ## use Runge-Kutta integration if true
# RK <- FALSE
# DL <- nrow(SP)

#   if (RK) {
#     stmf1 <- c(STMFV (sv, .components=9), rep(0,6))
#     sv1 <- sv + stmf1 * dt/2
#     stmf2 <- c(STMFV (sv1, .components=9), rep(0,6))
#     sv2 <- sv + stmf2 * dt/2
#     stmf3 <- c(STMFV (sv2, .components=9), rep(0,6))
#     sv3 <- sv + stmf3 * dt
#     stmf4 <- c(STMFV (sv3, .components=9), rep(0,6))
#     stmf <- (stmf1 + stmf4 + 2*(stmf2+stmf3))/6
#   } 
#   wp3F <- wp3F + (stmf[6] - C1*hxF - C2 * hxxF) * dt
#   hi3F <- hi3F + (wp3F - C0 * hxF) * dt
#   hxF <- hi3F - SP$GGALT[i]
#   hxxF <- hxxF + hxF * dt
#   sv[6] <- 0.5 * (sv[6] + wp3F)

@

\subsubsection{Validating the rotation rates\label{subsec:Checking-the-rotation}}

\index{measurement!rotation rate!validating}Independent measurements
of \index{measurement!from IRU}rotation rates are not available as
they are for accelerations, so similar direct tests and calibrations
are not possible. However, if the wind remains constant, a flight
maneuver consisting of a circular pattern\index{maneuver!circle}
should produce a 360$^{\circ}$change in heading, and the start and
end points can be identified from \index{navigation system!GPS}GPS-based
measurements by finding the times when the groundspeed components
return to their original values. DEEPWAVE\index{DEEPWAVE research project}
flight 15 included several circle\index{maneuver!circle} patterns
in the flight plan, including four from 3:38:00 to 3:55:00 UTC, two
counterclockwise and then two clockwise. Without inertial corrections,
which are very small integrated over the circles, the rate of change
in heading\index{heading!rate of change}\index{variable in data files!BYAWR}\sindex[var]{BYAWR: body yaw rate, inertial}
should be $\dot{\psi}$=BYAWR/$\cos\phi$ where BYAWR is the rotation
rate about the yaw axis as reported by the IRU and $\phi$ is the
roll angle, so comparing this to the change in heading tests that
the reported rotation rates are correct. The total heading change
from 3:38:50 to 3:46:40 is $-$718.2$^{\circ}$, while the sum of
BYAWR/$\cos\phi$ for the same time interval is $-720.1^{\circ}$,
so these agree to within 0.2\%. For the two clockwise turns from 3:46:40
to 3:54:30, the corresponding sums are 720.1 and 720.6, in still better
agreement. This only tests for consistency, because the INS\index{navigation system!inertial!mechanization}
mechanization should produce the same result as that obtained by the
difference in output variables, but one significant conclusion is
that the inertial\index{inertial corrections} corrections have only
a very small net effect on the rotation rate about the heading or
yaw axis. 

<<psi-dot, include=TRUE, cache=CACHE>>=

A <- atan2(D1$vedot, D1$vndot)/Cradeg
r1 <- setRange(D1, 33938, 34610)
r2 <- setRange (D1, 34730, 35348)
dA <- c(0, diff(A))
dA[dA > 180] <- dA[dA > 180] - 360
dA[dA < -180] <- dA[dA < -180] + 360
mdh1 <- mean(D1$hdot[r1])
mda1 <- mean(dA[r1]) * Rate
mdh2 <- mean(D1$hdot[r2])
mda2 <- mean(dA[r2]) * Rate
sdmh1 <- sd(D1$hdot[r1]) / sqrt(length(r1)-1)
sdmh2 <- sd(D1$hdot[r1]) / sqrt(length(r2)-1)
sdma1 <- sd(dA[r1]) * Rate / sqrt(length(r1)-1)
sdma2 <- sd(dA[r1]) * Rate / sqrt (length(r2)-1)
cfydot <- coef(lm (c(mda1, mda2) ~ c(mdh1, mdh2)))


@

Another test of the rotation rate about the yaw axis can be obtained
by comparing $\dot{\psi}$ in steady turns to the rate of change in
the orientation of the acceleration vector determined from the \index{navigation system!GPS}GPS.
In circle\index{maneuver!circle} maneuvers, the horizontal component
of the acceleration vector should rotate at a rate equal to $\dot{\psi}$,
so this provides a test of the calibration\index{calibration!rotation rate}
of the rotation rate provided by the \index{inertial reference unit}IRU
\index{gyro}gyros. Table~\ref{tab:hrot-comparison} shows the comparison\index{comparison!rotation rate}
of rotation rates obtained in these two independent ways. The consistency
between turn rates is remarkable, and a calibration representing both
turn directions is $\dot{\psi}_{cal}=a_{0}+a_{1}\dot{\psi}$ where
$a_{0}=$\Sexpr{round(cfydot[1], 3)}$^{\circ}\mathrm{s^{-1}}$ and
$a_{1}$=\Sexpr{round(cfydot[2],3)}. Because the cosine of the mean
roll angle was steady at 0.89$_{4}$, the corresponding calibration\index{calibration!rotation rate}
of \sindex[var]{BYAWR: body yaw rate, inertial}BYAWR\index{variable in data files!BYAWR}
would use the first coefficient multiplied by 0.89$_{4}$; i.e., $\mathrm{BYAWR}{}_{cal}=a_{0}^{*}+a_{1}\mathrm{BYAWR}$
where $a_{0}^{*}=$\Sexpr{round(cfydot[1]*0.894,3)}$^{\circ}\mathrm{s^{-1}}$.
This confirms that the \index{measurement!rotation rate!offset}offset
in the measured \index{measurement!from IRU!calibration}rotation
rate about the heading\index{heading!rate of change} axis is small
and the slope coefficient is indistinguishable from unity in this
test.

\begin{table}
\begin{centering}
\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline 
turn direction & mean, $\left\langle \dot{\psi}\right\rangle $ & std. dev. in $\left\langle \dot{\psi}\right\rangle $ & mean, $\left\langle \dot{\psi}^{*}\right\rangle $  & std. dev. in $\left\langle \dot{\psi}^{*}\right\rangle $\tabularnewline
\hline 
\hline 
left & \Sexpr{round(mdh1,3)} & \Sexpr{round(sdmh1,3)} & \Sexpr{round(mda1,3)} & \Sexpr{round(sdma1,3)}\tabularnewline
\hline 
right & \Sexpr{round(mdh2,3)} & \Sexpr{round(sdmh2,3)} & \Sexpr{round(mda2,3)} & \Sexpr{round(sdma2,3)}\tabularnewline
\hline 
\end{tabular}
\par\end{center}
\caption{Comparison\index{comparison!heading rate of change} of the rate of
change in \index{heading!rate of change}heading ($\dot{\psi}$) to
the rate of change in the direction of the acceleration vector determined
from differentiation of \index{navigation system!GPS}GPS-based velocity
components ($\dot{\psi}^{*}$). All units are {[}$^{\circ}\mathrm{s}^{-1}]$.
The listed standard deviations\index{deviation, standard!turn rate}
are those estimated for the mean \index{measurement!from IRU!calibration}measurement.\label{tab:hrot-comparison}}
%
\end{minipage}}
\par\end{centering}
\end{table}

Similar tests of the pitch and roll angles based on the GPS measurements
are not possible. However, the critical test of the angle derivatives\index{attitude angle!derivative}
is to transform\index{reference frame!transformation} the measured
derivatives\index{derivative!transformation to a-frame@transformation to \emph{a-}frame}
for pitch, roll, and heading to the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame,
with appropriate correction for inertial \index{inertial corrections}effects,
and verify that the results match the \index{measurement!from IRU}measured
\index{rotation rate of aircraft!a-frame@\emph{a-}frame}rotation
rates. The retrieval algorithm is discussed in a following section
(Sect.~\ref{subsec:Rotations}) because it is also useful for obtaining
surrogates for the body rotation rates\index{rotation rate of aircraft!surrogate for measurement}
in cases where they were not recorded or were not in the archive \index{file!data}files.\index{data!standard archive}
Plots and \index{fit!regression!rotation rate}fits confirm that the
transformed rotation rates\index{rotation rate of aircraft} obtained
in this way match the \index{measurement!from IRU}measured rotation
rates to within very small tolerances. For example, for the yaw rotation
rate, a linear fit gives coefficients (-0.0003, 1.000001) for a fit\index{fit!coefficients!rotation rate}
of the transformed values to the measured values, with \index{deviation, standard!turn rate}standard
deviation smaller than 0.01~$^{\circ}$\,s$^{-1}$ and correlation
coefficient 0.99997. Similar agreement was obtained for the pitch
and roll angles. This is evidence that, as formulated in the code
of the present document, the coordinate\index{reference frame!transformation}
transformations and inertial corrections match those applied by the
INS during the original mechanization. 

As argued in Sect.~\ref{subsec:mech-procedures}, integration\index{integration!duplicating INS}
using the calculated \index{state vector!derivative}derivatives and
comparison\index{comparison!to INS mechanization} to the \index{navigation system!inertial}INS-provided
variables is the crucial test of the derivatives that the derivative
function\index{function!derivative} must pass if it is to be used
in the Kalman filter. That is the topic of the next subsection.

<<find-rotation-correction, include=TRUE, cache=CACHE>>=

DL <- nrow(D1)
OmegaE <- StandardConstant ('Omega')

## the derivative of the transformation matrix in terms of hdot etc.
with (D1, {
  ch <- cos(THDG*Cradeg)
  sh <- sin(THDG*Cradeg)
  cp <- cos(PITCH*Cradeg)
  sp <- sin(PITCH*Cradeg)
  cr <- cos(ROLL*Cradeg)
  sr <- sin(ROLL*Cradeg)
  Rd <<- c(hdot*ch*cp-pdot*sh*sp,    ## note <<- assignment to get out of with() environment
           hdot*(ch*sp*sr-sh*cr)  + pdot*sh*cp*sr    + rdot*(sh*sp*cr-ch*sr),
           hdot*(-sh*sr-ch*sp*cr) + pdot*(-sh*cp*cr) + rdot*(ch*cr+sh*sp*sr),
           hdot*(-sh*cp)          + pdot*(-ch*sp),
           hdot*(-sh*sp*sr-ch*cr) + pdot*ch*cp*sr    + rdot*(ch*sp*cr+sh*sr),
           hdot*(sh*sp*cr-ch*sr)  + pdot*(-ch*cp*cr) + rdot*(ch*sp*sr-sh*cr),
           - pdot*cp,
           pdot*(-sp*sr)    + rdot*cp*cr,
           pdot*sp*cr       + rdot*cp*sr)
})
RdM <- aperm(array (Rd, dim=c(nrow(D1),3,3)))
OmegaA <- array (0, dim=c(nrow(D1),3,3))
rlmA <- XformLA (D1)
lat <- D1$LAT * Cradeg
sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- sinLat / cosLat
omega1 <- matrix (c (rep(0, DL), OmegaE * cosLat, OmegaE * sinLat), ncol=3)
omega2 <- with(D1, matrix (c (-VNS / Rm,  VEW / Rn, VEW * tanLat / Rn), ncol=3))
omega <- omega1 + omega2
zro <- c(rep(0, DL))
SRRI <- array(c(zro, omega[,3], omega[,2],
                -omega[,3], zro, -omega[,1],
                -omega[,2], omega[,1], zro), dim=c(DL,3,3))

for (i in 1:nrow(D1)) {
  OmegaA[i,,] <- t(rlmA[,,i]) %*% (RdM[,,i] + SRRI[i,,] %*% rlmA[,,i])
}
D1$BP <- -OmegaA[,1,3]
D1$BR <- OmegaA[,2,3]
D1$BY <- -OmegaA[,1,2]
D1$DBP <- SmoothInterp(D1$BPITCHR-D1$BP, .Length=60*Rate+1)
D1$DBR <- SmoothInterp(D1$BROLLR-D1$BR, .Length=60*Rate+1)
D1$DBY <- SmoothInterp(D1$BYAWR-D1$BY, .Length=60*Rate+1)
D15 <- D1[2:nrow(D1),]  ## save it for plotting later, and modify it to avoid deletion
## remove some large arrays
rm (stm, rlmA, OmegaA, RdM, omega, omega1, omega2, zro, lat, sinLat, cosLat, tanLat, Rd)

@

\subsection{Mechanization using the derivatives\label{subsec:Mechanization}}

<<plot-mechanization, include=TRUE, fig.height=c(7,5), fig.lp='fig:', fig.scap=c("Comparison of INS-provided and integration-derived attitude angles.", "Comparison of INS-provided and integration-derived components of the aircraft velocity."), fig.cap=c('Comparison of INS-provided and integration-derived attitude angles, labeled "original" and "new", the latter plotted as dashed lines. The differences, multiplied by 10, are plotted as green lines.', 'Comparison of INS-provided and integration-derived components of the aircraft velocity, the latter plotted as dashed red lines. The former are {VEW, VNS} and the latter {VEWX, VNSX}, for respectively the northbound and eastbound components of the aircraft velocity.'), cache=CACHE>>=

# r <- setRange (Data, 31000, 35500)

D1$DPITCH <- D1$PITCHX-D1$PITCH
D1$DROLL <- (D1$ROLLX-D1$ROLL)
D1$DTHDG <- (180+(D1$THDGX-D1$THDG)) %% 360 - 180
D1$ZERO <- rep(0, nrow(D1))
D1$PI <- rep(180, nrow(D1))
#layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
#op <- par (mar=c(2,4,1,1)+0.1)
r <- setRange(D1, 32000, 35500)
d <- with(D1[r, ], data.frame(Time, PITCH, PITCHX, 10*DPITCH, ROLL, ROLLX, 10*DROLL,
                               THDG, THDGX, 10*DTHDG))
ggplotWAC(d, col=c('blue', 'red', 'forestgreen'), 
          ylab=expression(paste('attitude angles [',degree,']')),
          lwd=c(1.4,0.8,1), lty=c(1,42,1), panels=3,
          labelL=c('original', 'new', '10*diff'),
          labelP=c('pitch', 'roll', 'heading'),
          legend.position=c(0.8, 0.97), theme.version=1)




d <- with(D1[r,], data.frame(Time, VEW, VEWX, VNS, VNSX))
ggplotWAC(d, col=c('blue', 'red'), lwd=c(1.4,0.8), lty=c(1,42),
          ylab=expression(paste('velocity component [m ',s^-2,']')),
          panels=2,
          labelL=c('original', 'new'),
          labelP=c('eastward', 'northward'),
          legend.position=c(0.2, 0.97), theme.version=1)


# plotWAC (D1[r, c('Time', 'VSPD', 'VSPDX')])

op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
# SP <- SPR    ## restore to state before integration

@

\index{mechanization}\index{integration!duplicating INS}\index{state vector!derivative}The
flight segment to be used to test the derivative \index{function!derivative}\index{derivative function|see {function, derivative}}function,
from DEEPWAVE\index{DEEPWAVE research project} flight 15 3:20:00
to 3:55:00 UTC, included a ``speed run''\index{maneuver!speed run}
during which the aircraft\index{airspeed} airspeed varied from near-minimum
to near-maximum (centered on 3:25:00 UTC), a maneuver with variation
in sideslip angle,\index{maneuver!yaw} and four complete circles,\index{maneuver!circle}
two flown counterclockwise and two flown clockwise. To produce the
right values of the \index{state vector}state vector through these
maneuvers is therefore a good test of the mechanization. Figure~\ref{fig:plot-mechanization1}\index{attitude angle!new mechanization}\index{comparison!plot!attitude angles}
shows that there is very good agreement for heading and roll, and
pitch tracks well through a pitch maneuver (not shown) and the speed
run, but there are some small deviations between INS-provided values
and the new values for pitch during the prolonged turns. The cause
of this difference is not known, but it may be the result of residual
timing differences or an internal calibration used by the INS or some
difference in the \index{inertial corrections}inertial-correction
terms, which become important in the turns. However, even after 5
min of turning, the accumulated difference is smaller than 0.1$^{\circ}$,
so this is not a serious weakness, especially because wind \index{wind!measurement}measurements
from the GV\index{aircraft!NSF/NCAR GV} are usually considered to
have increased uncertainty in turns. Figure~\ref{fig:plot-mechanization2}\index{comparison!plot!velocity components}\index{velocity of aircraft!{*}{*}}
shows that the ground-speed\index{ground speed} components tracked
the INS values very closely through all the maneuvers. The key result
is thus that as implemented above the derivatives of components of
the state vector are approximately correct and integrate to values
very close to those originally produced by the INS. The \index{function!derivative}function
providing those \index{state vector!derivative}derivatives is therefore
a reasonable basis for the Kalman\index{Kalman filter} filter that
follows in Sect.~\ref{sec:The-Kalman-filter}.

\section{Ancillary topics}

\subsection{A new variable for rate of climb\label{subsec:ROC}}

<<new-data, include=TRUE, cache=FALSE>>=

Flight <- "16" 			
Project = "DEEPWAVE"     		
ProjectDir <- "DEEPWAVE"
fname = sprintf("%s%s/%srf%s.nc", Directory, ProjectDir, Project, Flight)

ReloadData <- TRUE
SaveRData2 <- sprintf("%s2.Rdata", thisFileName)
if (ReloadData) {
  source ('chunks/AcquireData.R')
  ## add ROC variable
  source ('chunks/ROC.R')
  ## need to save lots more here -- check environment
  save (Data, file=SaveRData2)
} else {
  load(file=SaveRData2)
}
D1 <- Data  ## make adjustments to a copy; avoid changing original
## adjustments:
source ('chunks/AdjustCal.R')

## GPS shifted vs INS in AdjustCal.R


## transform to the a-frame for comparison to the IRU:
VL <- matrix(c(D1$VEW, D1$VNS, D1$VSPD), ncol=3) 
LA <- matrix (c(D1$vedot, D1$vndot, -D1$vudot - D1$Grav), ncol=3) + RotationCorrection (D1, VL)
AA <- XformLA (D1, LA, .inverse=TRUE)
AA[,3] <- AA[,3] - D1$Grav
fa1 <- lm(D1$BLONGA ~ AA[, 1])
fa2 <- lm(D1$BLATA ~ AA[, 2])
fa3 <- lm(D1$BNORMA ~ AA[, 3])  
fm1 <- lm (D1$vedot ~ D1$LACCX)
fm2 <- lm (D1$vndot ~ D1$LACCY)
fm3 <- lm (D1$vudot ~ D1$LACCZ)

@

The integration\index{integration!INS!rate of climb} provided by
the INS\index{navigation system!inertial} includes variables for
rate of climb (\sindex[var]{VSPD: rate of climb, INS}VSPD)\index{variable in data files!VSPD}
and altitude\index{integration!INS!altitude} (ALT\sindex[var]{ALT: altitude, INS}),\index{variable in data files!ALT}
but both are updated using an algorithm that adjusts the altitude\index{altitude of aircraft!pressure}
to the pressure altitude. This is not the variable needed for calculation
of the \index{wind!vertical!calculation}vertical wind, and in baroclinic
regions it is easy to detect the false variations that arise in rate
of climb because of this updating scheme. The \index{navigation system!GPS}GPS-based
variable \sindex[var]{GGVSPD: rate of climb, GPS}GGVSPD\index{variable in data files!GGVSPD}
can be used instead, but it is likely that the INS can produce a better
representation of the high-frequency component, so it is useful to
consider another variable based on the INS-provided \index{measurement!from INS!new rate of climb}measurements
that can then be updated to GGVSPD via the Kalman filter. 

The \index{hydrostatic equation}hydrostatic equation provides a basis
for updating that is independent of the GPS: 

\begin{equation}
\frac{dz}{dp}=-\frac{R_{a}T}{pg}\label{eq:hydrostatic-equation}
\end{equation}
where $z$ is the geometric altitude,\index{altitude of aircraft!geometric}
$p$ the pressure, $R_{a}$ the gas constant\index{gas constant}
for air, $T$ the absolute \index{temperature}temperature, and $g$
the acceleration of \index{gravity}gravity.\index{acceleration!gravity|see {gravity}}\index{gravity}
Then 

\begin{equation}
w_{p}=\frac{dz}{dt}=-\frac{R_{d}T}{pg}\frac{dp}{dt}\label{eq:w-hydro}
\end{equation}
is the \index{rate of climb!integrated acceleration}rate of climb
in terms of geometric altitude. The random component of \index{pressure!uncertainty}uncertainty
in the pressure \index{pressure}measurements makes this \index{rate of climb!hydrostatic equation}estimate
too noisy to use directly, but it can be used to update the integrated
vertical acceleration from the INS. Define these variables: $w_{p}^{\prime}$
as provided by (\ref{eq:w-hydro}) and $w_{p}^{*}=\int_{0}^{t}a(t)dt$
where $a$ is the vertical acceleration (ACINS\sindex[var]{ACINS: vertical acceleration, INS})\index{variable in data files!ACINS}
as provided by the INS. Define $\Delta w_{p}=w_{p}^{\prime}-w_{p}^{*}$
and the same variable after low-pass filtering to be $\overline{\Delta w_{p}}$.
\index{filter!low pass}Then estimate the rate of climb of the aircraft\index{rate of climb}\index{rate of climb!new variable}
from $w_{p}=w_{p}^{*}+\overline{\Delta w_{p}}$. The resulting rate
of climb can then be integrated again, starting from a reference value
provided by the \index{navigation system!GPS}GPS, to obtain a \index{measurement!altitude!new}measure
of altitude that, except for the initial reference, is independent
of the GPS and is a useful representation of geometric altitude.\index{altitude of aircraft!geometric} 

Implementation uses a Butterworth filter\index{filter!Butterworth}
to find $\overline{\Delta w_{p}}$, as follows:
\begin{lyxcode}
DIF~<-~WPPRIME~-~WPSTAR~~\#\#~WPPRIME~from~hydrostatic~equation,~

~~~~~~~~~~~~~~~~~~~~~~~~~\#\#~WPSTAR~from~integrating~ACINS

DIF~<-~zoo::na.approx~(as.vector(DIF),~maxgap=1000,~na.rm~=~FALSE)

DIFW~<-~signal::filtfilt~(signal::butter(3,~2/tau),~DIF)

ROC~<-~WPSTAR~+~DIFW
\end{lyxcode}
\sindex[var]{ROC: rate of climb, INS new}where the second statement
removes missing values by interpolation\index{interpolation} and
is needed to avoid an error exception in the third statement. The
period of the filter\index{filter!cutoff frequency} cut-off is tau,
here selected after some exploration to be 300~s. The ``filtfilt()''
\index{function!Butterworth filter}function filters by averaging
two passes, forward and backward in time, to minimize phase-shift
distortion\index{filter!phase-shift} of the filtered signal.

<<ROC-plot, include=TRUE, fig.height=6, fig.scap="Comparison of a new variable representing rate of climb to the corresponding GPS-based measurement and the INS-provided measurement.", fig.cap='Comparison of a new variable representing rate of climb (ROC) to the GPS-based measurement (GGVSPD) and, in the bottom panel, the measurement provided by the INS (VSPD). The time covered in the bottom panel is a small segment from the time interval used for the top two panels.', cache=CACHE>>=

grid.newpage()
vp1 <- viewport(width=1, height=0.6, x=0.5, y=0.7)
vp2 <- viewport(width=1, height=0.4, x=0.5, y=0.2)
g1 <- ggplotWAC(
  with(D1[setRange(D1, 74000, 80000), ], 
       data.frame (Time, ROC, GGVSPD, "DROC"=ROC-GGVSPD, 'SKIP'=ROC*0)),
       col=c('blue', 'red'), lwd=c(1.4,0.8,1,0), lty=c(1,42),
       ylab=expression(paste('rate of climb [m ', s^-1, ']')),
       panels=2,
       labelL=c('ROC', 'GGVSPD'),
       labelP=c('variables', 'difference'),
       legend.position=c(0.8,0.94), theme.version=1
)
print (g1, vp=vp1)
g2 <- ggplotWAC(
  with(D1[setRange(D1, 75500, 75900), ],
       data.frame (Time, ROC, GGVSPD, VSPD)),
  ylab=expression(paste('rate of climb [m ', s^-1, ']')), theme.version=1
)
g2 <- g2 + theme(axis.title.y=element_text(size=12),
                 axis.text.y=element_text(size=12),
                 axis.text.x=element_text(size=12),
                 axis.title.x=element_text(size=12))
print (g2, vp=vp2)

meanROC <- with(D1[setRange(D1, 70000, 122000), ], mean (ROC-GGVSPD, na.rm=TRUE))
sdROC <- with(D1[setRange(D1, 70000, 122000), ], sd (ROC-GGVSPD, na.rm=TRUE))

@

The resulting \index{ROC=rate of climb}variable\sindex[var]{ROC: rate of climb, INS new}
``ROC'' is plotted in Fig.~\ref{fig:ROC-plot}\index{comparison!plot!rate of climb}
for comparison to the \index{navigation system!GPS}GPS-based variable
\sindex[var]{GGVSPD: rate of climb, GPS}GGVSPD. The bottom panel
also shows the \sindex[var]{VSPD: rate of climb, INS}variable ``VSPD''
that is provided directly by the \index{measurement!from INS!VSPD}INS.
The latter departs significantly from the other two variables, so
using ROC as input to the Kalman filter\index{Kalman filter}\index{filter!Kalman|see {Kalman filter}}
appears preferable to using VSPD. The mean difference ROC$-$GGVSPD
is \Sexpr{round(meanROC, 2)}, with standard deviation \Sexpr{round(sdROC, 2)}.
ROC appears to vary more smoothly than GGVSPD, so Kalman-filter updating
of ROC to GGVSPD may provide a better representation of aircraft rate-of-climb
than GGVSPD. This will be considered further in Sect.~\ref{sec:KF-variables},
where the measurements of wind produced by the Kalman filter are discussed.

\subsection{Retrieving IRU measurements by differentiation}

\subsubsection{Rotation rates\label{subsec:Rotations}}

\index{measurement!rotation rate!surrogate for}\index{measurement!from IRU!surrogate for}\index{inertial reference unit}It
is usually the case that the \index{measurement!from IRU}IRU variables
for body rotation rate\index{rotation rate of aircraft!measurement}
and body acceleration\index{acceleration!measurement} are not part
of the data archives.\index{data!standard archive} Indeed, for all
except recent projects and for all C-130 projects, these variables
from the IRU were not even recorded in the original data tapes. Therefore,
it is useful to be able to \index{retrieval!of measurements from IRU}retrieve
the accelerations and rotation rates from the measured variables present
in those archive \index{file!data}files. Differentiating the measured
angles\index{attitude angle!derivative}\index{state vector!derivative}
and velocity and then \index{reference frame!transformation}transforming
the derivatives to the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame,
with correction for the inertial \index{inertial corrections}effects
as was discussed for the derivative of the state vector in Sect.~\ref{subsec:deriv-array},
can provide retrieved values for the measurements. Then the Kalman
\index{Kalman filter}filter can proceed using these surrogates for
the original measurements.

For the rotation rates, the calculation proceeds as follows: (For
additional detail, see the code is in the R program chunk named find-rotation-correction.
)
\begin{enumerate}
\item Start with an analytical expression for the derivative\index{matrix!coordinate transformation!derivative}
of the \index{reference frame!transformation}transformation matrix
$R_{a}^{l}$ in terms of attitude angles\index{attitude angle} ($\theta,\,\phi,\,\psi$,
pitch, roll, and heading) and their time \index{state vector!derivative}derivatives
$\dot{\theta}$, $\dot{\phi}$, and $\dot{\psi}$.
\item Use differences between sequential \index{measurement!from INS}measurements
of the attitude angles to find values for these time \index{state vector!derivative}derivatives.
Use these with the analytical expressions for the derivatives from
step 1 to find the derivative of the \index{reference frame!transformation}transformation
matrix from the \index{reference frame!l-frame@\emph{l-}frame}\index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame
to the \emph{l-}frame. 
\item Calculate the (minor) correction for inertial \index{inertial corrections}effects
and \emph{add} it to the derivative matrix of the transformation from
the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame
to the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame.
(Normally this is subtracted during the forward transformation.)
\item Multiply the result by the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame-to-\emph{a-}frame
\index{reference frame!transformation}transformation \index{matrix!coordinate transformation}matrix.
The result is a skew-symmetric\index{matrix!skew-symmetric}\index{skew-symmetric matrix}
representation of the \index{measurement!from IRU!surrogate for}measured
rotation rates, $\boldsymbol{\Omega}_{ia}^{a}$, from which the surrogate
for the measurements can be extracted. 
\end{enumerate}
\vfill\eject

A mathematical expression of this algorithm, with $\Omega_{il}^{a}$
representing the corrections for inertial effects, $R_{l}^{a}$ the
inverse of $R_{a}^{l}$, $\Omega_{ie}^{l}$ the effect of the rotation
of the Earth, and $\Omega_{el}^{l}$ the effect of translation of
the \emph{l-}frame, is as follows:

\begin{equation}
\dot{R}_{a}^{l}=R_{a}^{l}\Omega_{la}^{a}=R_{a}^{l}(\Omega_{ia}^{a}-\Omega_{il}^{a})\label{eq:Rla-dot}
\end{equation}
\begin{equation}
\Omega_{ia}^{a}=R_{l}^{a}\dot{R}_{a}^{l}+\Omega_{il}^{a}\label{eq:Omega-iaa}
\end{equation}
\begin{eqnarray}
\Omega_{ia}^{a} & = & R_{l}^{a}\dot{R}_{a}^{l}+R_{l}^{a}(\Omega_{ie}^{l}+\Omega_{el}^{l})R_{a}^{l}\label{eq:Omega2-iaa}
\end{eqnarray}
(\citet{noureldin2013fundamentals}) where the left side of the last
equation is the desired skew-symmetric representation of the rotation
rate\index{measurement!rotation rate!retrieval of} and all components
of the right side are known, the time \index{state vector!derivative}derivative
from the differentiated measurements\index{measurement!differentiated}
and the last term because it is the same correction for inertial \index{inertial corrections}effects
used to find the attitude-angle derivatives\index{attitude angle!derivative}
from the measurements.

<<plot-retrieved-rotations, include=TRUE, fig.scap="Comparison of measured body rotation rates and those determined by differentiating the attitude angles, for a flight segment with various maneuvers.", fig.cap='Comparison of measured body rotation rates and those determined by differentiating the attitude angles. The red lines denoted as "delta*10" show the difference between the two rates after multiplication by 10 to make the small differences visible. The measurements are from DEEPWAVE flight 15, from a portion of the flight that included, chronologically in the plot, maneuvers with rapid pitch variations, a speed run with slow pitch variations, a maneuver with rapid changes in sideslip, and two full left-turn circles.', cache=CACHE>>=

suppressWarnings (print (    ## this avoids printed warning about attribute differences
ggplotWAC (with(D15[setRange(D15, 31200, 34630),], 
                data.frame(Time, BPITCHR, BP, 10*DBP, BROLLR, BR, 10*DBR,
                                BYAWR, BY, 10*DBY)),
           ylab=expression(paste('rotation rate [',degree,' ',s^-1,']')),
           lwd=c(0.7,0.5,1), lty=c(1,93,1),
           panels=3,
           labelL=c('measured', 'from differentiation', 'delta*10'),
           labelP=c('pitch', 'roll', 'yaw'),
           legend.position=c(0.5,0.96), theme.version=1
  )
))

# + geom_label(mapping=aes(x=D15$Time[getIndex(D15,31300)], y=0.2, label='maneuvers:'), 
#              show.legend=FALSE, color='black')
# layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
# op <- par (mar=c(2,4,1,1)+0.1)
# with(D15, plotWAC(data.frame(Time, BPITCHR, BP, 10*DBP), ylim=c(-2,2)))
# with(D15, plotWAC(data.frame(Time, BROLLR, BR, 10*DBR)))
# op <- par (mar=c(5,4,1,1)+0.1)
# with(D15, plotWAC(data.frame(Time, BYAWR, BY, 10*DBY), ylim=c(-2,2)))
# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
# rm(D15)

@

\index{rotation rate of aircraft!retrieved}Figure \index{DEEPWAVE research project}\ref{fig:plot-retrieved-rotations}\index{rotation rate of aircraft!surrogate for measurement}\index{measurement!from IRU!surrogate for}\index{comparison!plot!rotation rate}
shows the resulting \index{reference frame!transformation}transformed
\index{state vector!derivative}derivatives, as the green lines, and
the measured rotation rates as blue lines. They are mostly indistinguishable
in these plots, and statistically they are nearly identical as characterized
at the end of Sect.~\ref{subsec:Checking-the-rotation}, so the transformed
derivatives are valid estimates of the original rotation rates and
should be suitable for use in the Kalman filter discussed in the next
section.

\subsubsection{Accelerations\label{subsec:retrieving-accelerations}}

The retrieval of \index{measurement!from IRU!surrogate for}\index{measurement!from IRU!retrieval|see {-{}-, surrogate for}}accelerations\index{acceleration!retrieving}
is similar: Differentiate\index{measurement!differentiated} the \index{reference frame!l-frame@\emph{l-}frame}\index{velocity of aircraft!l-frame@\emph{l-}frame}\emph{l-}frame
velocity components \{\sindex[var]{VEW: ground speed eastward, INS}VEW,
\sindex[var]{VNS: ground speed northward, INS}VNS, \sindex[var]{VSPD: rate of climb, INS}VSPD\}
to find the \index{acceleration!l-frame@\emph{l-}frame}\emph{l-}frame
accelerations, apply the correction for inertial\index{inertial corrections}
effects with sign opposite to that used for the \emph{a-}frame-to-\emph{l-}frame
\index{reference frame!transformation}transformation, then transform
the results from the \emph{l-}frame to the \emph{a-}frame using the
inverse of the transformation \index{matrix!coordinate transformation}matrix
used for the opposite transformation. See the workflow document\index{workflow document}
for more detail, and refer to the code in the R chunk ``checking-accelerations''
for the R implementation. This is the same algorithm that was used
in Sect.~\ref{subsec:Checking-accelerations} to test the calibration
of the accelerometers.\index{calibration!accelerometer} 

\subsection{Simpler algorithms}

\subsubsection{Reasons for considering alternate algorithms}

\index{algorithm!simplier!correct pitch}\index{algorithm!simplier!correct heading}The
Kalman filter discussed in the next section will produce estimated
\index{error!attitude angle!Kalman filter estimate}errors for the
attitude angles,\index{attitude angle!errors} but it is possible
to calculate a simpler estimate with some assumptions about the source
of the error. One estimate was developed in \citet{Cooper2016ncartn},
Sect.~6.4; cf.~Eqs.~57. The intent of this section is to provide
alternative corrections for all three attitude angles on the basis
of relatively simple comparisons\index{comparison!INS to GPS} between
measurements available from the combination of an \index{navigation system!inertial}INS
and a GPS\index{navigation system!GPS} receiver. These corrections
can be applied to archived data\index{data!standard archive} and
so can lead to improvements in data collected in \index{processing from archives}past
as well as future projects, and they provide valuable comparisons
to the results that will be obtained from the Kalman filter. 

In the case of pitch and roll, the estimate of error relies on the
derivatives of the \index{error!velocity}errors in \index{ground speed}ground-speed
components and \index{error!position}position, which arise primarily
from errors in those angles.\index{attitude angle!errors} For heading,
the accelerations\index{acceleration!measurement}  determined by
differentiating the ground-speed components produced by the \index{measurement!from INS}INS
are compared to those determined by differentiating the \index{navigation system!GPS}GPS-based
\index{ground speed}ground-speed \index{measurement!from GPS}components.
This difference is dependent on the error\index{error!heading} in
heading\index{heading!error} because the accelerations are measured
in the \index{reference frame!aircraft|see {reference frame, \emph{a-}frame}}\emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame}
and transformation\index{reference frame!transformation} to an \index{reference frame!Earth|see {reference frame, \emph{l-}frame}}Earth-reference
frame (the \emph{l-}frame) involves the heading. An error in heading\index{error!heading}
results in a difference between the two sets of measured accelerations,
and that difference can be used to detect the error in heading. As
developed here, all corrections are applied to measurements after
acquisition, not during recording or initial data processing, to be
able to use algorithms that \index{smoothing}smooth measurements
over centered intervals. This also makes it possible to correct archived
data as long as the INS-provided and GPS-based measurements of ground
speed\index{ground speed} are available.

\subsubsection{Correcting the pitch and roll\label{sec:Correcting-the-pitch}}

An inertial system\index{navigation system!inertial} aligns during
initialization\index{navigation system!inertial!alignment} to detect
the local \index{vertical direction!local}vertical direction and
then calculates the new vertical direction as the aircraft moves (changing
the local vertical direction) and accelerates (which can cause gyros
to precess). Any misalignment present at initialization persists but
also will oscillate and will cause errors in roll\index{error!roll}\index{error!pitch}\index{error!mix pitch and roll}
and pitch to mix as the aircraft changes flight direction. For the
inertial system\index{navigation system!inertial} used on the \index{aircraft!NSF/NCAR GV}NSF/NCAR
GV, the standard uncertainty associated with this \index{measurement!from INS!uncertainty}measurement
is 0.05$^{\circ}$ in both roll and pitch (cf.~\citet{Cooper2016ncartn})
for flight duration of a few hours, and the error often increases
during the flight as heading\index{heading!error} errors and \index{error!accelerometer}accelerometer\index{calibration!accelerometer}
biases\index{accelerometer!bias}\index{accelerometer!bias} affect
the results. 

The work of \index{Schuler oscillation}Schuler (\citet{Schuler1923})
showed that coupling\index{coupling!strong} among some of these error
sources leads to limits on the growth of errors and to simultaneous
oscillations in some of the \index{measurement!error!Schuler oscillation}measurement
errors. In particular, an error\index{error!pitch!strong coupling}
in pitch leads to an error in horizontal acceleration\index{error!acceleration!strong coupling}
because gravity\index{gravity} is resolved to have an erroneous horizontal
component, and integration\index{integration!position error} of that
error in horizontal acceleration leads to a position error\index{error!position!strong coupling}
that grows so as to compensate for the false component of acceleration
arising from the original error\index{error!pitch} in pitch. However,
when the error in pitch is reduced to zero, errors in position and
velocity have been accumulated and those lead to growth of the error
in pitch in the direction opposite to the original error. The result
is a Schuler oscillation having a \index{Schuler oscillation!period}period
of $T_{Sch}=(R_{e}/g)^{0.5}/(2\pi)\approx5064\thinspace s$ or 84.4\,min,
where $R_{e}$ is the radius of the Earth\index{radius of curvature!Earth}
and $g$ the acceleration of gravity.\index{gravity} 

The existence of this coupling allows estimation of the pitch error\index{error!pitch!estimation}
if the error in horizontal acceleration can be measured. That is the
case if, in addition to the INS, there is a \index{navigation system!GPS}GPS
receiver that can provide high-quality \index{measurement!from GPS}measurements
of Earth-relative \index{velocity of aircraft!Earth-relative}velocity.
Modern GPS receivers, especially if they incorporate differential-GPS
corrections or ionospheric corrections, produce velocity measurements
that have remarkably low \index{measurement!from GPS!uncertainty}uncertainty,
often a few cm/s, so these can be considered a standard against which
to compare the corresponding INS-provided velocity. The difference
between ground-speed\index{ground speed} components from the two
systems thus determines the error\index{error!velocity} in the INS-provided
velocity and, after differentiation, the error\index{error!horizontal acceleration}
in horizontal acceleration.

If $a_{n}=a_{n}^{*}+\delta a_{n}$ where $a_{n}^{*}$ is the true
northward acceleration\index{acceleration!measurement}  of the aircraft\index{acceleration}
and $\delta a_{n}$ is the erroneous acceleration\index{acceleration!error}
that results from pitch and position errors, then the error in acceleration
(if the accelerometer error itself is negligible) is given by

\begin{equation}
\delta a_{n}^{(l)}=-g\delta\theta^{(l)}\,\,\,.\label{eq:delta-an}
\end{equation}
where $\delta\theta^{(l)}$ is the error\index{error!pitch!strong coupling}
in pitch. The superscripts $(l)$ denote that these pitch and acceleration
\index{error!acceleration!strong coupling}errors are those present
in the \index{reference frame!l-frame@\emph{l-}frame}\index{reference frame!ENU|see {reference frame, \emph{l-}frame}}
\emph{l-}frame. Then the error in \index{pitch!error}measured northward
acceleration provides a direct measure of the error in pitch:\\
\begin{equation}
\delta\theta^{(l)}=-\frac{1}{g}\frac{d(\delta v_{n}^{(l)})}{dt}\,\,\,.\label{eq:full-delta-pitch}
\end{equation}

Because $\delta v_{n}$ is measurable by comparison\index{comparison!INS to GPS}
to \index{pitch}measurements from a GPS\index{navigation system!GPS}
receiver, the error\index{error!pitch!l-frame@\emph{l-}frame} in
pitch can be found from (\ref{eq:full-delta-pitch}). The analogous
equation for the \emph{l-}frame error\index{error!roll!l-frame@\emph{l-}frame}
in roll, $\delta\phi^{(l)}$, is

\begin{eqnarray}
\delta\phi^{(l)} & = & \frac{1}{g}\frac{d(\delta v_{e}^{(l)})}{dt}\,\,\,.\label{eq:delta-phi}
\end{eqnarray}
The differentiated\index{measurement!differentiated} errors in the
components of the aircraft ground speed\index{ground speed} thus
provide estimates of the corrections to be applied to the \index{pitch!corrected}measurements
of pitch\index{pitch!correction!simplified} and \index{roll!correction!simplified}roll.
Because this correction relies on the observable effects of the errors
in velocity, it is not sensitive to the source of the error, whether
it arises from misalignment before flight, bias errors in the \index{inertial reference unit!bias}IRU
\index{gyro}gyros,\index{gyro!bias} or other sources except for
these exceptions: (i) an error in measured \index{error!acceleration!effect of}acceleration
from the accelerometers\index{accelerometer!error} that contributes
to the velocity \index{error!velocity}errors in a way not dependent
on the pitch or roll errors; and (ii) a minor dependence on error\index{error!heading!effect on pitch}
in heading that arises when the pitch and roll errors in the Earth-relative
\emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame} are
\index{reference frame!transformation}transformed to the reference
frame of the aircraft. The latter is negligible for normal heading
errors, but the former can cause increasing amplitude or drift of
the velocity errors. Plots of the observed errors in ground-speed\index{ground speed}
components, shown later in this document, suggest relatively small
changes in the amplitude of the Schuler \index{Schuler oscillation}oscillation
during most flights, as would be expected if the accelerometer \index{error!accelerometer}errors
make only small contributions to the velocity \index{error!velocity}errors.

An additional \index{reference frame!transformation}transformation
of angles\index{attitude angle} is needed to obtain the pitch\index{error!pitch!a-frame@\emph{a-}frame}
and roll \index{error!roll!a-frame@\emph{a-}frame}errors in \index{reference frame!a-frame@\emph{a-}frame}the
\emph{a-}frame, the normal reference frame for these angles. \footnote{The \emph{a-}frame differs from the $b$-frame or body frame\index{reference frame!body or b-frame}
often discussed in the inertial-navigation literature by having $\hat{x}$
and $\hat{y}$ axes interchanged\index{reference frame!a-frame@\emph{a-}frame!axes interchanged}
and the $\hat{z}$ axis reversed to be downward, as is conventional
for aircraft.}This calculation has been incorporated into a \index{function!CorrectPitch}function
``CorrectPitch ()'' that is part of the ``Ranadu'' \index{R language!package!Ranadu}\index{R language!package!Ranadu}\index{R language!package!Ranadu!CorrectPitch()}package.
Given a data.frame containing appropriate \index{measurement!required by CorrectPitch}measurements
from a flight (specifically, \sindex[var]{VNS: ground speed northward, INS}VNS,\index{variable in data files!VNS}
\sindex[var]{VEW: ground speed eastward, INS}VEW,\index{variable in data files!VEW}
\sindex[var]{GGVNS: ground speed northward, GPS}GGVNS,\index{variable in data files!GGVNS}
\sindex[var]{GGVEW: ground speed eastward, GPS}GGVEW,\index{variable in data files!GGVEW}
\sindex[var]{LAT: latitude, INS}LAT\index{variable in data files!LAT}
or \sindex[var]{LATC: latitude, GPS-corrected}LATC, \sindex[var]{GGALT: altitude, GPS, MSL}GGALT,\index{variable in data files!GGALT}
\sindex[var]{THDG: heading, INS}THDG,\index{variable in data files!THDG}
\sindex[var]{PITCH: pitch angle, INS}PITCH,\index{variable in data files!PITCH}
and \sindex[var]{ROLL: roll angle, INS}ROLL,\index{variable in data files!ROLL}
representing respectively the eastward and northward velocity components
of the aircraft as measured by the \index{navigation system!inertial}INS
and the GPS receiver, the \index{latitude}latitude, the altitude
from the \index{navigation system!GPS}GPS, and the heading, pitch,
and roll angle), the function returns estimates of the \index{error!pitch!Ranadu}\index{error!roll!Ranadu}errors
in pitch and roll. The workflow document\index{workflow document}
accompanying this technical note provides additional detail on the
algorithm\index{algorithm!simplier!correct pitch}\index{algorithm!simplier!correct heading}
used, and the R code is available in the file ``PitchCorrection.R''
\index{PitchCorrection.R}in the Ranadu\index{R language!package!Ranadu!repository}
package, available at this \index{repository!GitHub}\index{repository!Ranadu}\index{GitHub repository}URL:
\url{https://github.com/WilliamCooper/Ranadu.git}, subdirectory ``R''.

\subsubsection{Correcting the heading\label{subsec:CorrectHeading}}

\index{heading!correction!simplified}An algorithm related to that
used for correcting pitch is developed here for estimating the error\index{error!heading}
in heading. The basis for the correction is that an error in heading
results in an error in transformation of the \emph{a-}frame measurements
of acceleration\index{measurement!from IRU}\index{acceleration!measurement}\index{reference frame!transformation}
to the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}.
These \index{error!heading!estimate}errors can be detected by comparing
the actual acceleration of the aircraft\index{acceleration!from GPS}
(determined from \index{state vector!derivative}derivatives of the
\index{navigation system!GPS}GPS-based ground-speed\index{ground speed}
components, as in the preceding section) to the measurements of acceleration
after transformation to the \emph{l-}frame. \footnote{Additional small corrections arise from rotation of the Earth\index{Earth!rotation rate}
and rotation of the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
in an inertial\index{reference frame!inertial} frame, as discussed
later..} If those measurements\index{measurement!acceleration!surrogate}
are not available, they can be \index{acceleration!retrieving}retrieved
by differentiating the corresponding ground-speed components provided
by the INS, as discussed in Sect.~\ref{subsec:retrieving-accelerations}. 

The required \index{reference frame!transformation}transformation,
developed by \citet{Bulletin23} and others, \index{attitude angle!definition}involves
a rotation about the roll axis to level the wings, a rotation about
the pitch axis to level the longitudinal axis of the aircraft, and
a rotation about the vertical axis as required to point the aircraft
to the north. However, if there is an error\index{error!heading!equation for}
in the heading ($\delta\psi$) the last rotation will give final components
$a_{x,y,z}^{(l)}$ that have respective errors of $\delta a_{x}^{(l)}=a_{x}^{(l)}(1-\cos\delta\psi)-a_{y}^{(l)}\sin\delta\psi$,
$\delta a_{y}^{(l)}=a_{y}^{(l)}(1-\cos\delta\psi)+a_{x}^{(l)}\sin\delta\psi$,
and $\delta a_{z}^{(l)}=0$ or, for small angles,\\
\begin{align}
\left[\begin{array}{c}
\delta a_{x}^{(l)}\\
\delta a_{y}^{(l)}\\
\delta a_{z}^{(l)}
\end{array}\right] & =\left[\begin{array}{ccc}
0 & -\delta\psi & 0\\
\delta\psi & 0 & 0\\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{c}
a_{x}^{(l)}\\
a_{y}^{(l)}\\
a_{z}^{(l)}
\end{array}\right]\label{eq:heading-error-equation}\\
\delta a_{x}^{(l)} & =-a_{y}^{(l)}\delta\psi\label{eq:ax-error}\\
\delta a_{y}^{(l)} & =a_{x}^{(l)}\delta\psi\label{eq:ay-error}\\
\delta\psi & =\frac{a_{x}^{(l)}\delta a_{y}^{(l)}-a_{y}^{(l)}\delta a_{x}^{(l)}}{(a_{x}^{(l)})^{2}+(a_{y}^{(l)})^{2}}\label{eq:estimator-equation}
\end{align}
The last equation is obtained\footnote{If the error measure to be minimized is $\chi^{2}=(\delta a_{x}+a_{y}\delta\psi)^{2}+(\delta a_{y}-a_{x}\delta\psi)^{2}$,
differentiating $\chi^{2}$ with respect to $\delta\psi$ and setting
the result equal to zero gives (\ref{eq:estimator-equation}).} by minimizing the errors between the values of $\delta a_{i}^{(l)}$
given by (\ref{eq:ax-error}) and (\ref{eq:ay-error}) and the measured
error given by $(a_{i}^{*}-a_{i}^{(l)})$. This then gives an estimate
of the rotation $-\delta\psi$ that gives the best match between the
measured accelerations\index{acceleration!measurement}  and those
determined from the derivatives\index{velocity of aircraft!derivative}
of the \index{navigation system!GPS}GPS-based ground-speed\index{ground speed}
components. The resulting value of $\delta\psi$ from (\ref{eq:estimator-equation})
is then an estimate of the error\index{error!heading!estimate} in
heading. As in the pitch-correction algorithm, the acceleration\index{acceleration!determined from GPS}
vector $\mathbf{a^{*}}$ is determined by differentiating the \index{acceleration!from GPS}GPS-measured
velocity components using Savitzky-Golay polynomials, \index{derivative!Savitzky-Golay}\index{derivative!-{}-|see {-{}-,derivative}}\index{polynomial!Savitzky-Golay},
but with a 31\,s span to avoid excessive distortion in 3-min turns.
It was previously estimated that the \index{measurement!from GPS!uncertainty}uncertainty\index{uncertainty!GPS-based measurements}
in a measurement of acceleration from differentiation of \index{navigation system!GPS}GPS-based
measurements of velocity is not more than about 0.01\,m\,s$^{-1}$/$\tau$
where $\tau$ is the time over which the average is calculated. For
polynomials spanning 31 1\_Hz samples, the effective averaging time
is about 20\,s, leading to a minimum uncertainty of about 0.0005\,m\,s$^{-2}$.
Equation~(\ref{eq:estimator-equation}) indicates that, for an uncertainty\index{heading!uncertainty}
in the heading correction of 0.1$^{\circ}$ or about 0.002~radians,
the total horizontal acceleration should then be at least 0.0005/0.002=0.25~m\,s$^{-2}$.

Typical horizontal accelerations in turns exceed 4~m\,s$^{-2}$
in the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
but horizontal accelerations exceeding 1~m\,s$^{-2}$ are seldom
encountered outside of turns. Therefore, the algorithm\index{algorithm!simplier!correct heading}
developed here only provides a valid correction if there are regular
turns during the flight. In the following, heading corrections will
be calculated only when the horizontal acceleration exceeds 1~m\,s$^{-2}$
to avoid excessive noise and uncertainty. For a flight that transits
in a straight line from start to finish, attempts to use these estimates
are cannot be useful. Fortunately, in most research flights there
are many turns, e.g., as the aircraft flies back and forth over a
mountain range or flies fixed raster patterns for mapping. Each turn
can provide significant horizontal accelerations that give estimates
of the \index{heading}heading \index{error!heading}error, but these
estimates are only sporadic and must be linked by extrapolation to
obtain valid corrections spanning intervals without significant acceleration.
The heading\index{heading!correction} correction therefore has a
higher \index{heading!uncertainty}uncertainty than the pitch correction
and, unlike the pitch correction, depends on particular flight \index{maneuver!recommended}maneuvers
for successful operation. In addition, unlike the pitch error, the
heading error is not coupled\index{coupling!weak} to other errors
in ways that limit its growth, so determining an estimated correction
is important not only to provide improved measurements but also to
determine the estimated magnitude of the uncorrected error.

The \index{heading!correction!requirements}requirements for valid
results from this algorithm\index{algorithm!simplier!correct heading}
are as follows:
\begin{itemize}
\item The flight\index{flight path!recommendation} path must include \index{maneuver!recommended}maneuvers
that provide horizontal accelerations,\index{acceleration!horizontal!required magnitude}
usually turns of at least 30\,s duration \emph{in each direction.}
The reason is that it is difficult to correct for \index{error!timing}timing\index{measurement!time lag}
errors in the measurements of \index{heading}heading relative to
the measured ground-speed\index{ground speed} components from a \index{navigation system!GPS}GPS
receiver, and even a delay\index{time lag} of 50\,ms will, for a
turn rate corresponding to a three-minute turn through 360$^{\circ}$,
lead to a 0.05$^{\circ}$ false indication of a heading error\index{error!heading!effect of lag}.
However, the error reverses sign with the direction of the turn, so
averaging the results from left turns and from right turns will correct
for this false indication of a heading error. Course-reversal maneuvers\index{maneuver!reverse heading}
like ``90-270'' turns (90$^{\circ}$ one direction followed by 270$^{\circ}$
the other direction) provide good data for this algorithm, as do ``60-300-60''
teardrop turns that are a faster means of returning to the starting
point. If wind \index{wind!measurement!recommendation}measurements
are critical to the research, it may be useful to include patterns
like ``S'' turns periodically, with 30\,s turns in opposite directions,
to provide the needed accelerations.\index{acceleration!horizontal!needed magnitude} 
\item To the extent possible, sampled time series should be corrected for
sampling delays.\index{time lag} The most important such correction
is the timing of the heading \index{measurement!time lag}measurement
from the INS\index{navigation system!inertial!timing} relative to
the ground-speed\index{ground speed} measurements from the GPS\index{navigation system!GPS}
receiver. In the examples shown in this note, the differences between
different turn directions were minimized by shifting the heading forward
in time by 92\,ms. The averaging provided by the first item above
helps reduce \index{error!timing}errors from timing, but it is still
preferable to keep those errors small. Full-circle patterns\index{maneuver!circle}
flown in each turn direction provide a sensitive test of timing \index{error!timing}errors.
\end{itemize}
Many research flights and research data sets meet these requirements,
and where wind \index{wind!measurement!recommendation}measurement
is important appropriate flight maneuvers can be incorporated into
flight plans for future projects. The algorithm\index{algorithm!simplier!Ranadu reference}
implemented here, for which R code is available in the ``Ranadu''
\index{R language!package!Ranadu}package (cf.~\url{https://github.com/WilliamCooper/Ranadu.git},
\index{GitHub repository}\index{repository!Ranadu}directory ``R'',
\index{function!HeadingCorrection}script ``HeadingCorrection.R''),
includes these components:
\begin{enumerate}
\item \emph{Shift the timing of the heading measurement as needed to match
the GPS-receiver measurements of ground velocity.} \emph{ }
\item \emph{Differentiate the ground-speed measurements provided by a GPS
receiver,} \index{ground speed}\index{measurement!differentiated}using
third-order Savitzky-Golay polynomials\index{polynomial!Savitzky-Golay}
spanning 21\,s, to obtain reference measurements of horizontal accelerations\index{acceleration!from GPS}\index{acceleration!l-frame@\emph{l-}frame}
in the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame. 
\item \emph{Transform the accelerations measured by the INS in the a-}frame\emph{
to the l-}frame. \index{acceleration!a-frame@\emph{a-}frame} \index{reference frame!transformation}\index{navigation system!inertial}Filter\index{filter!Savitzky-Golay}
these results also using Savitzky-Golay polynomials of the same order
and span so that they are \index{smoothing}smoothed in the same way
as the ground-speed\index{ground speed} derivatives.
\item \emph{Use (\ref{eq:estimator-equation}) to obtain estimates of the
heading error $\delta\psi$ at each time.} \index{error!heading!estimate}However,
apply data restrictions to avoid cases of high uncertainty. The most
important restriction used here was to require that the total horizontal
acceleration\index{acceleration!horizontal!required magnitude} in
the \index{reference frame!l-frame@\emph{l-}frame}\index{acceleration!l-frame@\emph{l-}frame}\emph{l-}frame
be larger than $1$\,m\,s$^{-2}$. 
\item \emph{Use a search algorithm to identify flight segments with turns}
(specifically, magnitude of roll larger than 10$^{\circ}$)\index{algorithm!search for turns}
continuously except for possible gaps of 5\,min. Require that these
flight\index{flight segments!for heading correction} segments have
both right and left turns, with at least 25\,s of each.
\item \emph{For each such segment, calculate the mean correction} and its
standard \index{deviation, standard!heading correction}deviation
and the mean time for each turn direction.
\item \emph{Use cubic spline interpolation} to represent the heading correction\index{spline!cubic}\index{interpolation!spline}
over the course of the flight. 
\item \emph{Subtract the result given by this interpolation from the measured
heading to obtain the corrected heading.}
\end{enumerate}

\subsubsection{Results from the simple correction algorithms}

Results will be presented later in comparison to the results from
the Kalman filter. See Figs.~\ref{fig:a-frame-errors} and \ref{fig:plot-Kalman-heading}. 

\subsection{Angle of attack}

As described in \citet{Cooper2016ncartn}, the standard empirical
represention of angle of attack\index{angle of attack!empirical representation}
has been

\begin{equation}
\alpha=c_{0}+\frac{\Delta p_{\alpha}}{q}\left(c_{1}+c_{2}M\right)\label{eq:old-AKRD}
\end{equation}
where $\Delta p_{\alpha}$ is the pressure difference \index{measurement!pressure difference!between radome ports}measured
on the radome between top and bottom \index{radome!pressure ports}ports,
$q$ is the dynamic pressure\index{pressure!dynamic} and $M$ is
the Mach\index{Mach number} number calculated from the measurements\index{pressure!dynamic}\index{pressure!ambient}
of dynamic and static pressure\index{pressure!static}\index{pressure!ambient}
before static-defect\index{static defect} corrections are applied.
The coefficients\index{angle of attack!empirical representation}
were found by \index{fit!angle of attack}fitting that formula to
a \index{angle of attack!empirical representation!reference for calibration}reference
value $\alpha^{*}$ that assumes there is zero vertical wind:\\
\begin{equation}
\alpha^{*}=\theta-\frac{w_{p}}{V}\label{eq:AOAREF}
\end{equation}
where $\theta$ is the pitch angle, $w_{p}$ the rate of climb of
the aircraft\index{rate of climb}\index{rate of climb} and $V$
the airspeed.\index{airspeed}

An alternate approach is developed here. The reference value as given
by (\ref{eq:AOAREF}) is split into two components, $\alpha^{*}=\alpha_{f}^{*}+\alpha_{s}^{*}$
that result from applying a Butterworth low-pass filter\index{filter!Butterworth}
 to $\alpha^{*}$ (in the code, the variable AOAREF) to obtain $\alpha_{s}^{*}$
and then finding $\alpha_{f}^{*}$ from $\alpha_{f}^{*}=\alpha^{*}-\alpha_{s}^{*}$,
where the $f$ and $s$ subscripts represent the high-pass and low-pass
components after filtering. These components are then represented
by \index{fit!angle of attack!new}separate fits:

\begin{equation}
\alpha_{f}=c_{1}\left(\frac{\Delta p_{\alpha}}{q}\right)_{f}=c_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{f}\label{eq:alpha-fast}
\end{equation}
\begin{equation}
\alpha_{s}=d_{0}+d_{1}\left(\frac{\Delta p_{\alpha}}{q}\right)_{s}+d_{2}q_{s}=d_{0}+d_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{s}+d_{2}\mathrm{\{QCF\}}_{s}\label{eq:alpha-slow}
\end{equation}
 where the second equalities in each line reference the standard variable
names used in \index{netCDF}netCDF archives\index{data!standard archive}
to represent the corresponding quantities in the first equality. More
complicated representations were tested in both cases, but these appear
to provide adequate fits without additional terms.

<<read-sensitivity-coef, cache=CACHE>>=

# load (file='~/RStudio/Reprocessing/AKRD-fit-coef.Rdata')
cffn <- 19.70547
cff <- 21.481
cfs <- c(4.525341674, 19.933222011, -0.001960992)

@

This approach has a substantial advantage\index{angle of attack!empirical representation!new approach}
over the approach in standard use. The important sensitivity to fluctuations
is not compromised by efforts to represent the slowly varying zero
level for angle of attack, and the slowly varying offset can be represented
by more complex equations without having those added factors influence
the high-frequency response. The result is an empirical representation
that is appropriate for all recent GV\index{aircraft!NSF/NCAR GV}
projects and that does not need to be changed for each project, as
has been the case for many recent projects that use the standard representation. 

To find the coefficients\index{angle of attack!empirical representation}
in (\ref{eq:alpha-fast}) and (\ref{eq:alpha-slow}), a composite
data set was constructed from most flights from three recent projects,
ORCAS, CSET, and \index{DEEPWAVE research project}DEEPWAVE.\footnote{For descriptions of these projects, see the EOL web site at \href{https://www.eol.ucar.edu/recent-projects-and-deployments}{this URL}.}
A full description of how these coefficients were determined is contained
in \index{angle of attack!empirical representation!standard reference}\href{https://drive.google.com/open?id=0B1kIUH45ca5AUmR1UkNUUVdBRFE}{this document},
and the coefficients from that analysis are used here. They are $c_{1}=$\Sexpr{round(cff,4)}
and \{$d$\} = \{\Sexpr{round(cfs[1], 4)}, \Sexpr{round(cfs[2], 4)},
\Sexpr{round(cfs[3], 6)}\}. Then the variables entering the fits
in (\ref{eq:alpha-fast}) and (\ref{eq:alpha-slow}) were obtained
by using a low-pass Butterworth forward-and-backward filter\index{filter!Butterworth}
 to find the slowly varying components $(\Delta p_{\alpha}/q)_{s}$
and $q_{s}$, and the first was subtracted from the unfiltered variable
to find $(\Delta p_{\alpha}/q)_{f}$. The new angle-of-attack variable
was then calculated from $\alpha=\alpha_{f}+\alpha_{s}$.

This calculation gave much less variation from project to project
and within projects and seemed to provide a standard representation
applicable to all recent GV\index{aircraft!NSF/NCAR GV} projects
since a change was made to the radome. 

\section{The Kalman filter\label{sec:The-Kalman-filter}}

\subsection{The algorithm used}

\index{overview!Kalman filter algorithm}\index{Kalman filter}Section
\ref{subsec:Mechanization} verified that a valid representation of
the derivatives\index{state vector!derivative} of the state vector
is available.\index{algorithm!Kalman filter}\index{Kalman filter!algorithm}
An error-state Kalman\index{Kalman filter!error-state} filter that
uses that derivative function is described in this section. The computational
algorithm has these components: 

\begin{enumerate}
\item The first step is to initialize an error-state vector\index{error-state vector}
$\delta\mathbf{x}$ from initial \index{measurement!from INS}\index{measurement!from GPS}measurements
of the differences between the INS and \index{navigation system!GPS}GPS-based
values of position and velocity. Other errors in components of the
state vector are unknown at the start of the integration and so will
be initialized as zero. The 15-component vector used here contains
the respective errors in \index{latitude}latitude, \index{longitude}longitude,
altitude\index{altitude of aircraft}, eastward ground speed, northward
ground speed, rate of climb, pitch, roll, heading, pitch-axis rotation
rate, roll-axis rotation rate, yaw-axis rotation rate, lateral\index{acceleration!lateral}
component of acceleration,\index{acceleration!measurement}  longitudinal
component of acceleration, and normal component of acceleration. The
\index{error!rotation rate}rotation-rate errors and acceleration
\index{error!acceleration}errors\index{accelerometer!bias}\index{gyro!bias}
in this \index{error-state vector}error-state vector are biases;
random errors enter instead through the noise-covariance matrix\index{matrix!!noise covariance}\index{matrix!noise}
$\mathbf{Q}$ below.
\item The covariance\index{matrix!covariance} matrix\index{matrix!covariance}\index{Kalman filter!matrices}
$\mathbf{V}$ characterizing the errors in the error-state vector\index{error-state vector}
is also needed. This is here initialized to have rather large components
corresponding to the \index{navigation system!inertial}INS-provided
measurements because it is expected that the GPS\index{navigation system!GPS}
\index{measurement!from GPS!uncertainty}measurements will have much
lower uncertainty\index{uncertainty!GPS-based measurements} than
these INS-provided components and that will constrain the covariance
matrix during the calculation. $\mathbf{V}$ is initialized as a 15$\times$15
diagonal matrix where the diagonal elements are the squares of these
values: \{2000/$R_{m}$, 2000/($R_{n}$cos$\lambda$), 500, 2, 2,
2, 0.3$^{\circ}$, 0.3$^{\circ}$, 1$^{\circ}$, 0.005$^{\circ}s^{-1}$,
0.005$^{\circ}s^{-1}$, 0.005$^{\circ}s^{-1}$, 0.0005, 0.0005, 0.0005\}.
All entries are in SI units except those where units are listed as
degrees, and those cases are converted to radians before use. The
variables $R_{m}$ and $R_{n}$ are appropriate radii of the \index{radius of curvature!Earth}Earth,
as discussed in Sect.~\ref{subsec:deriv-array}, and $\lambda$ is
the \index{latitude}latitude. The initial values assigned to this
covariance matrix have little effect on the results because the covariance
matrix is updated during the calculation based on the other error
estimates.
\item The \index{function!derivative}function ``STMFV'' was verified
above and so provides appropriate \index{state vector!derivative}derivatives
of the state vector, for the first nine components. The error-state
\index{error-state vector}vector, however, also includes errors in
the additional six components representing the \index{error!rotation rate}rotation-rate
and \index{error!acceleration}acceleration vectors. The derivatives
of the first nine components depend on the derivatives of the additional
six components, so all 15 elements in the error-state vector must
be considered. For an error-state Kalman\index{Kalman filter!error-state}
filter, the forward propagation of the error state\index{error-state vector!propagation}
can be found from the Jacobian\index{Jacobian!of derivative function}
$\mathbf{J}(\mathbf{x})$ of that derivative function of the state
vector, so the \index{matrix!state transition}error-state transition
\index{Kalman filter!matrices}matrix $\mathbf{T}$ is the sum of
that Jacobian (multiplied by the time \index{time step}step) and
the 15-element diagonal matrix:\\
\begin{equation}
\delta\mathbf{x}_{k}=\mathbf{T}\thinspace\delta\mathbf{x}_{k-1}=(\mathbf{J}(\mathbf{x}_{k-1})\thinspace\Delta t+\mathbf{I})\thinspace\delta\mathbf{x}_{k-1}\label{eq:error-state-transition}
\end{equation}
The derivative\index{state vector!derivative!extension} function\index{function!derivative!extension}
must be extended for this use beyond that used for mechanization,
because the dependence of the first nine components on the additional
six components is needed for the complete Jacobian. Furthermore, the
dependence of the additional six derivatives on each other and the
first nine components is needed. This is added as follows:
\begin{enumerate}
\item Expanding the state-vector $\mathbf{x}$ to include all 15 components
naturally includes the effect of the added six components on the first
nine components because the derivative\index{state vector!derivative}
calculation outlined earlier already includes these dependencies.
The corresponding components of the Jacobian will therefore be included
naturally.
\item The dependence that is not included in that case is the dependence
of the \index{state vector!derivative!extension}derivatives of the
last six components on the values of the first nine. There is no such
dependence, though, because these are direct measurements in an inertial
frame\index{reference frame!inertial} and so are not affected by
other components of the state vector. The changes in the errors in
acceleration or rotation rate do not depend analytically on any other
part of the \index{error-state vector}error-state vector, so the
terms in the Jacobian\index{Jacobian!of derivative function} involving
these components will be zero. This arises naturally if the state
vector is expanded to 15 components and then used to calculate the
\index{Jacobian!numerical evaluation}Jacobian\index{function!Jacobian}
numerically. There will be new terms in the Jacobian describing how,
for example, a derivative of a velocity component changes with the
change in a component of acceleration, but not the reverse component
describing how the derivative of a component of acceleration\index{acceleration!measurement}
 changes with the change in velocity component. The highest 6$\times$6
submatrix in the Jacobian will have 0 for all terms. 
\item Implementation then involves having the \index{state vector!derivative}derivative
function\index{function!derivative} return a 15-component derivative
where the first nine components are as before and the last six components
are zero. Using that derivative function to find the Jacobian\index{Jacobian!of derivative function}
will then include terms that involve all the components and so describe
the full interdependence of the errors. For example, errors in the
rotation-rate components will affect all of the error terms for the
first nine components and so will enter most of the Jacobian terms
involving the derivatives of the first nine components with respect
to the rotation-rate components.
\end{enumerate}
\item The noise-covariance matrix\index{matrix!noise}\index{matrix!noise}
$\mathbf{Q}$ \index{Kalman filter!matrices}represents the estimated
\index{measurement!from INS!noise}noise in the \index{navigation system!inertial}INS
forward integration. The results vary significantly with different
choices for these values, and the choices made here are the result
of \index{tuning}tuning to find a set of values giving reasonable
results. The 15 values used for the diagonal components of this matrix
are the squares of the following: \{$a$/$R_{m}$, $a$/$(R_{n}\cos\lambda$),
$a$, 0.02~m\,s$^{-1}$, 0.02~m\,s$^{-1}$,, 0.05~m\,s$^{-1}$,,
0.01$^{\circ}$, 0.01$^{\circ}$, 0.01$^{\circ}$, 0.02$^{\circ}$/s,
0.02$^{\circ}$/s, 0.02$^{\circ}$/s, 0.00005\,m\,s$^{-2}$, 0.00005\,m\,s$^{-2}$,
0.00005\,m\,s$^{-2}$\} where $a$ is 10~m. Cases with units of
degrees are converted to radians before use. These values are used
with a 5-s time \index{time step}step, and they may need adjustment
if a different time step is used. To estimate these values, a high-pass
filter of high-rate measurements for a straight-and-level flight segment
was used to find the standard deviation\index{deviation, standard!measurements}
of such signals applicable at a 0.2~Hz sample rate, corresponding
to the 5-s time step used in this particular implementation of the
Kalman filter. For positions, this approach indicated that appropriate
values would be about 10\% of the listed values, but the listed values
were used instead because the smaller values tended to result in numerical
singularities\index{singularity} in the inversion\index{inversion!computational singularity}
required in step 6 below. This change did not otherwise result in
any significant change in the solution. In the case of accelerations,\index{accelerometer!noise}
the variance \index{spectrum!variance}spectra for these measurements
show characteristics of a \index{variance spectrum!noise}noise limit
at an amplitude of about 0.001~m\,s$^{-2}$. However, this appears
to arise from the \index{resolution!data recording}resolution with
which the variables were recorded, so the forward integration\index{integration!INS}
in the INS may use less noisy measurements. When a noise estimate
this large was used in the following calculations, substantial errors
in \index{error!pitch!dependence on noise}pitch and \index{error!roll}roll
were predicted that seemed unrealistic and were reduced substantially
if these noise estimates were reduced. The very low values listed
above for these elements of the noise-covariance\index{matrix!noise}
matrix correspond to assuming that the noise affecting the accelerometers\index{accelerometer!noise}
is negligible, and indeed setting these values to zero gives almost
the same result as that obtained by using these small values. The
Kalman filter does estimate non-zero bias\index{accelerometer!bias}
in accelerations during the integration, so very small noise estimates
still permit compensation for errors in the \index{error!accelerometer}accelerometers.\index{accelerometer!error}
 All the values listed may be higher than the true noise, but at
least they should be upper limits. 
\item Once $\mathbf{T}$ and $\mathbf{Q}$ are specified, the covariance
$\mathbf{V}$ \index{matrix!covariance}matrix\index{matrix!covariance}
can be updated each \index{time step}time step via\footnote{Matrix multiplication is indicated by adjacent matrices separated
by spaces. The corresponding symbol in R is '\%{*}\%' but transposition
is sometimes required because matrices are represented in R in column-major
format.}\\
\begin{equation}
\mathbf{V}=\mathbf{T}\thinspace\mathbf{V}\thinspace\mathbf{T}^{T}+\mathbf{Q}\label{eq:covariance-update}
\end{equation}
\item The \index{Kalman filter!matrices}Kalman gain\index{matrix!Kalman gain}
is then given by\\
\begin{equation}
\mathbf{K}=\mathbf{V\thinspace}\mathbf{H}^{T}\mathbf{\left\{ \mathbf{H}\thinspace\mathbf{V}\thinspace\mathbf{H}^{T}+\mathbf{R}\right\} ^{-1}}\label{eq:kalman-gain}
\end{equation}
where $\mathbf{H}$ is a 15$\times$6 diagonal matrix\index{Kalman filter!matrices}
representing how the six measured differences\index{navigation system!GPS}
(GPS-INS) correspond to the \index{error-state vector}error-state
vector. $\mathbf{R}$ is the measurement-noise covariance matrix\index{matrix!measurement noise}\index{matrix!measurement noise}
representing the \index{measurement!from GPS!noise}noise in the GPS-based
measurements, a 6$\times$6 matrix having diagonal elements that are
the squares of these components: \{0.5/$R_{m}$, 0.5/($R_{n}\cos\lambda$),
0.5, 0.02, 0.02, 0.05\} in SI units. These were based on the same
analysis used to determine estimates for the components of $\mathbf{Q}$
and represent very high confidence in the measurements from the GPS
receiver. The particular time interval was one where \href{http://www.omnistar.com/}{OmniSTAR corrections}\index{OmniSTAR corrections}
were available, so this represents the best performance that can be
expected from the GPS receiver. An additional seventh component, based
on an estimate of the heading \index{error!heading!estimate}error
determined from (\ref{eq:estimator-equation}) above, will be discussed
below and added to the matrices so that $\mathbf{H}$ will be 15$\times$7
and $\mathbf{R}$ will be 7$\times$7.\footnote{Three additional measurements were explored for inclusion, the three
measurements of acceleration determined by differentiating the measurements
of velocity components from the GPS receiver. These complicate the
tuning and did not appear useful, so they will not be discussed in
this technical note. Their inclusion in the solution appears to be
redundant.} 
\item Define \textbf{$\delta\mathbf{z}$ }as the set of six measurements
consisting of the differences between \index{navigation system!GPS}GPS
and \index{navigation system!inertial}INS-provided \index{measurement!used in Kalman filter}position
and velocity. Because the GPS antenna\index{navigation system!GPS!antenna location}
on the \index{aircraft!NSF/NCAR GV}GV is located $L_{G}=4.3$~m
behind the INS, a small correction is made to the velocity differences
to account for the \index{correction!for aircraft rotation}rotation
rate of the aircraft:\index{rotation rate of aircraft}\index{velocity of aircraft!correction for GPS location}\\
\[
\delta z_{4}=v_{e}-v_{e}^{(G)}-L_{g}\dot{\psi}\cos\psi
\]
\begin{equation}
\delta z_{5}=v_{n}-v_{n}^{(G)}+L_{G}\dot{\psi}\sin\psi\label{eq:GPScorrection}
\end{equation}
\[
\delta z_{6}=v_{u}-v_{u}^{(G)}-L_{G}\dot{\theta}\cos\phi
\]
where \{$v_{e},\,v_{n},\,v_{u}$\} are the eastward, northward, and
upward components of the aircraft \index{velocity of aircraft}velocity
as \index{velocity of aircraft!correction to}measured by the INS,
the same symbols with superscript (G) are the corresponding measurements
from the GPS\index{navigation system!GPS} receiver, $\psi$ is the
heading, $\phi$ the roll angle, and $\dot{\psi}$ and $\dot{\theta}$
are the respective time \index{state vector!derivative}derivatives
of the heading and pitch angles.\index{attitude angle} Similar corrections
are made to the horizontal position differences. The error-state vector\index{error-state vector}
is then further updated as follows:\\
\begin{equation}
\delta\mathbf{x}_{k}\leftarrow\delta\mathbf{x}_{k}+\mathbf{K\{\delta}\mathbf{z}-\mathbf{H}\delta\mathbf{x}\}\label{eq:post-update-sv}
\end{equation}
\item Finally, the covariance matrix\index{matrix!covariance}\index{matrix!covariance}
is updated further according to\\
\begin{equation}
\mathbf{V}\leftarrow\mathbf{V}-\mathbf{K}\thinspace\mathbf{H}\thinspace\mathbf{V}\label{eq:post-cv-update}
\end{equation}
\end{enumerate}
To apply these equations, it is not necessary to use a high-rate data
\index{file!data}file and update at high rate because it is expected
that the \index{smoothing}\index{error!smoothing}errors vary slowly.
However, turns and other maneuvers can introduce spurious effects
if time delays are not adjusted well. For these reasons, a 1-Hz data
file will be used for the following example, and the measurements
of components of the velocity and of the attitude angles\index{attitude angle!lag}
as well as the rotation rates and accelerations\index{acceleration!measurement}
 will be shifted in time where needed and then smoothed before applying
the Kalman filter. DEEPWAVE\index{DEEPWAVE research project} flight
16 (4 July 2014) was selected, and the measurements were filtered
with 11-s smoothing of accelerations\index{acceleration!smoothing}
and 301-s smoothing of measured velocity components and attitude angles.
A 5~s update interval was used for the example that follows.

The file ``KalmanFilterTechNote.Rnw'' loads R ``chunks'' from
a directory named ``chunks''\index{R language!program chunks} when
it runs, so this directory is archived along with the file.\index{archive!for this document}
The reason is that a separate R \index{R language!interactive processing script}script\index{R language!interactive processing script}
designed to support interactive runs, with specification of the archive
\index{file!data}file\index{data!standard archive} to be used and
with options to change time shifts and calibrations but which omits
generation of the text and plots in this technical note, can use those
same chunks. That script is called ``KalmanFilter.R'', and the workflow
\index{workflow document}document includes detailed instructions\index{instructions!R script}\index{R language!interactive processing script!instructions}
for its use.


\subsection{Detecting the error in heading\label{subsec:heading-error}}

\index{error!heading}\index{heading!error}\index{heading}Most of
the components of the \index{state vector}state vector have good
feedback from \index{navigation system!GPS}GPS-based measurements,
but an exception is the measurement of heading. For position and velocity,
there is direct correspondence between INS-provided and \index{measurement!from GPS}\index{measurement!from INS}GPS-based
measurements. For pitch and roll, there is strong coupling\index{coupling!strong}
to \index{strong coupling|see {coupling, strong}}errors in the eastward
and northward components of aircraft velocity.\index{velocity of aircraft}
However, the coupling of INS-provided heading\index{heading!weak coupling}
to GPS-based measurements is not a case of strong coupling (to which
the Schuler oscillation\index{Schuler oscillation} applies), and
it is less effective to update via measurements from the GPS receiver.
To improve the constraint on heading, another approach was tried that
estimates a the error in heading by using derivatives of the measurements
provided by the GPS receiver. The basis for this approach is related
to that discussed in Sect.~\ref{subsec:CorrectHeading}, in particular
via (\ref{eq:estimator-equation}) which estimates the error in \index{heading!error!estimate from acceleration}heading
by comparing the directions of the two accelerations that arise in
the first case from \index{reference frame!transformation}transforming
the \index{inertial reference unit}IRU-measured accelerations to
the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}\index{acceleration!l-frame@\emph{l-}frame}
and in the second by differentiating the \index{navigation system!GPS}GPS-based
components of the aircraft velocity. The latter direction then provides
a \index{heading!error!reference}reference toward which the former
can be updated. Unfortunately, the measured accelerations\index{acceleration!measurement}
 are too noisy for this to be effective except during turns, so updating
to this reference value must consider the variance in the estimated
error. 

 Most of the evidence from flights that have been examined suggests
that the heading\index{heading!error} error\index{error!heading!comparison of INSs}
is small and changes little during the flight. (The evidence comes
primarily from comparisons\index{comparison!independent INS units}
among independent inertial navigation\index{navigation system!inertial}
systems, as discussed in \citet{Cooper2016ncartn}.) However, the
Kalman filter often leads to estimates of heading error that are 0.2$^{\circ}$
or more, accompanied by large variances that indicate substantial
\index{heading!correction!uncertainty}uncertainty in the estimates.
The heading error\index{error!heading!need for turns} is constrained
well only during turns, when there are significant horizontal accelerations.
With strong accelerations, the direction of the acceleration is determined
well and can be used as an additional error\index{error!heading!additional constraint}
term in the Kalman filter. Although inclusion of this term is redundant
in theory because the filter already determines optimal corrections
to minimize the measurement errors, specific inclusion of this term
did lead to apparent improvement in performance, particularly the
reduction of noise in the estimated heading error and smaller excursions
from the mean correction.

Because significant horizontal accelerations\index{acceleration!lag}
occur mostly in turns when the heading angle is changing rapidly,
it is very important to have correct relative timing\index{time lag}
between the INS-provided measurement\index{measurement!time lag}
of heading and the GPS-based\index{navigation system!GPS} measurement
of velocity.\footnote{As an illustration, a 50-ms delay\index{time lag} in heading during
a 3-min turn causes a shift in heading relative to the correct time
of 0.1$^{\circ}$, so adjustment to at least this uncertainty is desirable. } The GPS measurements\index{measurement!from GPS} are assigned correct
times by the GPS receiver and so provide a standard clock against
which to compare other measurements.\footnote{It appears that the relative timing between the IRU and the \index{navigation system!GPS}GPS
receiver can change enough during some flights to introduce additional
\index{error!timing}errors that are sometimes detectable. This warrants
further study.} If the \index{navigation system!GPS}GPS-vs-INS time shift\index{time lag!GPS vs. INS}
is not removed, a bias will be introduced into the heading correction
that varies with turn direction. Therefore the following procedure
was followed to remove this time shift:
\begin{enumerate}
\item Differentiate\index{measurement!differentiated} the \index{navigation system!GPS}GPS-based
\index{measurement!from GPS}measurements to obtain $\dot{v}_{e}$
and $\dot{v}_{n}$.
\item Transform\index{reference frame!transformation} the unshifted body
accelerations\index{acceleration!measurement}  to the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
with rotation-rate \index{inertial corrections}corrections, to obtain
the eastward and northward components of acceleration ($a_{e}^{(l)}$,
$a_{n}^{(l)}$) in the local-level frame (\emph{l-}frame). 
\item Find the heading\index{heading!correction} correction for unshifted
measurements by calculating $\delta\psi$ from (\ref{eq:estimator-equation}).
\item Calculate the running-standard \index{deviation, standard!heading error}deviation
of $\delta\psi$ spanning 30 seconds. Select the subset of $\delta\psi$
for which that standard deviation is less than 0.2$^{\circ}$.
\item Fit\index{fit!time shift} the subset to find the slope $b$ in the
relationship $\delta\psi=a+b\thinspace\tan\phi$ where $\phi$ is
the roll angle. The rate of turn $R$ is related to the roll angle
$\phi$ according to the relationship $R=g\thinspace\tan\phi/V$ where
$V$ is the airspeed\index{airspeed}, so $\tan\phi=RV/g$ and $\delta\psi=a+bRV/g$.
A time delay\index{time lag} of $\delta t$ produces a heading \index{error!heading!effect of lag}error
of $-R\delta t$, so $-R\delta t=a+bRV/g$ and the time shift can
be estimated from\\
\begin{equation}
\delta t=-b\frac{V}{g}\,\,\,\,.\label{eq:deltaT}
\end{equation}
For example, for DEEPWAVE\index{DEEPWAVE research project} flight
16, $b=0.2146^{\circ}$s$^{-1}$ = 0.003745\,rad\,s$^{-1}$ and
$V\simeq240$\,m\,s$^{-1}$, so (with g=9.8\,m\,s$^{-2}$) $\delta t=$-0.092~s.
The negative sign indicates that the INS-provided measurement of heading
appears to be shifted backward (earlier) in time by 92\,ms relative
to the GPS-based \index{navigation system!GPS}measurements of aircraft
velocity.\index{time lag!GPS vs. INS} The standard error from the
fit indicates that this shift was determined with an uncertainty of
about 3\,ms, so this is a very sensitive way to determine the time
shift. Note that the result is not influenced by a real error in heading.
\item Apply this time shift to the \index{measurement!time lag}measurements
of ground speed from the GPS (\sindex[var]{GGVEW: ground speed eastward, GPS}GGVEW
and \sindex[var]{GGVNS: ground speed northward, GPS}GGVNS), in this
case shifting them backward (earlier) in time by 92~ms while leaving
the heading unshifted.\footnote{The reason that it is preferable to shift GGVEW and GGVNS rather than
THDG is that it is common in data archive for heading to already be
shifted. In the case discussed here, heading was already shifted by
$-80$~ms. However, this was done after processing by the INS, so
\index{measurement!time lag}measurements like VEW and VNS have been
determined with the heading as used internally by the INS, not as
shifted during subsequent processing. The feedback provided by the
Kalman filter then relies on the heading before shifting, and subsequent
shifting of the heading has no effect on those measurements. It does
affect the recalculated transformation from \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame
to \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
so there would be an inconsistency between (\ref{eq:estimator-equation})
and other estimates of the heading error arising from the Kalman filter.} For a data \index{file!data}file containing \index{measurement!time lag}measurements
at 1~Hz, this requires creating an interpolated\index{interpolation!for time shift}
high-rate vector of measurements, shifting that vector, and then extracting
a shifted 1-Hz vector from the shifted measurements. The Ranadu \index{function!ShiftInTime}function
ShiftInTime() accomplishes this by interpolating to a 125-Hz variable.
\end{enumerate}
After an appropriate time shift is introduced, (\ref{eq:estimator-equation})
is an appropriate measurement of \index{heading!estimated error}heading
\index{error!heading!estimate}error to include in the \index{error-measurement vector}error-measurement
vector $\delta\mathbf{z}$. Here, that is accomplished by adding a
seventh component to the measurement vector and a seventh row to the
observation \index{matrix!observation!added row}matrix $\mathbf{H}$,
where a matrix element 1 then appears in row 7, column 9, to associate
this measurement with the heading angle.  In normal straight flight,
the standard deviation\index{deviation, standard!heading error} in
the estimate obtained from (\ref{eq:estimator-equation}) is around
15$^{\circ}$, but in turns this standard deviation reduces to typically
about 0.15$^{\circ}$. This has two important consequences. First,
flights without turns or other sources of horizontal acceleration\index{acceleration!horizontal!required magnitude}
will lack the information for adjusting the heading. so in flights
where good wind measurements\index{wind!measurement!recommendation}
are important regular turns\index{flight path!recommendation} should
be part of the flight plans. Second, when the GPS-based estimate of
the heading error\index{error!heading} is used, an appropriate variance
should be assigned to prevent excessive noise from affecting the result
from the Kalman filter. It appears best to suppress updating to the
GPS result entirely for this seventh term except when horizontal accelerations
are significant (more than 1\,m\,s$^{-2}$, which is common only
in turns where accelerations are often about 3~m\,s$^{-2}$), and
the case to be shown used this suppression of updating. Then the running
variance in the estimate of heading error can be used as the appropriate
factor to include in the noise \index{matrix!noise!expansion of}matrix
$\mathbf{R}$\@. For the flight being used as an example, the mean
and standard \index{deviation, standard!heading error}deviation of
the correction from (\ref{eq:estimator-equation}) for all cases where
the horizontal accelerations exceed this criterion are 0.003$\pm0.15{}^{\circ}$
for 4295 1-Hz measurements, and the mean error\index{error!heading!mean}
is determined to a standard \index{heading!correction!uncertainty}uncertainty
of about 0.002$^{\circ}$.

\subsection{Smoothing the errors in pitch and roll\label{subsec:Smoothing-the-errors}}

\index{smoothing}\index{error!smoothing}Because the errors in pitch
and roll are strongly coupled\index{coupling!strong} to the errors
in velocity, good estimates of these errors should arise naturally
from the Kalman \index{Kalman filter}filter. However, the estimated
\index{pitch!error!smoothing}errors so obtained are noisy in comparison
to the direct measurements, so application of those corrections will
introduce undesirable noise\index{noise!from Kalman filter!reducing}
into the results from the filter. Variations in the errors in velocity
indicate that the main source of error in pitch is expected to be
the slowly varying Schuler oscillation\index{Schuler oscillation},
so it is preferable to smooth the corrections before applying them
to the original measurements to avoid the introduction of noise. As
described above, the errors in pitch and roll are those that apply
to the original measurements in the \index{reference frame!a-frame@\emph{a-}frame}\emph{a-}frame.
However, if a major source of those errors is platform misalignment
that varies slowly, the errors will vary smoothly in the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
where \emph{l-}frame pitch error refers to platform\index{inertial platform!misalignment}
north-south tilt and \emph{l-}frame roll error refers to platform
east-west tilt. In the \emph{a-}frame, each turn leads to mixing of
the pitch and roll errors and to abrupt changes, so smoothing\index{error!smoothing!l-frame@\emph{l-}frame}
in the \emph{l-}frame followed by \index{reference frame!transformation}transformation
back to the \emph{a-}frame produces a better result. This will be
discussed further after the results from the Kalman filter are presented.\footnote{An alternative that would likely be preferable would be to use the
\emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame} errors
in pitch and roll in the \index{state vector}state vector. This has
not been done in this document and the associated code, but might
be worth explorating in the future because it should produce smoother
variations in the corrections.}

<<Kalman-setup, include=TRUE, cache=CACHE>>=

## the chunk is 'sourced' here so the same code can be used in KalmanFilter.R
# source ('chunks/Kalman-setup.R')
## Kalman-setup
## initialize matrices needed by the Kalman filter and load the starting-point
## for the error-state vector.

NSTEP <- 30      ## update time
# r <- setRange(D1, 110000, 120000)
# D1 <- D1[r, ]
DL <- nrow (D1)
DLL <- DL - DL %% NSTEP
if (DLL != DL) {
  D1 <- D1[1:DLL, ]
  DL <- DLL
}
## initial values of the state vector and error-state vector:
SV <- with(D1[1, ], data.frame(LAT, LON, ZROC, VEW, VNS, ROC, PITCH, ROLL, THDG,
                               BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
## also need the corresponding noise vector:
tau <- 60
GCF <- function (sv, sp) {    ## sv is the state vector; sp is the data record
  gcf <- vector('numeric', length=15)
  ## For lat and lon, noise evidence indicates 1 m, but when that is used
  ## there are numerical problems in the 'solve' call because of the large range
  ## in values in the matrix. Forcing these 10 times larger avoids that problem.
  gcf[1] <- 10 / sp$Rm
  gcf[2] <- 10 / (sp$Rn * cos (sv$LAT))
  gcf[3] <- 10
  gcf[4:5] <- 0.02    ## 0.3
  gcf[6] <- 0.05
  gcf[7:8] <- 0.02*Cradeg  ## 0.005
  gcf[9] <- 0.02*Cradeg    ## 0.015
  gcf[10:11] <- 0.003*Cradeg    ## 0.015
  gcf[12] <- 0.003*Cradeg       ## 0.015
  gcf[13:15] <- 0.00005 # see text re why this is so small
  # gcf <- as.vector(gcf) * sqrt(2/tau)
  return (gcf)
}
gcf <- as.numeric (GCF (SV, D1[1, ]))

## The measurement model: 
##      Calculate the measurements of acceleration from the GPS to add to the measurement vector.
##      This was explored but not used in the version that produced the the Tech Note
GAEL <- c(D1$LACCX - D1$vedot, D1$LACCY - D1$vndot, D1$LACCZ - D1$vudot)
DL <- nrow(D1)
dim(GAEL) <- c(DL, 3)
## transform to the a-frame
GAE <- XformLA (D1, GAEL, .inverse=TRUE)
## get rotation-rate corrections to apply to GPS measurements
LR <- 4.42; LG <- -4.30
Pdot <- c(0, diff (D1$PITCH*Cradeg)) * Rate  # diff does step-wise differentiation
Hdot <- c(0, diff (D1$THDG*Cradeg))          # see Rate multiplication few lines down
Hdot[is.na(Hdot)] <- 0
Hdot[Hdot > pi] <- Hdot[Hdot > pi] - 2*pi
Hdot[Hdot < -pi] <- Hdot[Hdot < -pi] + 2*pi
Hdot <- Hdot * Rate
cospsi <- cos (D1$THDG*Cradeg)
sinpsi <- sin (D1$THDG*Cradeg)
cosphi <- cos (D1$ROLL*Cradeg)

## note that LG is negative:
DZ <- with(D1, c(Cradeg*(LAT-GGLAT)-LG*cospsi/Rm, Cradeg*(LON-GGLON)-LG*sinpsi/Rn, 
                 ZROC-GGALT, VEW-GGVEW + LG*Hdot*cospsi, 
                 VNS-GGVNS - LG*Hdot*sinpsi, ROC-D1[, VROC] + LG*Pdot*cosphi))
# DZ <- c(DZ, GAE[,1], GAE[,2], GAE[,3]) ## add this later?
## The last three components provide direct feedback to measured acceleration
## in the a-frame but also provide feedback to heading, as developed below
# dim(DZ) <- c(DL, 9)
# dim(DZ) <- c(DL, 6)
# DZ[,1:2] <- DZ[, 1:2] * Cradeg
## now add the pseudo-measurement of heading error found from the accelerations:
D1$deltaPsi <- (atan2 (D1$LACCX, D1$LACCY) - atan2 (D1$vedot, D1$vndot))
## alternate based on (12):
D1$deltaPsi <- (D1$LACCX*(D1$vndot-D1$LACCY)-D1$LACCY*(D1$vedot-D1$LACCX)) /
               (D1$LACCX^2+D1$LACCY^2)
D1$deltaPsi[D1$deltaPsi > pi] <- D1$deltaPsi[D1$deltaPsi > pi] - 2*pi
D1$deltaPsi[D1$deltaPsi < -pi] <- D1$deltaPsi[D1$deltaPsi < -pi] + 2*pi
D1$sdPsi <- zoo::rollapply(D1$deltaPsi, 10, sd, fill=NA)  ## calculate the std dev
## add the heading correction to the measurement vector
DZ <- c(as.vector(DZ), D1$deltaPsi)
dim(DZ) <- c(DL, 7)

## The observation matrix: (the first six and last three components of the state error 
## vector are observable, the latter requiring transformation from l-frame to a-frame)
## components 7-9 are connected to IRU-measured rotation rates via the transformation matrix l->a,
## so matrix H must vary with aircraft attitude angles. This is addressed by the GAEL->GAE transform.
# H <- diag(1, nrow=10, ncol=15)
# for (k in 7:9) {
#   H[k,k] <- 0
#   H[k,k+6] <- 1
# }
# H[10,9] <- 1
H <- diag(1, nrow=7, ncol=15)
H[7,7] <- 0
H[7,9] <- 1  ## measurement 7 applies to the heading error, SVE component 9


## at any time step, assume the measurements are contaminated by noise:
RCV <- matrix (rep(0,100), ncol=10)
RCV <- matrix (rep(0,49), ncol=7)
RCV[1,1] <- (1/D1$Rm[1])^2  ## latitude
RCV[2,2] <- (1/(D1$Rn[1]*cos(SV$LAT)))^2
RCV[3,3] <- 5^2 #100^2
RCV[4,4] <- 0.1^2            ## ve
RCV[5,5] <- 0.1^2
RCV[6,6] <- 0.1^2
# RCV[7,7] <- 100.0  # A big value here limits updating of acceleration measurement.
# RCV[8,8] <- 100.0  # The assumption is that there errors arise from an error in heading, not
# RCV[9,9] <- 100.0  # measured acceleration, so the GPS-measured acceleration is used for that.
# RCV[10,10] <- D1$sdPsi[1]^2
# if (is.na(D1$sdPsi[1])) {RCV[10,10] <- 225}  # typical sd is 15 deg.
# # RCV[10, 10] <- 1000  ## suppress effect
RCV[7,7] <- 1000  ## but update this each time step

## initialize covariance matrix with generous variances, because Schuler-oscillation
## errors might be large at the start
CV <- matrix (rep(0,225), ncol=15)
CV[1,1] <- 2000^2 / D1$Rm[1]^2
CV[2,2] <- 2000^2 / (D1$Rn[1]*cos(SV[1]))^2
CV[3,3] <- 500^2
CV[4,4] <- 4
CV[5,5] <- 4
CV[6,6] <- 4
CV[7,7] <- (0.3*Cradeg)^2
CV[8,8] <- CV[7,7]
CV[9,9] <- (1*Cradeg)^2
CV[10,10] <- CV[11,11] <- (0.005*Cradeg)^2
CV[12,12] <- (0.01*Cradeg)^2
CV[13,13] <- CV[14,14] <- CV[15,15] <- 0.0005^2

## Q: (initial estimate):
Q <- diag(gcf^2, 15)



@

<<Kalman-loop, include=TRUE, cache=CACHE>>=

# source ('chunks/Kalman-loop.R')
## Kalman-loop.R

SVEF <- array(dim=c(DL/NSTEP, 15))
CVEF <- array(dim=c(DL/NSTEP, 15))
## initialize error state vector
SVE <- rep (0, 15)  ## respectively: (lat,lon,alt) (vew,vns,vspd),
## (pitch,roll,thdg) (rot. rates) (accel components)
SVE[1:6] <- DZ[1, 1:6]
## pitch and roll errors are going to be those in the l-frame
SVE[7:9] <- 0  ## might initialize using pitch/roll/heading-correction functions here
## start with zero for gyro and accelerometer errors
SVEF[1, ] <- SVE
CVEF[1, ] <- diag (CV)
pctL <- 0
MH <- 1    ## 0 suppresses use of deltaPsi as error in heading
for (i in seq(2*NSTEP, DL, by=NSTEP)) {
  pct <- as.integer(100*i/DL)
  # if (pct %% 10 == 0 && pct != pctL) {print (sprintf ('pct done is %d', pct));pctL <- pct}
  SV <- with(D1[i, ], data.frame(LAT, LON, ZROC, VEW, VNS, ROC, PITCH, ROLL, THDG,
                                 BPITCHR, BROLLR, BYAWR, BLATA, BLONGA, BNORMA))
  SV[c(1,2,7:12)] <- SV[c(1,2,7:12)] * Cradeg
  Rn <- D1$Rn[i]
  Rm <- D1$Rm[i]
  Grav <- D1$Grav[i]
  sv <- as.vector (SV, mode='numeric')
  # stmf <- STMFV (sv)
  dcm <- jacobian (STMFV, sv) * dt * NSTEP + diag(15)
  ## modify to include this?
  ## modify this to include decaying error terms for the measurements:
  # dcm[10,10] <- dcm[11,11] <- dcm[12,12] <- -1/tau
  # dcm[13,13] <- dcm[14,14] <- dcm[15,15] <- -1/tau
  ## predict the new error-state vector:
  ## the pitch and roll error derivatives are now those in the a-frame, but
  ##   the pitch/roll error state is in the l-frame. Save the l-frame error state:
  #   SVEL <- SVEA <- SVE
  #   ## Transform l-frame pitch/roll error state to a-frame
  #   SVEA[7] <- cos(sv[9]) * SVEL[7] + sin(sv[9]) * SVEL[8]
  #   SVEA[8] <- -sin(sv[9]) * SVEL[7] + cos(sv[9]) * SVEL[8]
  #   ## apply derivatives to get a-frame change
  #   SVEA <- dcm %*% SVEA
  #   ## transform back to l-frame
  #   SVEL[7] <- cos(sv[9]) * SVEA[7] - sin(sv[9]) * SVEA[8]
  #   SVEL[8] <- sin(sv[9]) * SVEA[7] + cos(sv[9]) * SVEA[8]
  
  SVE <- dcm %*% SVE    ## take time step in error-state vector
  
  ## update the covariance matrix:
  CV <- dcm %*% (CV %*% t(dcm)) + Q
  if (is.na(D1$sdPsi[i]) || (sqrt(D1$LACCX[i]^2+D1$LACCY[i]^2) < 1)) {
    H[7,9] <- 0
    # DZ[i, 7] <- NA
  } else {
    H[7,9] <- MH
    RCV[7, 7] <- 10*D1$sdPsi[i]^2
  }
  ## the Kalman gain:
  Kb <- solve (H %*% CV %*% t(H) + RCV)
  K <- CV %*% t(H) %*% Kb
  DZZ <- DZ[i, ] - H %*% SVE
  SVE <- SVE + K %*% DZZ
  CV <- CV - K %*% H %*% CV
  SVEF[i/NSTEP, ] <- SVE
  CVEF[i/NSTEP, ] <- diag(CV)
}

## interpolate the results over the full data.frame:
IntFilter <- function (X, inRate, outRate) {
  if (inRate == outRate) {return (X)}
  ratio <- as.integer(outRate/inRate)    ## expected to be an integer
  x <- 0:(length(X)-1)
  A <- stats::approx (x, X, n=length(X)*ratio-ratio+1)
  T <- A$y
  T <- signal::filter(signal::sgolay(4,75),T)
  ## now shift to match Rate:
  n <- as.integer (ratio / 2)
  NL = length(T)
  T <- c(rep(T[1],n), T, rep(T[NL],ratio-n-1))  ## OK, even or odd ratio
  return (T)
}
Cor <- vector('numeric', DL*15)
dim (Cor) <- c(DL, 15)
VCor <- vector ('numeric', DL*15)
dim (VCor) <- c(DL, 15)
X <- SVEF[, 1]
for (j in 1:15) {
  Cor[, j] <- IntFilter (SVEF[, j], 1, NSTEP)
  VCor[, j] <- IntFilter (CVEF[, j], 1, NSTEP)
  VCor[VCor[,j] < 0] <- 0 
  if (j > 6) {next}
  Cor[, j] <- zoo::na.approx (as.vector (Cor[, j]), maxgap=1000, na.rm=FALSE)
  Cor[is.na(Cor[, j]), j] <- 0
  Cor[, j] <- signal::filtfilt (signal::butter (3, 1/600), Cor[, j])
}
# Cor7 <- Cor[, 7]
# VC7 <- VCor[, 7]
# .hdg <- D1$THDG * Cradeg
# Cor[, 7] <- cos(.hdg) * Cor7 - sin(.hdg) * Cor[, 8]
# Cor[, 8] <- sin(.hdg) * Cor7 + cos(.hdg) * Cor[, 8]
# VCor[, 7] <- cos(.hdg) * VC7 - sin(.hdg) * VCor[, 8]
# VCor[, 8] <- sin(.hdg) * VC7 + cos(.hdg) * VCor[, 8]
D1$LATKF <- D1$LAT - Cor[, 1]/Cradeg
D1$LONKF <- D1$LON - Cor[, 2]/Cradeg
## filter the result to smooth the jumps arising from limited INS resolution:
D1$LATKF <- zoo::na.approx (as.vector (D1$LATKF), maxgap=1000, na.rm=FALSE)
D1$LONKF <- zoo::na.approx (as.vector (D1$LONKF), maxgap=1000, na.rm=FALSE)
D1$LATKF[is.na(D1$LATKF)] <- 0
D1$LONKF[is.na(D1$LONKF)] <- 0
D1$LATKF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), D1$LATKF)
D1$LONKF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), D1$LONKF)
D1$ALTKF <- D1$ZROC - Cor[, 3]
D1$VEWKF <- D1$VEW - Cor[, 4]
D1$VNSKF <- D1$VNS - Cor[, 5]
D1$ROCKF <- D1$ROC - Cor[, 6]
D1$PITCHKF <- D1$PITCH - Cor[, 7]/Cradeg
D1$ROLLKF <- D1$ROLL - Cor[, 8]/Cradeg
D1$THDGKF <- D1$THDG - Cor[, 9]/Cradeg
D1$BPITCHRKF <- D1$BPITCHR - Cor[, 10]/Cradeg
D1$BROLLRKF <- D1$BROLLR - Cor[, 11]/Cradeg
D1$BYAWRKF <- D1$BYAWR - Cor[, 12]/Cradeg
D1$BLATAKF <- D1$BLATA - Cor[, 13]
D1$BLONGAKF <- D1$BLONGA - Cor[, 14]
D1$BNORMAKF <- D1$BNORMA - Cor[, 15]

D1$DLAT <- D1$LATKF-D1$GGLAT
D1$DLATM <- D1$DLAT * .060 * StandardConstant ('Cmfromnmi')
D1$CLAT <- -Cor[, 1] / Cradeg
D1$CLATM <- D1$CLAT * .060 * StandardConstant ('Cmfromnmi')
D1$DLON <- D1$LONKF-D1$GGLON
D1$DLONM <- D1$DLON * .060 * StandardConstant ('Cmfromnmi') * cos (D1$GGLAT * Cradeg)
D1$CLON <- -Cor[, 2] / Cradeg
D1$CLONM <- D1$CLON * .060 * StandardConstant ('Cmfromnmi') * cos (D1$GGLAT * Cradeg)
D1$DALT <- (D1$ALTKF-D1$GGALT)/1000
D1$CALT <- -Cor[, 3]/1000
D1$DVEW <- D1$VEWKF-D1$GGVEW
D1$CVEW <- -Cor[, 4]
D1$DVNS <- D1$VNSKF-D1$GGVNS
D1$CVNS <- -Cor[, 5]
D1$DROC <- D1$ROCKF-D1[, VROC]
D1$CROC <- -Cor[, 6]
D1$CPITCH <- -Cor[, 7] / Cradeg
D1$CROLL <- -Cor[, 8] / Cradeg
D1$CTHDG <- -Cor[, 9] / Cradeg

.hdg <- D1$THDG * Cradeg
D1$CPL <- (cos(.hdg)*Cor[,7]+sin(.hdg)*Cor[,8]) / Cradeg
D1$CRL <- (-sin(.hdg)*Cor[,7]+cos(.hdg)*Cor[,8]) / Cradeg
D1$SDCPL <- sqrt(cos(.hdg)^2*VCor[,7]+sin(.hdg)^2*VCor[,8]) / (30*Cradeg)
D1$SDCRL <- sqrt(sin(.hdg)^2*VCor[,7]+cos(.hdg)^2*VCor[,8]) / (30*Cradeg)
D1$SDCPA <- sqrt(cos(.hdg)^2*D1$SDCPL^2 + sin(.hdg)^2*D1$SDCRL^2)
D1$SDCRA <- sqrt(sin(.hdg)^2*D1$SDCPL^2 + cos(.hdg)^2*D1$SDCRL^2)
D1$CPLF <- signal::filtfilt (signal::butter (3, 1/900), D1$CPL)
D1$CRLF <- signal::filtfilt (signal::butter (3, 1/900), D1$CRL)
D1$CPAF <- cos(.hdg)*D1$CPLF - sin(.hdg)*D1$CRLF
D1$CRAF <- sin(.hdg)*D1$CPLF + cos(.hdg)*D1$CRLF
## save corrected values, obtained by subtracting the smoothed a-frame corrections:
D1$PITCHKF <- D1$PITCH - D1$CPAF
D1$ROLLKF <- D1$ROLL - D1$CRAF

HE <- VCor[,9]
HE[HE < 0.00001] <- 0.00001
# lineWAC(D1$Time[r], D1$THDG[r]/1000, col='brown', lwd=0.7)
# lineWAC(D1$Time, D1$CTHDG-HE, col='magenta', lwd=0.7)
# lineWAC(D1$Time, D1$CTHDG+HE, col='magenta', lwd=0.7)
# D1$CTHDG <- SmoothInterp (D1$CTHDG, .Length=181)
SS <- smooth.spline(D1$Time, D1$CTHDG, w=1/HE, spar=1.1)
D1$HCS <- predict(SS, as.numeric(D1$Time))$y
D1$THDGKF <- D1$THDG - D1$HCS    ## save the corrected heading


@

\clearpage

\subsection{Results}


\subsubsection{Position}

Because the \index{time step}time step for the \index{Kalman filter!time step}Kalman
filter is normally longer that the interval between measurements in
the original file, the error estimates from the Kalman filter are
\index{interpolation!Kalman-filter results}interpolated to the original
data rate\index{data rate} and then subtracted from the original
\index{position!Kalman filter}measurements to obtain corrected\index{Kalman filter!corrected variable}
results corresponding to the original measurements. The \index{Kalman filter!results!position}corrected
results for position, after conversion to meters, are shown in Fig.~\ref{fig:plot-Kalman-position}\index{altitude of aircraft!Kalman filter}\index{comparison!plot!Kalman filter results}
for DEEPWAVE\index{DEEPWAVE research project} flight 16. The blue
lines in the top two panels show that differences between the corrected
(KF) and \index{navigation system!GPS}GPS-based measurements (DLAT=\sindex[var]{LAT: latitude, INS}LAT$-$\sindex[var]{GGLAT: latitude, GPS}GGLAT+CLAT
and DLON=\sindex[var]{LON: longitude, INS}LON$-$\sindex[var]{GGLON: longitude, GPS}GGLON+CLON
where CLAT and CLON are the corrections produced by the Kalman filter)
are negligibly small for latitude\index{latitude} and \index{longitude}longitude,
at the resolution of these plots. This good agreement arises from
the corrections CLAT and CLON shown as the green lines, which show
a smoothly varying \index{Schuler oscillation}Schuler oscillation.\footnote{Before addition to the original measurement, this correction has been
filtered using a three-pole low-pass Butterworth filter\index{filter!Butterworth}
 with cutoff frequency\index{filter!cutoff frequency} corresponding
to a period of 600~s. This avoids the introduction of noise from
the Kalman filter that otherwise would contaminate the high-frequency
variance \index{spectrum!variance}spectra.} Using the new variable ZROC\sindex[var]{ZROC: altitude, INS new}
from Sect.~\ref{subsec:ROC} for altitude\index{altitude of aircraft!new variable ZROC}
leads to only a small \index{altitude!offset}offset in vertical position;
this would be 100 times larger if the \index{navigation system!inertial}INS-provided
variable ALT\sindex[var]{ALT: altitude, INS}\index{variable in data files!ALT}
 had been used, because then the correction would need to remove the
difference between pressure altitude,\index{altitude of aircraft!pressure}
used by the INS, and geometric altitude\index{altitude of aircraft!geometric}
 from the GPS. 

At higher resolution than plotted here, there are step-change features
in the KF result that are not present in the GPS measurement, at a
level of about 10~m. The reason is that this is the \index{resolution!data recording}resolution
at which the original measurements from the \index{navigation system!inertial}INS
(variables LAT and LON) are recorded, so a smoothly varying correction
as provided by the Kalman filter preserves these step changes. Because
the true values of latitude\index{latitude} and \index{longitude}longitude
are not expected to show high-frequency components at these frequencies,
the positions after correction are further \index{smoothing}filtered
using a low-pass Butterworth filter with a cutoff frequency\index{filter!cutoff frequency}
corresponding to about 10~s. This effectively smooths the jumps arising
from the original \index{position!smoothing}measurements from the
INS and leads to agreement between the KF and \index{navigation system!GPS}GPS-based
values corresponding to about 10~m standard deviation\index{deviation, standard!position difference}
for the part of the flight track that excludes the initial climb and
final descent. Some part of this standard deviation likely arises
from minor time shifts between the measurements from the INS and GPS.

<<plot-Kalman-position, include=TRUE, fig.scap="Comparison of the Kalman filter, GPS, and INS values for latitude, longitude and altitude, with corrections from the Kalman filter also shown.", fig.cap='Comparison of the KF (Kalman filter), GPS, and INS values of position for DEEPWAVE flight 16. DLAT, DLON, and DALT (blue lines) are the differences between the Kalman-filter result and GPS measurement, while CLAT, CLON, and CALT (green lines) are the corrections applied to the original INS values by the Kalman filter.', cache=CACHE>>=

r <- setRange (D1, 70000, 122000)
DP <- D1[r, ]
ggplotWAC (with (DP,
                 data.frame(Time, DLONM, CLONM, DLATM, CLATM, DALT, CALT)),
           ylab=expression (paste ('difference in position [km]')),
           panels=3, 
           labelL=c('KF-GPS', 'correction'),
           labelP=c('east', 'north', 'up'),
           legend.position=c(0.2,0.68), theme.version=1
)
sdZ <- sd(DP$DALT, na.rm=TRUE)
sdvew <- sd(DP$GGVEW - DP$VEWKF, na.rm=TRUE)
sdvns <- sd(DP$GGVNS - DP$VNSKF, na.rm=TRUE)
meanvz <- mean(DP$ROCKF - DP[, VROC], na.rm=TRUE)
sdvz <- sd(DP[, VROC] - DP$ROCKF, na.rm=TRUE)

@

The result then is that the \index{position!Kalman filter}positions
after correction are in agreement with the \index{navigation system!GPS}GPS-based
measurements of position to within about 10~m in each component of
the position vector. The uncertainty arising from the calculated covariance\index{matrix!covariance}
matrix\index{matrix!covariance} also indicates uncertainty\index{Kalman filter!uncertainty}
for individual \index{position!uncertainty}measurements of \index{latitude!uncertainty}latitude
or \index{longitude}longitude corresponding to about 10~m.

\subsubsection{Ground-speed components and rate of climb}

\index{ground speed}\index{Kalman filter!results!velocity}Figure
\ref{fig:plot-Kalman-velocity} shows the corresponding differences
between the aircraft-velocity \index{velocity of aircraft!Kalman filter}\index{velocity of aircraft!{*}{*}}components\index{velocity of aircraft!Kalman filter}
and the \index{navigation system!GPS}GPS-based measurements, for
the same flight as that shown in the preceding figure. For the two
horizontal components of ground speed, the mean difference between
KF and GPS results is negligible ($<0.00001$~m/s) and the standard
deviation\index{deviation, standard!velocity difference} of this
difference is about \Sexpr{round(sdvns, 2)}~m/s, mostly arising
in turns and likely the result of small timing differences between
INS-provided and GPS-based measurements. There does not appear to
be a problem with \index{resolution!data recording}resolution for
the INS variables (\sindex[var]{VEW: ground speed eastward, INS}VEW
and \sindex[var]{VNS: ground speed northward, INS}VNS) as there was
for position, so no further smoothing of these results is needed.
Indeed, plots of the KF and \index{navigation system!GPS}GPS-based
variables for short time intervals indicate that there is more noise
in the GPS-based variables (GGVEW and GGVNS) than in the KF variables,
so using the new variables from the Kalman filter in the calculation\index{wind!horizontal!calculation}
of horizontal wind may lead to better high-frequency spectral characteristics\index{spectral characteristics!high frequency}
than those obtained using the GPS-based variables. This will be explored
further in Sect.~\ref{subsec:KF-wind}. The occasional spikes in
this plot are all associated with turns, and they have been minimized
by adjustment of the relative timing\index{time lag!adjustment for}
between the INS-provided and GPS-based variables as well as correction
for the \index{correction!for aircraft rotation}rotation rates of
the aircraft, but these small residuals remain. Despite some exploration,
it has not been possible to reduce them further.

The difference between the KF and \index{navigation system!GPS}GPS-based
variables for \index{rate of climb!Kalman filter}rate-of-climb of
the aircraft,\index{rate of climb!Kalman filter}\index{rate of climb!Kalman filter}
shown in the bottom panel of Fig.~\ref{fig:plot-Kalman-velocity},\index{comparison!plot!Kalman filter results}
needs further explanation. This calculation was first done using the
INS-provided variable \sindex[var]{VSPD: rate of climb, INS}VSPD
as the vertical-motion component of the state variable. While the
mean values were similar, the standard deviation\index{deviation, standard!velocity difference}
in this difference was about 0.28~m/s, which is larger than expected
or desirable. The difficulty is attributable to weakness in the \index{navigation system!inertial}INS-provided
variable \index{VSPD!characteristics}VSPD\@. Examination of this
variable indicates that it has been filtered and shifted in time before
being transmitted to the GV data system for recording, and the INS
internal processing includes a \index{baro-inertial loop}baro-inertial
loop that updates to the pressure altitude.\index{altitude of aircraft!pressure}
Section \ref{subsec:ROC} of this technical note and this \index{rate of climb!ROC memo}memo
(\href{https://drive.google.com/open?id=0B1kIUH45ca5AMXpaWlIyWWxwU2M}{Recommendation161107f.pdf})
argue that \sindex[var]{VSPD: rate of climb, INS}VSPD is a poor variable
to use when calculating the vertical wind\index{wind!vertical!{*}{*}}
and that an alternative \index{ROC=rate of climb}variable\sindex[var]{ROC: rate of climb, INS new}
(ROC) represents the rate of climb of the aircraft better while still
remaining independent of the GPS-based measurements. That new variable
has been used in the present calculation and in Fig.~\ref{fig:plot-Kalman-velocity}\index{velocity of aircraft!Kalman filter}\index{DEEPWAVE research project}
 instead of VSPD. The Kalman filter then updates that variable to
the \index{navigation system!GPS}GPS-based \index{measurement!from GPS}measurement
(GGVSPD), to produce the new variable \index{ROC=rate of climb}ROCKF\sindex[var]{ROCKF: rate of climb, Kalman filter}
that is shown in this plot. The mean difference between the GPS value
and the corrected measurement from the Kalman filter\index{Kalman filter}
was \Sexpr{round(meanvz,3)}~m/s, with standard deviation \Sexpr{round(sdvz, 2)}~m/s.
Section~\ref{subsec:KF-vertical-wind} explores the characteristics
of the new variable (ROCKF) as it would influence calculation\index{wind!vertical!calculation}
of the vertical wind. There it is argued that the level of noise evident
in the bottom panel of this plot arises mostly from noise in the \index{navigation system!GPS}GPS-based
\index{measurement!from GPS!noise}measurement of rate of climb.

<<plot-Kalman-velocity, include=TRUE, fig.scap="Comparison of the Kalman filter, GPS, and INS values for aircraft-velocity components, with corrections from the Kalman filter also shown.", fig.cap="Comparison of the KF, GPS, and INS values of aircraft-velocity components for DEEPWAVE flight 16. Blue lines show the differences between the Kalman-filter results and the corresponding GPS-based values, while the green lines show the corrections applied to the original INS values by the Kalman filter.", cache=CACHE>>=

ggplotWAC (with (DP,
                 data.frame(Time, DVEW, CVEW, DVNS, CVNS, DROC, CROC)),
           ylab=expression (paste ('velocity component [m ',s^-1,']')),
           panels=3, 
           labelL=c('KF-GPS', 'correction'),
           labelP=c('east', 'north', 'up'),
           legend.position=c(0.2, 0.97), theme.version=1
)

@

\newpage

<<errors-in-pitch, include=TRUE, fig.height=4.5, fig.scap="Errors in pitch and roll after transformation to the l-frame with a filtered result and bands of uncertainty.", fig.cap='Errors in pitch and roll after transformation to the l-frame (blue lines). The red lines result from the application of a centered low-pass third-order Butterworth filter to the errors, where the filter cutoff frequency corresponds to a period of 900 s. The shaded ribbon shows the estimated standard uncertainty.', dev='png', dpi=100, cache=CACHE>>=

## must construct using many of the elements of ggplotWAC but in this order:
d1 <- with(DP, data.frame(Time, CPL, CPLF, CRL, CRLF))
lines_per_panel <- 2; panels <- 2
labelL=c('KF value', 'smoothed')
labelP=c('pitch', 'roll')
DL <- nrow(d1)
VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
dd <- data.frame(reshape2::melt(d1, 1), VarGroup, PanelGroup)
lvl <- levels(dd$VarGroup)
d2 <- with(DP, data.frame(Time, "plo"=CPLF-4*SDCPL, "rlo"=CRLF-4*SDCRL,
                             "phi"=CPLF+4*SDCPL, "rhi"=CRLF+4*SDCRL))
## note the required order below:
de <- data.frame (reshape2::melt(d2, 1, c(2,4,3,5)), VarGroup, PanelGroup)
g7 <- ggplot(dd, aes(x=Time)) + facet_grid(PanelGroup ~ .) 
g7 <- g7 + geom_ribbon(aes(x=Time, ymin=value, ymax=value), data=de, alpha=0.25)  ##alpha=.25 
g7 <- g7 + geom_path(aes(x=Time, y=value, colour=VarGroup, linetype=VarGroup, size=VarGroup), data=dd)
g7 <- g7 + ylim(-0.05,0.05)
g7 <- g7 + scale_linetype_manual ('', labels=lvl, breaks=lvl, values = c(1,1))
g7 <- g7 + scale_colour_manual('', labels = lvl, breaks=lvl, values = c('blue', 'red'))
g7 <- g7 + scale_size_manual('', labels=lvl, breaks=lvl, values = c(0.5, 1.5))
g7 <- g7 + theme_WAC(1) + theme (legend.position=c(0.5,0.95))
g7 <- g7 + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)))
g7 <- g7 + theme(axis.title.x = element_text (size=12))
g7 <- g7 + labs (x='Time [UTC]', y=expression (paste ('l-frame error [',degree,']')))
## I'm not sure why this is necessary; printing g7 in the usual way did not leave
## the ribbon visible, apparently because the resulting pdf file did not include it.
## Now the plot is generated here, but placed in the document in the LaTeX code
## preceding this chunk. This out-of-order sequence requires run
# png (filename='Fig7.png', width=600, height=480, res=150)
print (g7)
# invisible (dev.off())


@

\subsubsection{Roll and pitch\label{subsec:Roll-and-pitch}}

\index{Kalman filter!results!pitch}\index{Kalman filter!results!roll}The
primary value of this Kalman-filter estimate of error is the improvement
in the \index{attitude angle}measurements of attitude angles.\index{attitude angle}
\index{measurement!from GPS}Measurements of position and velocity
with good quality are already available from the GPS\index{navigation system!GPS}
receiver, although some improvement is realized in those cases also.
As discussed in Sect.~\ref{subsec:Smoothing-the-errors}, it is expected
that the errors in pitch and roll will vary more smoothly in the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
than in the \emph{a-}frame\index{reference frame!a-frame@\emph{a-}frame}
because each turn changes how any platform\index{inertial platform!misalignment}
misalignment is resolved into errors in pitch and roll. It is therefore
useful to \index{reference frame!transformation}transform those errors
to the \emph{l-}frame for \index{smoothing}\index{pitch!smoothing!l-frame@\emph{l-}frame}smoothing.
The approximate transformation for level flight is\\
\begin{eqnarray}
\delta\theta^{(l)} & = & \cos\psi\thinspace\delta\theta^{(a)}+\sin\psi\thinspace\delta\phi^{(a)}\label{eq:a-to-l-frame}\\
\delta\phi^{(l)} & = & -\sin\psi\thinspace\delta\theta^{(a)}+\cos\psi\thinspace\delta\phi^{(a)}\nonumber 
\end{eqnarray}
where $\theta$, $\phi$ and $\psi$ denote pitch, roll and heading,
respectively, and the superscripts in parentheses indicate the reference
frame. After this transformation is applied to the \index{error-state vector}error-state
vector produced by the Kalman filter, the pitch and roll errors in
the \emph{l-}frame\index{reference frame!l-frame@\emph{l-}frame}
are as shown in \index{reference frame!transformation}Fig.~\ref{fig:errors-in-pitch}.\index{filter!cutoff frequency}\index{error!pitch!Kalman-filter result}
As for position and velocity, pronounced Schuler oscillations\index{Schuler oscillation}
are evident in both. Also shown in this plot is the result of applying
a low-pass third-order Butterworth filter\index{filter!Butterworth}
with 900~s cutoff period to the errors. The result is a smoothly
varying error signal dominated by the Schuler oscillation that eliminates
much of the apparent noise introduced by the Kalman filter. \index{reference frame!a-frame@\emph{a-}frame}Figure~\ref{fig:a-frame-errors}
shows the result of transforming the smoothed error\index{error!pitch!a-frame@\emph{a-}frame}
signal back to the \emph{a-}frame, and it also shows the result of
the simplified algorithm of Sect.~XX as the red line labeled ``PC.''
The results from the simplified algorithm are in good agreement with
the error estimates from the Kalman filter, with some increased differences
in turns as expected. These smoothed errors are then subtracted from
the original measurements to obtain corrected \index{measurement!corrected by Kalman filter}results,

<<a-frame-errors, include=TRUE, fig.height=4.0, fig.scap="Errors in pitch and roll that result from transforming the filtered result in the previous figure back from the l-frame to the a-frame.", fig.cap='Errors in pitch and roll (blue lines) that result from transforming the filtered result in the previous figure back from the l-frame to the a-frame. The red lines show the result of the separate pitch-correction function discussed in the text. The shaded ribbon shows the estimated standard uncertainty in the Kalman-filter result.', dev='png', dpi=100, cache=CACHE>>=

# with(D1[r, ],
#      ggplotWAC (data.frame(Time, CPL, CPLF, CRL, CRLF),
#                 col=c('blue', 'red'), lwd=c(1.4, 0.8), lty=c(1,1),
#                 ylab=expression (paste ('l-frame error [',degree,']')),
#                 panels=2, labelL=c('KF value', 'smoothed'),
#                 labelP=c('pitch', 'roll')
#      )
# )

PC <- CorrectPitch(DP, .span=901)
DP$PC <- PC[, 1]
DP$RC <- PC[, 2]

# with(D1[r, ],
#      ggplotWAC (data.frame(Time, CPAF, PC, CRAF, RC),
#                 col=c('blue', 'red'), lwd=c(1.4, 0.8), lty=c(1,1),
#                 ylab=expression (paste ('a-frame error [',degree,']')),
#                 panels=2, labelL=c('KF smoothed', 'CorrectPitch'),
#                 labelP=c('pitch', 'roll')
#      )
# )
d1 <- with(DP, data.frame(Time, CPAF, PC, CRAF, RC))
lines_per_panel <- 2; panels <- 2
labelL=c('smoothed KF value', 'PC')
labelP=c('pitch', 'roll')
DL <- nrow(d1)
VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
dd <- data.frame(reshape2::melt(d1, 1), VarGroup, PanelGroup)
lvl <- levels(dd$VarGroup)
d2 <- with(DP, data.frame(Time, "plo"=CPAF-4*SDCPA, "rlo"=CRAF-4*SDCRA,
                             "phi"=CPAF+4*SDCPA, "rhi"=CRAF+4*SDCRA))
## note the required order below:
de <- data.frame (reshape2::melt(d2, 1, c(2,4,3,5)), VarGroup, PanelGroup)
g9 <- ggplot(dd, aes(x=Time)) + facet_grid(PanelGroup ~ .) 
g9 <- g9 + geom_ribbon(aes(x=Time, ymin=value, ymax=value), data=de, alpha=0.25) 
g9 <- g9 + geom_line(aes(x=Time, y=value, colour=VarGroup, linetype=VarGroup), data=dd)
g9 <- g9 + ylim(-0.05,0.05)
g9 <- g9 + scale_linetype_manual ('', labels=lvl, breaks=lvl, values = c(1,1))
g9 <- g9 + scale_colour_manual('', labels = lvl, breaks=lvl, values = c('blue', 'red'))
g9 <- g9 + theme_WAC(1) + theme (legend.position=c(0.5,0.95))
g9 <- g9 + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)))
g9 <- g9 + theme(axis.title.x = element_text (size=12))
g9 <- g9 + labs (x='Time [UTC]', y=expression (paste ('a-frame error [',degree,']')))
## I'm not sure why this is necessary; printing g9 in the usual way did not leave
## the ribbon visible, apparently because the resulting pdf file did not include it.
## Now the plot is generated here, but placed in the document in the LaTeX code
## preceding this chunk. This out-of-order sequence requires run
# png (filename='Fig9.png', width=600, height=480, res=150)
print (g9)
# invisible (dev.off())

## translate pitch/roll corrections to the a-frame:
.hdg <- DP$THDG * Cradeg
C7 <- SmoothInterp (Cor[, 7], .Length=181)
C8 <- SmoothInterp (Cor[, 8], .Length=181)
# CPITCH <- cos(.hdg) * C7 + sin(.hdg) * C8
# CROLL <- -sin(.hdg) * C7 + cos(.hdg) * C8
# # CPITCH <- cos(.hdg) * Cor[, 7] + sin(.hdg) * Cor[, 8]
# # CROLL <- -sin(.hdg) * Cor[, 7] + cos(.hdg) * Cor[, 8]
# D1$CPITCH <- CPITCH / Cradeg
# D1$CROLL <- CROLL / Cradeg
# D1$CPITCH <- SmoothInterp (D1$CPITCH, .Length=181)
# D1$CROLL <- SmoothInterp (D1$CROLL, .Length=181)
# D1$CTHDG <- SmoothInterp (D1$CTHDG, .Length=181)

DP$HC <- -CorrectHeading (DP, .plotfile='./HCPlot.pdf')

# plotWAC(subset(D1[r,],,c(Time, CPITCH, PC)), ylab=expression(paste('PITCH CORRECTION',' [',degree,']')), 
#         ylim=c(-0.05, 0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
# CCPITCH <- D1$CPITCH
# PCC <- D1$PC
# ival <- abs(D1$ROLL) > 4
# CCPITCH[ival] <- NA
# PCC[ival] <- NA
# lineWAC(D1$Time[r], CCPITCH[r], lwd=3, col='blue')
# lineWAC(D1$Time[r], PCC[r], lwd=3, col='red')
# abline(h=0, col='darkorange', lty=2)

# with(D1[r,], plotWAC(data.frame(Time, CPL)))
# lineWAC(D1$Time[r], predict(SP, as.numeric(D1$Time))$y[r], col='red')
# lineWAC(D1$Time[r], sqrt(VC7[r])+predict(SP, as.numeric(D1$Time))$y[r], col='darkgreen')
# lineWAC(D1$Time[r], -sqrt(VC7[r])+predict(SP, as.numeric(D1$Time))$y[r], col='darkgreen')
# Y <- predict(SP, as.numeric(D1$Time))$y[r]
# plotWAC(data.frame(D1$Time[r], Y, Y+sqrt(VC7[r]), Y-sqrt(VC7[r]), D1$CPL[r]), 
#         col=c('blue', 'darkgreen', 'darkgreen', 'red'), lty=c(1,2,2,1))
# plotWAC(subset(D1[r,],,c(Time, CROLL, RC)), 
#       ylab=expression(paste('ROLL CORRECTION [',degree,']')), 
#       ylim=c(-0.05,0.05), lwd=c(0.7,0.7), col=c('blue', 'red'), legend.position='topright')
# D1$CROLL[ival] <- NA
# D1$RC[ival] <- NA
# lineWAC(D1$Time[r], D1$CROLL[r], lwd=3, col='blue')
# lineWAC(D1$Time[r], D1$RC[r], lwd=3, col='red')
# abline(h=0, col='darkorange', lty=2)

DP$dP <- DP$deltaPsi/Cradeg
HA <- with(DP, sqrt(LACCX^2+LACCY^2))
DP$dP[HA < 1] <- NA
sddP <- sd(DP$dP, na.rm=TRUE)

@

The variances associated with \emph{l-}frame\index{pitch!variance!l-frame@\emph{l-}frame}
pitch and roll can be found by appropriate derivation from (\ref{eq:a-to-l-frame}).
The resulting variances correspond to a standard deviation\index{deviation, standard!pitch correction}
of typically about 0.2$^{\circ}$, but that then is reduced by an
appropriate factor representing the reduction in standard deviation
from averaging many points, as was done with the low-pass filter with
900~s cutoff.\index{filter!cutoff frequency} Averaging 900 points
would reduce the expected standard deviation by a factor of 1/30,
so this seems an appropriate factor to use when representing the \index{Kalman filter!uncertainty}uncertainty
in the \index{smoothing}smoothed correction. The gray ribbon in Fig.~\ref{fig:errors-in-pitch}
shows the resulting \index{pitch!uncertainty!l-frame@\emph{l-}frame}\index{pitch!uncertainty!a-frame@\emph{a-}frame}\index{error!pitch!uncertainty}standard
uncertainty in pitch and roll in the \index{reference frame!l-frame@\emph{l-}frame}\emph{l-}frame,
and this then leads to similar standard uncertainty in the \index{reference frame!l-frame@\emph{l-}frame}\emph{a-}frame
for the \index{smoothing}smoothed \index{error!pitch!smoothed}error
estimates, as shown in Fig.~\ref{fig:a-frame-errors}\index{function!CorrectPitch}.
The mean standard deviation obtained in this way is 0.01$^{\circ}$
for both pitch and roll in either the \emph{a-}frame or \emph{l-}frame,
so this is reasonable estimate of the uncertainty after correction
using the Kalman filter.


\subsubsection{Heading}

<<flight-track, include=TRUE, fig.height=3, fig.width=4, fig.scap="The flight track of about 7 h duration for DEEPWAVE flight 16, 4 July 2012.", fig.cap="The flight track of about 7 h duration for DEEPWAVE flight 16, 4 July 2012. In the Kalman filter, the many turns provide constraints on the heading. The dashed-line topography shows the South Island of New Zealand.", cache=CACHE>>=

plotTrack(getNetCDF(fname), .Spacing=NA)

@

<<plot-Kalman-heading, include=TRUE, fig.height=6, fig.scap="Heading error estimated from Eqn.\\ 15 (top), and the results from the Kalman filter and a simplified estimate of the error in heading (bottom).", fig.cap="(top) Heading error estimated from (15), for only those periods of DEEPWAVE flight 16 where the horizontal acceleration is larger than 1\\ m\\,s$^{-2}$. (bottom) Heading correction from the Kalman filter and from Ranadu::CorrectHeading (HC, green line). The results from the Kalman filter are plotted as dotted where the estimated standard deviation exceeds 0.02$^{\\circ}$ and as a thick solid line otherwise. A spline representing the smoothed heading correction from the Kalman filter, using the inverse of the estimated variance as weight factor for the spline, is shown as the red line. Data from DEEPWAVE flight 16.", cache=CACHE>>=


DP$dP <- DP$deltaPsi/Cradeg
HA <- with(DP, sqrt(LACCX^2+LACCY^2))
DP$dP[HA < 1] <- NA
# plotWAC(subset(DP,,c(Time, dP)))
grid.newpage()
suppressWarnings (
  with(DP,
       ggplotWAC (data.frame(Time, dP),
                  ylim=c(-0.4,0.4),
                  ylab=expression (paste ('error in heading [',degree,']')),
                  legend.position=NA, position=c(2,2), theme.version=1
       )
  )
)
# sddP <- sd(DP$dP, na.rm=TRUE)
DP$SDH <- sqrt(VCor[r,9]) / (Cradeg * 30)
DP$CCTHDG <- SmoothInterp (DP$CTHDG, .Length=181)
DP$CCCTHDG <- DP$CCTHDG
DP$CCCTHDG[DP$SDH > 0.02] <- NA
suppressWarnings (
  with (DP,
    ggplotWAC(data.frame(Time, 'Kalman'=CCTHDG, 'Ranadu'=HC, 'spline'=HCS, 'KF'=CCCTHDG), 
      ylim=c(-0.4,0.4), lwd=c(0.7,1,1,1.5), lty=c(3,1,1,1),
      ylab=expression (paste ('error in heading [',degree,']')),
      col=c('blue', 'forestgreen', 'red', 'blue'), position=c(1,2),
      legend.position=c(0.5,0.95), theme.version=1
    )
  )
)
# plotWAC(subset(DP,, c(Time, CCTHDG, HC)), ylim=c(-0.4,0.4), 
#         lwd=0.7, legend.position='topright')
# iv <- HE > 0.0012    # 0.0025
# D1$CCTHDG[iv] <- NA
# lineWAC(D1$Time, D1$CCTHDG, lwd=3, col='blue')
# lineWAC(D1$Time, D1$HCS, col='red')

@

\index{heading!Kalman filter results}\index{Kalman filter!results!heading}The
error in heading is more difficult to determine because, for most
flight conditions, the heading is poorly constrained and as a result
the estimated error in heading often has large uncertainty. \index{heading!correction!uncertainty}
The flight path for the particular flight used for this example included
frequent changes in flight direction, as shown in \index{DEEPWAVE research project}Fig.~\ref{fig:flight-track},
so those turns result in accelerations that can constrain the heading
at times spaced throughout during the flight. In Sect.~\ref{subsec:heading-error},
it was argued that (\ref{eq:estimator-equation}) provides an estimate
of the error\index{error!heading} in heading. However, for the full
flight (excluding initial climb and final descent) the mean value
provided by this formula was \Sexpr{round(mean(D1$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}$^{\circ}$
but the standard deviation of the correction provided by this equation
was \Sexpr{round(sd(D1$deltaPsi[r], na.rm=TRUE)/Cradeg, 3)}$^{\circ}$,
so using this correction throughout the flight would introduce unrealistic
corrections with large uncertainty. To avoid the noise\index{noise!in heading correction}
this would introduce, the estimated error can be considered valid
only when horizontal accelerations are large. The top panel in \index{error!heading}Figure~\ref{fig:plot-Kalman-heading}\index{acceleration!horizontal!required magnitude}\index{deviation, standard!heading correction}
shows the values from (\ref{eq:estimator-equation}) for those times
when the horizontal acceleration was more than 1~m\,s$^{-2}$. The
mean value of $\delta\psi$ for these periods was smaller than 0.001$^{\circ}$
and the standard deviation of the 4295 values was \Sexpr{round(sddP, 2)}.
This indicates that the \index{heading!correction!uncertainty}uncertainty
in the average error in heading\index{error!heading!uncertainty}
is smaller than 0.01$^{\circ}$ when the average is calculated for
the entire flight. 

The heading error\index{error!heading!correction}\index{correction!heading|see {error!heading!correction}}
from the Kalman filter\index{Kalman filter!results!heading} is shown
as the blue line in the bottom panel of Fig.~\ref{fig:plot-Kalman-heading}.
The estimate of error usually has large uncertainty as estimated from
the covariance estimate from the Kalman filter. As in the top panel,
the regions of low uncertainty are confined to the turns where horizontal
accelerations are significant. To avoid large corrections with high
uncertainty, a \index{smoothing}smoothing spline\footnote{The ``smooth.spline()'' function\index{function!spline} provided
by the ``stats'' \index{R language!package!stats}package in R \citet{Rlanguage}
was used, with parameter ``spar=1.1'' to give strong smoothing.} that uses weight \index{spline!weight factors}factors inversely
proportional to the covariance leads to the red line in Fig.~\ref{fig:plot-Kalman-heading},
for which the mean \index{error!heading!spline fit}error is $<0.002^{\circ}$
and the standard deviation\index{deviation, standard!heading correction}
for individual \index{heading!uncertainty}\index{heading!correction!uncertainty}measurements
is about 0.02$^{\circ}$. Another test of the heading error is provided
by the correction algorithm\index{algorithm!simplier!correct heading}
``Ranadu::CorrectHeading()'' from Sect.~\ref{subsec:CorrectHeading},
which gives a mean and standard deviation of \Sexpr{round(mean(D1$HC[r], na.rm=TRUE),3)}$\pm$\Sexpr{round(sd(D1$HC[r], na.rm=TRUE),3)}
as shown by the green line in the figure. Perhaps the best interpretation
for this flight is that, within about 0.02$^{\circ}$ uncertainty,
there is no heading error. However, in general the spline fit representing
the result from the Kalman filter appears to be the preferable correction
to the heading.

\index{correction to heading!caution re use}The results reported
by the INS are those that have been used during its internal \index{mechanization}mechanization
to find, for example, the ground-speed\index{ground speed} components
and the \index{acceleration!l-frame@\emph{l-}frame}\emph{l-}frame
accelerations.\index{heading!imposed offset} In processed data sets,
it has been common to introduce adjustments\index{heading!imposed offset}
to the heading or, less often, the pitch to improve the wind measurements
during calibration\index{maneuver!calibration} maneuvers. It is particularly
common to find an offset in \index{heading!imposed offset}heading
that was introduced to give better agreement for winds during reverse-heading
maneuvers.\index{maneuver!reverse heading} However, it is difficult
to separate an offset in sideslip from an offset in heading, as discussed
in the NCAR Technical Note on uncertainty in wind measurements. It
now appears that the offset often introduced to \index{heading!offset}heading
should have instead been an offset in sideslip. Because these offsets
are introduced after the INS has performed its internal calculations,
the Kalman filter has no mechanism for detecting that an offset has
been introduced and will still produce estimates of heading \index{error!heading!effect of imposed offset}error
applicable to the original measurements. It is therefore important
to remove any ad hoc adjustments that have been introduced to heading
or other INS-provided variables before applying the Kalman filter.

\clearpage

\section{New variables for wind\label{sec:KF-variables}}

\subsection{Calculating the wind\label{subsec:KF-wind}}

\subsubsection{The vertical wind\label{subsec:KF-vertical-wind}}

\index{wind!{*}{*}}\index{wind!vertical!{*}{*}}\index{Kalman filter!results!new variables}The
result of the Kalman filter is that new corrected \index{velocity of aircraft!{*}{*}}\index{pitch!{*}{*}}\index{heading!{*}{*}}variables\index{variables!new from Kalman filter}
\{\sindex[var]{LATKF: latitude, Kalman filter}LATKF, \sindex[var]{LONKF: longitude, Kalman filter}LONKF,
\sindex[var]{ALTKF: altitude, Kalman filter}ALTKF, \sindex[var]{VEWKF: ground speed eastward, Kalman filter}VEWKF,
\sindex[var]{VNSKF: ground speed northward, Kalman filter}VNSKF,
\sindex[var]{ROCKF: rate of climb, Kalman filter}ROCKF, \sindex[var]{PITCHKF: pitch angle, Kalman filter}PITCHKF,
\sindex[var]{ROLLKF: roll angle, Kalman filter}ROLLKF, and \sindex[var]{THDGKF: heading, Kalman filter}THDGKF\}
are available. These and the variables\index{variables!standard|see {variable in data files}}
\{\sindex[var]{TASX: airspeed, relative wind}TASX, \sindex[var]{ATTACK|see {also AKRD}}ATTACK,
\sindex[var]{SSLIP: sideslip, radome}SSLIP\}\index{variable in data files!TASX}\index{variable in data files!ATTACK}\index{variable in data files!SSLIP}
can be used in a new calculation of the vector wind.\index{wind!calculation!Kalman-based}
For the vertical wind, the new variable PITCHKF should be superior
to the original variable \sindex[var]{PITCH: pitch angle, INS}PITCH
and should lead to some improvement. The other critical \index{rate of climb}measurement
used to calculate vertical wind is the rate-of-climb of the aircraft,
for which there are two options: \index{ROC=rate of climb}ROCKF\sindex[var]{ROCKF: rate of climb, Kalman filter}
and \sindex[var]{GGVSPD: rate of climb, GPS}GGVSPD.\index{variable in data files!GGVSPD}
The former uses the accelerations\index{acceleration!measurement}
 from the INS\index{navigation system!inertial} and so should have
the best \index{spectral characteristics!high frequency}high-frequency
characteristics, although \index{navigation system!GPS}GPS receivers
provide very good measurements now even at high frequency. The other
difference between these two choices is that if \sindex[var]{GGVSPD: rate of climb, GPS}GGVSPD
is used then a correction is needed for the separation\index{navigation system!GPS!antenna location}
of the \index{navigation system, GPS!antenna location}GPS antenna
from the INS\@. ROCKF is based on measurements from the INS, with
slow updating to the GPS value through the Kalman filter, so it does
not need such a correction.\footnote{An aspect of the corrected vertical wind that needs further investigation
is the relative timing of measurements entering the calculation, especially
the \index{navigation system!inertial}INS-provided variables PITCH
and ACINS\index{variable in data files!ACINS} as they might be offset
from the vertical component of the \index{wind!relative}relative
wind as determined from the airspeed\index{airspeed} (\sindex[var]{TASX: airspeed, relative wind}TASX)
and angle of attack (\sindex[var]{AKRD: angle of attack, radome}AKRD).\index{angle of attack}\index{variable in data files!AKRD}}

<<wind-calculation, include=TRUE, cache=CACHE>>=

# source ('chunks/wind-calculation.R')
## wind-calculation.R

## get the wind variables:
DataW <- D1
DataN <- WindProcessor (DataW)
D1$WICC <- DataN$WIN
D1$WDCC <- DataN$WDN
D1$WSCC <- DataN$WSN
DataW$PITCH <- D1$PITCHKF
DataW$ROLL <- D1$ROLLKF
DataW$THDG <- D1$THDGKF
DataW$VEW <- D1$VEWKF
DataW$VNS <- D1$VNSKF
DataW$GGVSPD <- D1$ROCKF
DataN <- WindProcessor(DataW, LG=0, CompF=FALSE)    ## suppress comp filter and GPS lever arm)
D1$WDKF <- DataN$WDN
D1$WSKF <- DataN$WSN
D1$WIKF <- DataN$WIN
## add longitudinal and lateral components analogous to UXC and VYC:
.hdg <- D1$THDGKF * Cradeg
.wd <- D1$WDKF * Cradeg + pi
D1$UXKF <- D1$WSKF * (sin(.hdg)*sin(.wd) + cos(.hdg)*cos(.wd))
.hdg <- .hdg - pi/2
D1$VYKF <- D1$WSKF * (sin(.hdg)*sin(.wd) + cos(.hdg)*cos(.wd))
DataW$GGVSPD <- D1[, VROC]
DataN <- WindProcessor(DataW, CompF=FALSE)    ## suppress comp filter and GPS lever arm)
D1$WIKFG <- DataN$WIN
sdWIdif <- sd(D1$WIKF[r]-D1$WICC[r], na.rm=TRUE)


@

Figure~\ref{fig:Variance-spectra-ROC} shows a comparison\index{comparison!plot!variance spectra!Kalman filter}
of the variance spectra\index{spectrum!variance} from the \index{navigation system!GPS}GPS-based
value (\sindex[var]{GGVSPD: rate of climb, GPS}GGVSPD) and the Kalman-filter
\index{ROC=rate of climb}value (\sindex[var]{ROCKF: rate of climb, Kalman filter}ROCKF).
The spectra are nearly identical, but GGVSPD appears to have some
\index{spectral characteristics!high frequency}high-frequency noise
not present in ROCKF. At these high frequencies, both have contributions
to the vertical wind that are insignificant in comparison to that
from the relative \index{wind!relative}wind (air motion relative
to the aircraft), so it will make little difference which is used
in wind calculations,\index{wind!calculation} but ROCKF is the preferred
choice because high-frequency fluctuations in rate of climb are probably
not present.

\begin{figure}
\begin{centering}
\includegraphics[width=0.85\textwidth]{ROCGGVSPDMEMPlot}
\par\end{centering}
\caption[Variance spectra for the rate-of-climb measurements from the GPS receiver and the integrated INS-provided acceleration.]{\index{spectrum!variance!rate of climb}Variance \index{spectrum!variance}spectra for the rate-of-climb \index{rate of climb!variance spectrum}measurements from the \index{navigation system!GPS}GPS receiver (GGVSPD) and the integrated INS-provided acceleration\index{acceleration!vertical} adjusted to match the rate of climb required by the hydrostatic equation \index{ROC=rate of climb}(ROCKF). The thin red line shows the spectrum without smoothing for ROCKF; other lines have been smoothed in 50 bins in the logarithm of frequency. Data from a region with intense waves encountered during \index{DEEPWAVE research project}DEEPWAVE flight 16 on 4 July 2014 over New Zealand.\label{fig:Variance-spectra-ROC}}

\end{figure}

Variance \index{spectrum!variance}spectra for the \index{wind!vertical!variance spectrum}\index{wind!vertical!variance spectrum}measurements
of vertical wind for the same flight segment are shown in \sindex[var]{WIC: vertical wind, GPS corrected}\sindex[var]{WIKF: vertical wind, Kalman filter}Fig.~\ref{fig:Variance-spectra-WI}.
There are small but significant differences, particularly for frequencies
around 0.1~Hz where the rate of climb makes an important contribution
to the measurement of vertical wind. (At higher frequencies, the relative
wind makes the dominating contribution; at lower frequencies, the
aircraft is controlled to maintain altitude so again the relative
wind is dominant.)\index{ROC=rate of climb}ROCKF\sindex[var]{ROCKF: rate of climb, Kalman filter}\sindex[var]{GGVSPD: rate of climb, GPS}\sindex[var]{ACINS: vertical acceleration, INS}ACINS)\index{variable in data files!ACINS}
A comparison of the two measurements of vertical wind is shown in
\index{ROC=rate of climb}\index{DEEPWAVE research project}Fig.~\ref{fig:plot-WIC}.\index{comparison!plot!variance spectra!rate of climb}
While the two represent almost the same signal, the differences at
any given time can be significant, as emphasized by the bottom panel
in the figure. The standard deviation\index{deviation, standard!velocity difference}
of the difference between measurements for the interval shown in this
figure is \Sexpr{round(sd(D1$WIKF[r]-D1$WICC[r], na.rm=TRUE), 2)}~m/s,
so the difference is the same as the claimed uncertainty in measuried
vertical wind. The evidence from Sect.~\ref{subsec:Roll-and-pitch}
indicates that the standard uncertainty in pitch has been reduced
from an estimated error of 0.02$^{\circ}$ to 0.01$^{\circ}$. This
is the dominant source of error in the measured vertical wind; its
inclusion in the uncertainty estimate for vertical wind indicates
reduction in the standard uncertainty from about 0.12~m/s to about
0.07~m/s.

\begin{figure}
\begin{centering}
\includegraphics[width=0.85\textwidth]{WIKFWICMEMPlot}
\par\end{centering}
\caption[Variance spectra for two measurements of the vertical wind, WIKF as adjusted by the Kalman filter and WIC from conventional data processing.]{\index{spectrum!variance!vertical wind}Variance \index{spectrum!variance}spectra for two \index{wind!vertical!variance spectrum}\index{wind!vertical!variance spectrum}measurements of the vertical \index{wind!vertical!Kalman filter}wind, WIKF as adjusted by the Kalman filter and WIC from conventional data processing.\index{data processing!conventional} The thin red line shows the spectrum without smoothing for WIKF; other lines have been smoothed in 50 logarithmic frequency bins. Measurements from a region where intense waves were encountered during \index{DEEPWAVE research project}DEEPWAVE flight 16, 4 July 2014. \label{fig:Variance-spectra-WI}} 

\end{figure}

<<plot-WIC, include=TRUE, fig.scap="Vertical wind calculated using the results from the Kalman filter, compared to the original calculation before Kalman-filter correction.", fig.cap='Vertical wind calculated using the results from the Kalman filter, compared to the original calculation before Kalman-filter correction. The difference is shown in the bottom panel. The result labeled "Kalman" is calculated using ROCKF and other results after correction by the Kalman filter, while WIC was calculated using GGVSPD from the GPS for the rate-of-climb of the aircraft. Data from a segment of DEEPWAVE flight 16 where intense waves were encountered.', cache=CACHE>>=

# layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
# op <- par (mar=c(2,4,1,1)+0.1)
# with(D1[setRange(D1, 83400, 83800),], plotWAC (data.frame(Time, WIKF, WICC),
#                                                    legend.position=NA))
# legend ('bottomleft', legend=c('WIKF', 'WIC'), col=c('blue', 'darkgreen'), lwd=c(2,1), cex=0.8)
# op <- par (mar=c(5,4,1,1)+0.1)
# with(D1[setRange(D1, 83400, 83800),], plotWAC (data.frame(Time, WIKF-WICC), ylab='WIKF-WIC'))
# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
ggplotWAC(
  with(D1[setRange(D1, 83400, 83800), ], 
       data.frame (Time, 'Kalman'=WIKF, 'original'=WICC, "DWI"=WIKF-WICC, 'SKIP'=WIKF*0)),
       col=c('blue', 'red'), lwd=c(1.4,0.8,1,0), lty=c(1,42),
       ylab=expression(paste('vertical wind [m ', s^-1, ']')),
       panels=2,
       labelL=c('Kalman', 'original'),
       labelP=c('variables', 'difference'),
       legend.position=c(0.8,0.94), theme.version=1
)

@

\subsubsection{The horizontal wind}

\index{wind!{*}{*}}\index{wind!Kalman filter}The conventional measurements\index{wind!measurement!conventional}
of horizontal wind, provided by the direction \sindex[var]{WDC: wind direction, GPS corrected}WDC
and speed \sindex[var]{WSC: wind speed, GPS corrected}WSC, are based
on the \index{wind!relative}relative wind added to the ground-speed\index{ground speed}
components \sindex[var]{VEWC: ground speed eastward, GPS corrected}VEWC\index{variable in data files!VEWC}
and \sindex[var]{VNSC: ground speed northward, GPS corrected}VNSC.\index{variable in data files!VNSC}
These are adjusted in standard data processing to match the \index{navigation system!GPS}GPS-based
measurements via a complementary filter\index{filter!complementary}
that uses the slowly varying components from the GPS and the faster
varying components from the INS (\citet{Cooper2016ncartn}). This
complementary filter therefore should produce results quite similar
to the variables VEWKF\sindex[var]{VEWKF: ground speed eastward, Kalman filter}
and \sindex[var]{VNSKF: ground speed northward, Kalman filter}VNSKF
from the Kalman filter. For the example flight being used (\index{DEEPWAVE research project}DEEPWAVE
flight 16), the standard deviation\index{deviation, standard!difference in wind}
of the difference between the corrected measurements and the complementary-filter
results is 0.1~m/s and the mean difference is $<0.0001$~m/s, so
these are in very good agreement. These differences are plotted in
Fig.~\ref{fig:hw-plot}. The resulting measurements of horizontal
wind direction match with a standard deviation of 0.3$^{\circ}$ and
the magnitudes of the horizontal winds match with a standard deviation
of 0.1~m/s. In both variables the differences show a Schuler oscillation.\index{filter!centered}
\index{filter!recursive} The \index{wind!calculation!standard}complementary
filter uses a recursive filter that leaves a small residual from the
Schuler oscillation, so the corrected result from the Kalman filter
is preferable. The plot also shows some larger fluctuations in turns
that likely point to residual timing differences among the components
entering the calculation of the wind. The difference in heading between
the two measurements also would affect the measured horizontal \index{wind!measurement}wind,
but in this case the heading correction is small and slowly varying
so it will have little effect on the results.\footnote{The heading-change correction needed to account for the separation
\index{navigation system!GPS!antenna location}between the INS and
\index{navigation system, GPS!antenna location}GPS antenna has little
effect on the horizontal wind because both the Kalman filter and the
complementary filter smooth any short-term contributions to the GPS-based
measurements. For completeness, however, the \index{navigation system!GPS}GPS-based
\index{measurement!from GPS!correction to}measurements \sindex[var]{GGVEW: ground speed eastward, GPS}GGVEW
and \sindex[var]{GGVNS: ground speed northward, GPS}GGVNS have been
corrected for the effect of heading change before use in the Kalman
filter or the complementary filter.} 

Despite these small differences, representative \index{spectrum!variance}variance
spectra\index{wind!variance spectrum}\index{spectrum!variance!horizontal wind}
for the longitudinal and lateral wind\index{wind!lateral} overlap
in plots so well that the spectra are indistinguishable. An example
is shown in Fig.~\ref{fig:Variance-spectra-UXVY}.\sindex[var]{UXKF: longitudinal wind, Kalman filter}\sindex[var]{VYKF: lateral wind, Kalman filter}\sindex[var]{VYC: lateral wind, GPS corrected}\sindex[var]{UXC: longitudinal wind, GPS corrected}
Nevertheless, Fig.~\ref{fig:hw-plot}\index{wind!measurement!conventional}\index{wind!Kalman filter}
and the standard deviations\index{deviation, standard!difference in wind}
quoted above indicate that there are significant differences and that
the Kalman-filter reduces \index{error!wind, effect of Kalman filter}errors
in the horizontal wind by an amount that is significant in comparison
to the estimated uncertainty. The reduction in uncertainty arises
from the reduced uncertainty in heading, from about 0.10$^{\circ}$
to about 0.01$^{\circ}$, leaves heading as an insignificant source
of uncertainty in the lateral component of the horizontal wind and
reduces the standard uncertainty from 0.44~m/s to 0.22~m/s, using
the elemental contributions to uncertainty in \citet{Cooper2016ncartn},
Table 8 and the summary in that reference on p.~51. The remaining
uncertainty is now dominated by the uncertainty in meassurement of
sideslip, and recent studies of the sideslip using a laser air-motion
sensor suggest that there is still opportunity to improve that measurement
also.

<<GS-comparison, include=FALSE, eval=FALSE>>=

DT <- getNetCDF (fname, c('VEWC', 'VNSC'))
D1$VEWC <- DT$VEWC
D1$VNSC <- DT$VNSC
layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
op <- par (mar=c(2,4,1,1)+0.1)
with(D1[r,], plotWAC (data.frame(Time, VEWKF-GGVEW)))
op <- par (mar=c(5,4,1,1)+0.1)
with(D1[r,], plotWAC (data.frame(Time, VNSKF-GGVNS)))
op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset

@

<<hw-plot, include=TRUE, fig.scap="Differences between the conventional measurements of horizontal wind and the results from the Kalman filter.", fig.cap='Differences between the conventional measurements of horizontal wind (variables WDC and WSC) and the results from the Kalman filter (variables WDKF and WSKF).', cache=CACHE>>=

# layout(matrix(1:2, ncol = 1), widths = 1,  heights = c(5,6))
# op <- par (mar=c(2,4,1,1)+0.1)
# with(D1[r,], plotWAC (data.frame(Time, WDKF-WDCC), ylab='WDKF-WDC'))
# op <- par (mar=c(5,4,1,1)+0.1)
# with(D1[r,], plotWAC (data.frame(Time, WSKF-WSCC), ylab='WSKF-WSC'))
# op <- par (mfrow=c(1,1), mar=c(5,5,2,2)+0.1)  # reset
ggplotWAC(
  with(D1[r, ], 
       data.frame (Time, 'direction'=WDKF-WDCC, 'speed'=WSKF-WSCC)),
       ylab=expression(paste('KF correction [', degree, ' (top) or m ', s^-1, ' (bottom)]')),
       panels=2,
       labelL=c('Kalman correction'),
       labelP=c('direction', 'speed'),
       legend.position=c(0.8,0.94), theme.version=1
)

@

\begin{figure}
\begin{centering}
\includegraphics[width=0.85\textwidth]{UXVYMEMPlot}
\par\end{centering}
\caption[Variance spectra for the standard measurements of the longitudinal and lateral components of the horizontal wind and for the corresponding results after correction by the Kalman filter.]{\index{spectrum!variance!horizontal wind}Variance \index{spectrum!variance}spectra for the standard variables UXC and VYC, which are measurements of the longitudinal and lateral components of the horizontal wind\index{wind!lateral} relative to the orientation of the aircraft, and the corresponding results for the winds produced after correction by the Kalman filter (UXKF and VYKF). The thin red line shows the spectrum without smoothing for UXKF; the other lines have been smoothed in 50 logarithmic bins in frequency. Data are from \index{DEEPWAVE research project}DEEPWAVE flight 16, 4 July 2014, in waves over New Zealand.\label{fig:Variance-spectra-UXVY}} 

\end{figure}

<<create-new-netcdf, cache=FALSE>>=

# source ('chunks/create-new-netcdf.R')
## create-new-netcdf.R

fnew <- sub ('.nc', 'KF.nc', fname)
## beware: overwrites without warning!!
Z <- file.copy (fname, fnew, overwrite=TRUE)  ## BEWARE: overwrites without warning!!

# function to copy attributes from old variable (e.g., PITCH) to new one (e.g., PITCHKF)
copy_attributes <- function (atv, v, nfile) {
  for (i in 1:length(atv)) {
    aname <- names(atv[i])
    if (grepl ('name', aname)) {next}  # skips long and standard names
    if (grepl ('units', aname)) {next}
    if (grepl ('Dependencies', aname)) {next}
    if (grepl ('actual_range', aname)) {next}
    if (is.numeric (atv[[i]])) {
      ncatt_put (nfile, v, attname=aname, attval=as.numeric(atv[[i]]))
    } else {
      ncatt_put (nfile, v, attname=aname, attval=as.character (atv[[i]]))
    }
  }
}


@

\subsection{Adding the new variables to the netCDF file}

\index{netCDF file}The code shown in the box that follows adds one
variable to an existing newCDF \index{file!data}\index{file!netCDF}file,
renaming the resulting file with a name like PROJECTrf01KF.nc if the
original file was PROJECTrf01.nc. This can serve as a \index{netCDF variable!model for new}model
for adding such variables. See the ``.Rnw'' file\index{program!file}
for the actual code, which has additional statements to protect against
missing variables or substitute variables when some are missing and
to handle high-rate data files. This example\index{R language!code to add variable!example}
is included to serve as a template for other scripts that might want
to add variables to a netCDF file. The processing script ``KalmanFilter.R''
adds these variables in a similar way: \sindex[var]{LATKF: latitude, Kalman filter}LATKF,
\sindex[var]{LONKF: longitude, Kalman filter}LONKF, \sindex[var]{ALTKF: altitude, Kalman filter}ALTKF,
\sindex[var]{VEWKF: ground speed eastward, Kalman filter}VEWKF, \sindex[var]{VNSKF: ground speed northward, Kalman filter}VNSKF,
\sindex[var]{ROCKF: rate of climb, Kalman filter}ROCKF, \sindex[var]{PITCHKF: pitch angle, Kalman filter}PITCHKF,
\sindex[var]{ROLLKF: roll angle, Kalman filter}ROLLKF, \sindex[var]{THDGKF: heading, Kalman filter}THDGKF,
\sindex[var]{WDKF: wind direction, Kalman filter}WDKF, \sindex[var]{WSKF: wind speed, Kalman filter}WSKF,
\sindex[var]{WIKF: vertical wind, Kalman filter}WIKF, \sindex[var]{WICC: WIC recalculated}WICC,
\sindex[var]{WDCC: WDC recalculated}WDCC, \sindex[var]{WSCC: WSC recalculated}WSCC,
\sindex[var]{UXKF: longitudinal wind, Kalman filter}UXKF, \sindex[var]{VYKF: lateral wind, Kalman filter}VYKF.
All ending in KF are the same as the original name without KF but
after applying the correction from the Kalman filter. Three other
variables ending in CC are those calculated in the standard way but
with measurements from the GPS receiver corrected for the rotation
of the aircraft, which was not included in the original processing.
The table of variable names at the end of this technical note includes
definitions for these and the other netCDF variables that have been
used.

\subsubsection*{Example of code to add a variable:}
\begin{lyxcode}
\fbox{\begin{minipage}[t]{1\columnwidth - 2\fboxsep - 2\fboxrule}%
\begin{lyxcode}
\#\#~get~the~old~netCDF~variables:

D~<-~getNetCDF~(fname,~VarList)~~~~

\#\#~open~the~copy~of~the~old~file~for~writing:

netCDFfile~<-~nc\_open~(fnew,~write=TRUE)~

Rate~<-~1~~\#\#~the~data~rate~of~this~file

\#\#~retrieve~dimension~info~from~the~old~file

Dimensions~<-~attr~(D,~\textquotedbl{}Dimensions\textquotedbl{})

Dim~<-~Dimensions{[}{[}\textquotedbl{}Time\textquotedbl{}{]}{]}

\#\#~variables~to~add~to~the~netCDF~file:~(add~more)

VarNew~<-~c(\textquotedbl{}LATKF\textquotedbl{})~~~

VarOld~<-~c(\textquotedbl{}LAT\textquotedbl{})

VarUnits~<-~c(\textquotedbl{}degrees\textquotedbl{})

VarLongName~<-~c(\textquotedbl{}latitude,~KF\textquotedbl{})

VarStdName~<-~c(\textquotedbl{}INS~latitude,~Kalman-filter-corrected\textquotedbl{})

\#\#~create~the~new~variables

varCDF~<-~list~()

for~(i~in~1:length(VarNew))~\{~~\#\#~only~one~in~this~example

~~\#\#~create~the~new~variable~and~add~it~to~the~netCDF~file

~~varCDF{[}{[}i{]}{]}~<-~ncvar\_def~(VarNew{[}i{]},~~

~~~~~~~~~~~~~~~~~~~~units=VarUnits{[}i{]},~

~~~~~~~~~~~~~~~~~~~~dim=Dim,~

~~~~~~~~~~~~~~~~~~~~missval=as.single(-32767.),~prec=\textquotedbl{}float\textquotedbl{},~

~~~~~~~~~~~~~~~~~~~~longname=VarLongName{[}i{]})

~~if~(i~==~1)~\{

~~~~newfile~<-~ncvar\_add~(netCDFfile,~varCDF{[}{[}i{]}{]})

~~\}~else~\{

~~~~newfile~<-~ncvar\_add~(newfile,~varCDF{[}{[}i{]}{]})

~~\}

~~\#\#~transfer~attributes~from~the~old~variable~and~add~new~ones

~~ATV~<-~ncatt\_get~(netCDFfile,~VarOld{[}i{]})

~~copy\_attributes~(ATV,~VarNew{[}i{]},~newfile)

~~ncatt\_put~(newfile,~VarNew{[}i{]},~attname=\textquotedbl{}standard\_name\textquotedbl{},~

~~~~~~~~~~~~~attval=VarStdName{[}i{]})

~~\#\#~add~the~measurements~for~the~new~variable

~~ncvar\_put~(newfile,~varCDF{[}{[}i{]}{]},~D1{[},~VarNew{[}i{]}{]})

\}

\#\#~then~close~to~write~the~new~file

nc\_close~(newfile)
\end{lyxcode}
%
\end{minipage}}\index{latitude!Kalman filter}
\end{lyxcode}
<<modify-new-netcdf, include=TRUE>>=

# source ('chunks/modify-new-netcdf.R')
## modify-new-netcdf.R

## variables needed for attributes and new wind calculation:
VarList <- c('TASX', 'ATTACK', 'SSLIP', 'GGVEW', 'GGVNS', VROC, 'VEW', 'VNS', 'THDG', 'ROLL', 'PITCH',
             'LAT', 'LON', 'VSPD')
VarListRef <- VarList
FI <- DataFileInfo (fname)
VarList <- VarListRef

if (!('GGVSPD' %in% FI$Variables)) {
  if ('GGVSPDB' %in% FI$Variables) {
    VarList [which (VarList == 'GGVSPD')] <- 'GGVSPDB'
  } else if ('VSPD_A' %in% FI$Variables) {
    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_A'
  } else if ('VSPD_G' %in% FI$Variables) {
    VarList [which (VarList == 'GGVSPD')] <- 'VSPD_G'
  } else {
    print ('ERROR: no VSPD variable found')
    exit()
  }
}
for (Var in VarList) {
  if (!(Var %in% FI$Variables)) {
    print (sprintf (' required variable %s not found in file %s; skipping...', Var, fname))
    exit()
  }
}

netCDFfile <- nc_open (fnew, write=TRUE) 
Rate <- 1
Dimensions <- attr (D1, "Dimensions")
Dim <- Dimensions[["Time"]]
if ("sps25" %in% names (Dimensions)) {
  Rate <- 25
  Dim <- list(Dimensions[["sps25"]], Dimensions[["Time"]])
}
if ("sps50" %in% names (Dimensions)) {
  Rate <- 50
  Dim <- list(Dimensions[["sps50"]], Dimensions[["Time"]])
}
DATT <- D1  ## save to ensure that attributes are preserved

## variables to add to the netCDF file:
VarNew <- c('LATKF', 'LONKF', 'ALTKF', 'VEWKF', 'VNSKF', 'ROCKF', 'PITCHKF', 'ROLLKF', 'THDGKF',
            'WDKF', 'WSKF', 'WIKF', 'WICC', 'WDCC', 'WSCC', 'UXKF', 'VYKF')
VarOld <- c('LAT', 'LON', 'ALT', 'VEW', 'VNS', 'VSPD', 'PITCH', 'ROLL', 'THDG', 
            'WD', 'WS', 'WI', 'WIC', 'WDC', 'WSC', 'UXC', 'VYC')
VarUnits <- c('degrees', 'degrees', 'm', 'm/s', 'm/s', 'm/s', 'degrees', 'degrees', 'degrees',
              'degrees', 'm/s', 'm/s', 'm/s', 'degrees', 'm/s', 'm/s', 'm/s')
VarLongName <- c('latitude, KF', 'longitude, KF', 'altitude MSL, KF',
                 'eastward groundspeed, KF', 'northward groundspeed, KF', 'rate of climb, KF',
                 'pitch, KF', 'roll, KF', 'heading, KF',
                 'wind direction, KF', 'wind speed, KF', 'vertical wind, KF', 
                 'vertical wind, KF and GGVSPD', 'WIC recalc', 'WDC recalc', 'WSC recalc',
                 'longitudinal wind, KF', 'lateral wind, KF')
VarStdName <- c('INS latitude, Kalman-filter-corrected',
                'INS longitude, Kalman-filter-corrected',
                'INS altitude, Kalman-filter-corrected',
                'INS eastward ground speed, Kalman-filter-corrected',
                'INS northward ground speed, Kalman-filter-corrected',
                'INS rate of climb, Kalman-filter-corrected',
                'INS aircraft pitch angle, Kalman-filter-corrected',
                'INS aircraft roll angle, Kalman-filter-corrected',
                'INS aircraft true heading angle, Kalman-filter-corrected',
                'horizontal wind direction, Kalman-filter-corrected',
                'horizontal wind speed, Kalman-filter-corrected',
                'vertical wind speed, Kalman-filter-corrected',
                'original WIC, recalculated',
                'original WDC, recalculated',
                'original WSC, recalculated',
                'longitudinal component of the horizontal wind, Kalman-filter-corrected',
                'lateral component of the horizontal wind, Kalman-filter-corrected')

## create the new variables
varCDF <- list ()
for (i in 1:length(VarNew)) {
  varCDF[[i]] <- ncvar_def (VarNew[i],  
                            units=VarUnits[i], 
                            dim=Dim, 
                            missval=as.single(-32767.), prec='float', 
                            longname=VarLongName[i])
  if (i == 1) {
    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
  } else {
    newfile <- ncvar_add (newfile, varCDF[[i]])
  }
  ATV <- ncatt_get (netCDFfile, VarOld[i])
  copy_attributes (ATV, VarNew[i], newfile)
  ncatt_put (newfile, VarNew[i], attname="standard_name", 
             attval=VarStdName[i])
  if (Rate == 1) {
    ncvar_put (newfile, varCDF[[i]], D1[, VarNew[i]])
  } else if (Rate == 25) {
    ncvar_put (newfile, varCDF[[i]], D1[, VarNew[i]], count=c(25, nrow(D1)/25))
  }
}
nc_close (newfile)


@

\section{Summary and conclusions}

An application of an \index{Kalman filter!error-state}error-state
Kalman filter\index{Kalman filter!primary value} has been developed
to improve the measurements of \index{wind!{*}{*}}wind provided by
the NSF/NCAR GV\index{aircraft!NSF/NCAR GV} research aircraft. The
primary advantage provided by the corrected measurements is \index{uncertainty!reduction in}reduction
in the uncertainty associated with the measurements of pitch and heading,
which without correction are the largest sources of uncertainty in
the measurements. The corrected measurements reduce the standard uncertainty
in measured vertical wind and the lateral component of the horizontal
wind to about 50\% of their previous values, to about 0.07 and 0.22~m\,s$^{-1}$.
The Kalman filter has a much smaller effect on the longitudinal component
of the horizontal wind because that uncertainty is determined mostly
by elemental contributions from the measurement of airspeed and temperature,
which are not affected by the Kalman filter, and only to a small extent
by the ground speed which is measured well by GPS without the Kalman
filter. The program that implements this procedure for correction
of the measurements can be used with data archives from past projects
as long as the measurements in those archived files include the aircraft
velocity from INS and GPS sources and the INS-based attitude angles.

\appendix

\section{Appendix: Reproducibility}

\index{reproducibility}This document is constructed in ways that
support duplication of the study. The code that generates the plots
and implements the Kalman filter is incorporated into the same \index{program!file}file
that generated this document via \LaTeX, using principles and techniques
described by \citet{Xie2014a} as implemented in the R \index{R language!package!knitr}package\index{knitr}
'knitr' (\citet{Xie2014b}). The program, 'KalmanFilterTechNote.Rnw',
is archived on 'GitHub' \index{GitHub repository}in the \index{repository!github}directory\index{archive!for this document}
at \href{https://github.com/WilliamCooper/KalmanFilterTechNote.git}{this URL}.
There is some \index{supplemental material}supplemental material
in that directory, including the workflow document\index{workflow document},
the bibliography and many code segments saved in the ``chunks''\index{R language!program chunks}
subdirectory, so the full directory should be downloaded in order
to run the program. The calculations use the programming \index{R language}language
\index{R language!program}\index{RStudio}R (\citet{Rlanguage})
and were run within \index{RStudio}RStudio (\citet{RStudio2012}),
so this is the most straightforward way to replicate the calculations
and the generation of this \index{program!generating this document}document.

A \index{R language!package!Ranadu}package named Ranadu,\index{R language!package!Ranadu}
containing auxillary \index{function!Ranadu}functions, is used extensively
in the R code. It is available on GitHub\index{GitHub repository}
as \href{https://github.com/WilliamCooper/Ranadu.git}{https://github.com/WilliamCooper/Ranadu.git}.
The version used for calculations in this technical note is included
in the 'zip' archive listed below.

The \index{file!data}data files used are also preserved in the NCAR
High Performance Storage System (HPSS)\index{HPSS archives} in files
that are available, and they can be provided via a \index{data!requesting}request
to \url{mailto:raf-dm@eol.ucar.edu}. The original files containing
the data as produced by the NCAR Earth Observing Laboratory, Research
Aviation Facility, were in \index{netCDF format}netCDF format (cf.~\href{http://www.unidata.ucar.edu/software/netcdf/}{this URL}),
but in many cases data archives were reprocessed and the files may
change after reprocessing so a separate archive\index{archive!for this document!data}
is maintained for this document. The data files\index{file!data!archive}
in this archive contain \index{R language!data.frames}R data.frames
and are preserved as binary-format 'Rdata' files via R 'save' commands.
The code in the GitHub archive has appropriate 'load' commands to
read these data files from a subdirectory named 'Data' (/Data or \textasciitilde{}/Data
or /home/Data) but this is not part of the GitHub repository because
it is too large to be appropriate there. To reproduce this research,
those data files have to be transferred separately from the NCAR HPSS
to the 'Data' \index{repository!data used}directory.

Extensive use has been made of \index{attributes!data.frame}\index{attributes!variable}attributes
assigned to the data.frames and the variables in those data.frames.
All the attributes from the original netCDF \index{file!netCDF}files
have been transferred, so there is a record of how the original data
were processed, for example recording \index{calibration!coefficients!used in processing}calibration
coefficients and processing chains for the variables. Once the data.frames
are loaded into R, these attributes can be viewed and provide additional
documentation of what data were used. Key information like the processing
date, the program version that produced the archive, and the selection
of primary variables for various measurements thus is preserved.

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}}  & KalmanFilterTechNote\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}}  & KalmanFilterTechNote.zip\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}}  & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}}  & KalmanFilterTechNote.Rnw\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}}  & /scr/raf\_data/DEEPWAVE/\index{DEEPWAVE research project} \tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}}  & \index{GitHub repository}https://github.com/WilliamCooper/KalmanFilterTechNote.git\tabularnewline
\end{tabular}

\clearpage
\phantomsection \addcontentsline{toc}{section}{References}

\label{sec:bibliography} 

\bibliographystyle{plainnat}
\bibliography{WAC}

\clearpage
\phantomsection \addcontentsline{toc}{section}{Variable Names and Acronyms}

\printindex[var]{}\index{Variable Names}

\clearpage
\phantomsection \addcontentsline{toc}{section}{Index}

\printindex[idx]{}

%\centerline{-- Blank Page, End of this Technical Report --}
\vfill\eject
\clearpage
\addcontentsline{toc}{section}{End}
\end{document}
